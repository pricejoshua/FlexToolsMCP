{
  "_schema": "unified-api-doc/2.0",
  "_generated_at": "2026-02-05T22:05:34.150533+00:00",
  "_source": {
    "type": "flexlibs2",
    "path": "D:/Github/flexlibs2",
    "description": "FlexLibs 2.0 - Deep Python wrapper for LibLCM (~90% coverage)"
  },
  "metadata": {
    "total_classes": 78,
    "total_methods": 1398,
    "total_properties": 52,
    "files_analyzed": 64,
    "categories": {
      "general": 15,
      "discourse": 6,
      "grammar": 8,
      "lexicon": 11,
      "lists": 6,
      "notebook": 5,
      "reversal": 2,
      "scripture": 6,
      "system": 5,
      "texts": 10,
      "wordform": 4
    },
    "lcm_interfaces_used": [
      "CellarPropertyType",
      "CellarPropertyTypeFilter",
      "FwObjDataTypes",
      "GenDate",
      "IAnalysis",
      "ICmAgent",
      "ICmAgentEvaluation",
      "ICmAgentEvaluationFactory",
      "ICmAgentFactory",
      "ICmAgentRepository",
      "ICmAnnotationDefn",
      "ICmAnnotationDefnFactory",
      "ICmAnnotationDefnRepository",
      "ICmAnthroItem",
      "ICmAnthroItemFactory",
      "ICmBaseAnnotation",
      "ICmBaseAnnotationFactory",
      "ICmFile",
      "ICmFileFactory",
      "ICmFilter",
      "ICmFilterFactory",
      "ICmFolder",
      "ICmFolderFactory",
      "ICmLocation",
      "ICmLocationFactory",
      "ICmMedia",
      "ICmMediaFactory",
      "ICmObjectRepository",
      "ICmPerson",
      "ICmPersonFactory",
      "ICmPersonRepository",
      "ICmPicture",
      "ICmPictureFactory",
      "ICmPossibility",
      "ICmPossibilityFactory",
      "ICmPossibilityList",
      "ICmPossibilityListFactory",
      "ICmPossibilityRepository",
      "ICmSemanticDomain",
      "ICmSemanticDomainFactory",
      "ICmTranslation",
      "ICmTranslationFactory",
      "IConstChartClauseMarker",
      "IConstChartClauseMarkerFactory",
      "IConstChartMovedTextMarker",
      "IConstChartMovedTextMarkerFactory",
      "IConstChartRow",
      "IConstChartRowFactory",
      "IConstChartTag",
      "IConstChartTagFactory",
      "IConstChartWordGroup",
      "IConstChartWordGroupFactory",
      "IDataReader",
      "IDsChart",
      "IDsConstChart",
      "IDsConstChartFactory",
      "IDsConstChartRepository",
      "IDsDiscourse",
      "IDsDiscourseData",
      "IDsDiscourseFactory",
      "IFsClosedFeature",
      "IFsComplexFeature",
      "IFsComplexFeatureFactory",
      "IFsFeatDefn",
      "IFsFeatStruc",
      "IFsFeatStrucFactory",
      "IFwMetaDataCacheManaged",
      "ILangProject",
      "ILexEntry",
      "ILexEntryFactory",
      "ILexEntryRef",
      "ILexEntryRefFactory",
      "ILexEntryRepository",
      "ILexEntryType",
      "ILexEntryTypeRepository",
      "ILexEtymology",
      "ILexEtymologyFactory",
      "ILexExampleSentence",
      "ILexExampleSentenceFactory",
      "ILexPronunciation",
      "ILexPronunciationFactory",
      "ILexRefType",
      "ILexRefTypeFactory",
      "ILexRefTypeRepository",
      "ILexReference",
      "ILexReferenceFactory",
      "ILexSense",
      "ILexSenseFactory",
      "ILexSenseRepository",
      "IMoAffixAllomorphFactory",
      "IMoAffixProcessFactory",
      "IMoForm",
      "IMoInflClass",
      "IMoInflClassFactory",
      "IMoMorphSynAnalysis",
      "IMoMorphType",
      "IMoStemAllomorphFactory",
      "IMoStemMsaFactory",
      "IMultiString",
      "IMultiUnicode",
      "IPartOfSpeech",
      "IPartOfSpeechFactory",
      "IPhCode",
      "IPhCodeFactory",
      "IPhEnvironment",
      "IPhEnvironmentFactory",
      "IPhIterationContextFactory",
      "IPhNCSegments",
      "IPhNCSegmentsFactory",
      "IPhNaturalClass",
      "IPhPhoneme",
      "IPhPhonemeFactory",
      "IPhRegularRuleFactory",
      "IPhSegRuleRHSFactory",
      "IPhSegmentRuleFactory",
      "IPhSimpleContextNCFactory",
      "IPhSimpleContextSegFactory",
      "IReversalIndex",
      "IReversalIndexEntry",
      "IReversalIndexEntryFactory",
      "IReversalIndexFactory",
      "IReversalIndexRepository",
      "IRnGenericRec",
      "IRnGenericRecFactory",
      "IRnResearchNbkRepository",
      "IScrBook",
      "IScrBookAnnotations",
      "IScrBookAnnotationsFactory",
      "IScrBookFactory",
      "IScrBookRepository",
      "IScrDraft",
      "IScrDraftFactory",
      "IScrScriptureNote",
      "IScrScriptureNoteFactory",
      "IScrSection",
      "IScrSectionFactory",
      "IScrTxtPara",
      "IScrTxtParaFactory",
      "IScripture",
      "ISegment",
      "ISegmentFactory",
      "ISegmentRepository",
      "IStStyle",
      "IStText",
      "IStTextFactory",
      "IStTxtPara",
      "IStTxtParaFactory",
      "IStTxtParaRepository",
      "IText",
      "ITextFactory",
      "ITextRepository",
      "ITsStrBldr",
      "ITsString",
      "IUndoStackManager",
      "IVariantComponentLexeme",
      "IWfiAnalysis",
      "IWfiAnalysisFactory",
      "IWfiAnalysisRepository",
      "IWfiGloss",
      "IWfiGlossFactory",
      "IWfiGlossRepository",
      "IWfiMorphBundle",
      "IWfiMorphBundleFactory",
      "IWfiWordform",
      "IWfiWordformFactory",
      "IWfiWordformRepository",
      "LcmDataMigrationForbiddenException",
      "LcmFileLockedException",
      "LcmInvalidClassException",
      "LcmInvalidFieldException",
      "LexEntryRefTags",
      "LexEntryTags",
      "LexExampleSentenceTags",
      "LexRefTypeTags",
      "LexSenseTags",
      "MoFormTags",
      "MoMorphTypeTags",
      "ReflectionHelper",
      "ReversalIndexEntryTags",
      "SpecialWritingSystemCodes",
      "TextTags",
      "TsStringUtils",
      "WfiAnalysisTags",
      "WfiGlossTags",
      "WfiMorphBundleTags",
      "WfiWordformTags",
      "WorkerThreadException"
    ]
  },
  "entities": {
    "BaseOperations": {
      "name": "BaseOperations",
      "type": "class",
      "namespace": "FlexLibs2.BaseOperations",
      "source_file": "BaseOperations",
      "category": "general",
      "summary": "Base class for all FLEx operation classes.",
      "description": "Base class for all FLEx operation classes.\n\nProvides common reordering functionality that works with any FLEx\nOwning Sequence (OS) collection. Subclasses must override _GetSequence()\nto specify which OS property to reorder.\n\nAll 43 operation classes inherit from this base class, gaining access\nto 7 reordering methods without code duplication.\n\nReordering Safety:\n- Reordering is SAFE - preserves all data connections\n- GUIDs, references, properties, and children remain intact\n- Only changes the sequence position (index)\n- Uses safe Clear/Add pattern for all operations\n\nLinguistic Significance:\n- Reordering changes linguistic meaning and behavior\n- Senses: First sense is primary\n- Allomorphs: First matching allomorph selected by parser\n- Examples: Order may reflect preference or pedagogy\n- Reorder only when linguistically justified\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"MyProject\", writeEnabled=True)\n\nentry = list(project.LexiconAllEntries())[0]\n\n# All operation classes have these methods:\n\n# Sort senses alphabetically\nproject.Senses.Sort(entry,\nkey_func=lambda s: project.Senses.GetGloss(s))\n\n# Move sense up one position\nsense = entry.SensesOS[2]\nproject.Senses.MoveUp(entry, sense)\n\n# Move allomorph to specific index\nallo = entry.AlternateFormsOS[3]\nproject.Allomorphs.MoveToIndex(entry, allo, 0)\n\n# Swap two examples\nex1 = sense.ExamplesOS[0]\nex2 = sense.ExamplesOS[1]\nproject.Examples.Swap(ex1, ex2)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two items and return detailed differences.",
          "description": "Compare two items and return detailed differences.\n\nThis method is OPTIONAL for sync framework integration. Subclasses that\nwant to support the sync framework (flexlibs.sync) should implement this\nmethod to enable intelligent comparison and merging between projects.\n\nThe sync framework uses this method to:\n- Detect if two items (matched by GUID) have diverged\n- Generate detailed diff reports showing what changed\n- Support conflict detection in multi-way merges\n- Enable selective merge operations\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First item to compare (from source project)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second item to compare (from target project)."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional. Operations instance for item1's project. If None, uses self (assumes items from same project)."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional. Operations instance for item2's project. If None, uses self (assumes items from same project)."
            }
          ],
          "returns": "tuple: (is_different, differences) where: - is_different (bool): True if items differ in any way - differences (dict): Detailed differences with structure: { 'properties': { 'PropertyName': { 'source': value_in_item1, 'target': value_in_item2, 'type': 'modified'|'added'|'removed' }, ... }, 'children': { 'ChildSequenceName': { 'added': [guid1, guid2, ...], 'removed': [guid3, guid4, ...], 'modified': [guid5, guid6, ...] }, ... } } ",
          "raises": [
            "NotImplementedError: If subclass doesn't implement sync support.",
            "Example Implementation (in LexSenseOperations):",
            ">>> def CompareTo(self, sense1, sense2, ops1=None, ops2=None):",
            "...     '''Compare two senses for differences.'''",
            "...     if ops1 is None:",
            "...         ops1 = self",
            "...     if ops2 is None:",
            "...         ops2 = self",
            "...",
            "...     is_different = False",
            "...     differences = {'properties': {}, 'children': {}}",
            "...",
            "...     # Compare properties",
            "...     props1 = ops1.GetSyncableProperties(sense1)",
            "...     props2 = ops2.GetSyncableProperties(sense2)",
            "...",
            "...     for key in set(props1.keys()) | set(props2.keys()):",
            "...         val1 = props1.get(key)",
            "...         val2 = props2.get(key)",
            "...         if val1 != val2:",
            "...             is_different = True",
            "...             differences['properties'][key] = {",
            "...                 'source': val1,",
            "...                 'target': val2,",
            "...                 'type': 'modified'",
            "...             }",
            "...",
            "...     # Compare child sequences (examples)",
            "...     guids1 = {ex.Guid for ex in sense1.ExamplesOS}",
            "...     guids2 = {ex.Guid for ex in sense2.ExamplesOS}",
            "...",
            "...     added = guids2 - guids1",
            "...     removed = guids1 - guids2",
            "...",
            "...     if added or removed:",
            "...         is_different = True",
            "...         differences['children']['Examples'] = {",
            "...             'added': list(added),",
            "...             'removed': list(removed),",
            "...             'modified': []",
            "...         }",
            "...",
            "...     return is_different, differences",
            "Example Usage (by sync framework):",
            ">>> from flexlibs.sync import DiffEngine",
            ">>>",
            ">>> # Find matching senses by GUID in two projects",
            ">>> sense1 = project1.Senses.FindByGuid(guid)",
            ">>> sense2 = project2.Senses.FindByGuid(guid)",
            ">>>",
            ">>> # Compare them",
            ">>> is_diff, diffs = project1.Senses.CompareTo(",
            "...     sense1, sense2,",
            "...     ops1=project1.Senses,",
            "...     ops2=project2.Senses",
            "... )",
            ">>>",
            ">>> if is_diff:",
            "...     print(\"Sense has diverged between projects:\")",
            "...     for prop, details in diffs['properties'].items():",
            "...         print(f\"  {prop}: {details['source']} -> {details['target']}\")",
            "...",
            "...     for child_name, child_diffs in diffs['children'].items():",
            "...         if child_diffs['added']:",
            "...             print(f\"  {child_name} added: {len(child_diffs['added'])}\")",
            "...         if child_diffs['removed']:",
            "...             print(f\"  {child_name} removed: {len(child_diffs['removed'])}\")"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get dictionary of syncable properties for cross-project synchronization.",
          "description": "Get dictionary of syncable properties for cross-project synchronization.\n\nThis method is OPTIONAL for sync framework integration. Subclasses that\nwant to support the sync framework (flexlibs.sync) should implement this\nmethod to specify which properties can be safely synchronized between\nprojects.\n\nThe sync framework uses this method to:\n- Extract property values for comparison (DiffEngine)\n- Build property-level diffs showing what changed\n- Enable selective merging of individual properties (MergeOperations)\n- Support conflict resolution in multi-way syncs\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The FLEx object to extract properties from."
            }
          ],
          "returns": "dict: Property names mapped to their values. Keys should be property names (strings), values should be JSON-serializable when possible. For complex FLEx objects (MultiString, etc.), return appropriate representations. ",
          "raises": [
            "NotImplementedError: If subclass doesn't implement sync support.",
            "Example Implementation (in LexSenseOperations):",
            ">>> def GetSyncableProperties(self, sense):",
            "...     '''Get syncable properties from a sense.'''",
            "...     return {",
            "...         'Gloss': self.GetGloss(sense),",
            "...         'Definition': self.GetDefinition(sense),",
            "...         'PartOfSpeech': self.GetPartOfSpeech(sense),",
            "...         'SemanticDomains': self.GetSemanticDomains(sense),",
            "...         'ExampleCount': sense.ExamplesOS.Count,",
            "...         # Note: Don't include order-dependent items in properties",
            "...         # The sync framework handles OS sequences separately",
            "...     }",
            "Example Usage (by sync framework):",
            ">>> from flexlibs.sync import DiffEngine",
            ">>>",
            ">>> # Compare senses between two projects",
            ">>> props1 = project1.Senses.GetSyncableProperties(sense1)",
            ">>> props2 = project2.Senses.GetSyncableProperties(sense2)",
            ">>>",
            ">>> diff_engine = DiffEngine()",
            ">>> is_different, differences = diff_engine.CompareProperties(",
            "...     props1, props2",
            "... )",
            ">>>",
            ">>> if is_different:",
            "...     print(f\"Properties changed: {list(differences.keys())}\")",
            "...     for prop, (old_val, new_val) in differences.items():",
            "...         print(f\"  {prop}: {old_val} -> {new_val}\")"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveAfter",
          "signature": "MoveAfter(item_to_move, target_item)",
          "summary": "Move an item to position immediately after another item.",
          "description": "Move an item to position immediately after another item.\n\nPositions item_to_move directly after target_item in the sequence.\nBoth items must be in the same sequence (same parent). The parent\nis automatically determined by examining the items' Owner property.\n",
          "parameters": [
            {
              "name": "item_to_move",
              "type": "",
              "default": null,
              "description": "The item to reposition (object, not HVO)."
            },
            {
              "name": "target_item",
              "type": "",
              "default": null,
              "description": "The item after which to insert (object, not HVO)."
            }
          ],
          "returns": "bool: True if successful. ",
          "raises": [
            "ValueError: If items not in same sequence or not found."
          ],
          "example": "            >>> # Move primary sense to second position\n            >>> primary = entry.SensesOS[0]\n            >>> secondary = entry.SensesOS[1]\n            >>> project.Senses.MoveAfter(primary, secondary)\n            True\n\n            >>> # Move variant allomorph after default\n            >>> default = entry.AlternateFormsOS[0]\n            >>> variant = entry.AlternateFormsOS[3]\n            >>> project.Allomorphs.MoveAfter(variant, default)\n            True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveBefore",
          "signature": "MoveBefore(item_to_move, target_item)",
          "summary": "Move an item to position immediately before another item.",
          "description": "Move an item to position immediately before another item.\n\nPositions item_to_move directly before target_item in the sequence.\nBoth items must be in the same sequence (same parent). The parent\nis automatically determined by examining the items' Owner property.\n",
          "parameters": [
            {
              "name": "item_to_move",
              "type": "",
              "default": null,
              "description": "The item to reposition (object, not HVO)."
            },
            {
              "name": "target_item",
              "type": "",
              "default": null,
              "description": "The item before which to insert (object, not HVO)."
            }
          ],
          "returns": "bool: True if successful. ",
          "raises": [
            "ValueError: If items not in same sequence or not found."
          ],
          "example": "            >>> # Move secondary sense to become primary\n            >>> primary = entry.SensesOS[0]\n            >>> secondary = entry.SensesOS[2]\n            >>> project.Senses.MoveBefore(secondary, primary)\n            True\n\n            >>> # Move variant allomorph before default\n            >>> default = entry.AlternateFormsOS[0]\n            >>> variant = entry.AlternateFormsOS[3]\n            >>> project.Allomorphs.MoveBefore(variant, default)\n            True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveDown",
          "signature": "MoveDown(parent_or_hvo, item, positions=1)",
          "summary": "Move an item down (toward end) by specified number of positions.",
          "description": "Move an item down (toward end) by specified number of positions.\n\nMoves an item toward the end of the sequence. If the requested\nnumber of positions would move past the end, the item is clamped\nat the last index (no error raised).\n",
          "parameters": [
            {
              "name": "parent_or_hvo",
              "type": "",
              "default": null,
              "description": "The parent object or HVO containing the sequence."
            },
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The item to move (object, not HVO)."
            },
            {
              "name": "positions",
              "type": "",
              "default": 1,
              "description": "Number of positions to move down. Must be positive. Default is 1."
            }
          ],
          "returns": "int: Actual number of positions moved. May be less than requested if item reaches last index. Returns 0 if already at end. ",
          "raises": [
            "ValueError: If item not found in sequence.",
            "ValueError: If positions is negative or zero."
          ],
          "example": "            >>> # Move sense down one position (e.g., from index 1 to 2)\n            >>> sense = entry.SensesOS[1]\n            >>> moved = project.Senses.MoveDown(entry, sense)\n            >>> print(f\"Moved {moved} positions\")\n            Moved 1 positions\n\n            >>> # Demote primary sense significantly\n            >>> primary = entry.SensesOS[0]\n            >>> moved = project.Senses.MoveDown(entry, primary, positions=3)\n            >>> print(f\"Now at index {list(entry.SensesOS).index(primary)}\")\n            Now at index 3\n\n            >>> # Try to move past end (clamped)\n            >>> allo = entry.AlternateFormsOS[8]  # Count = 10\n            >>> moved = project.Allomorphs.MoveDown(entry, allo, positions=5)\n            >>> print(f\"Actually moved {moved} positions\")\n            Actually moved 1 positions\n\n            >>> # Already at end - no movement\n            >>> last = entry.SensesOS[entry.SensesOS.Count - 1]\n            >>> moved = project.Senses.MoveDown(entry, last)\n            >>> print(f\"Moved {moved} positions\")\n            Moved 0 positions\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveToIndex",
          "signature": "MoveToIndex(parent_or_hvo, item, new_index)",
          "summary": "Move an item to a specific index position.",
          "description": "Move an item to a specific index position.\n\nDirectly moves an item to the specified index. Other items are\nshifted accordingly. This is useful for absolute positioning.\n",
          "parameters": [
            {
              "name": "parent_or_hvo",
              "type": "",
              "default": null,
              "description": "The parent object or HVO containing the sequence."
            },
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The item to move (object, not HVO)."
            },
            {
              "name": "new_index",
              "type": "",
              "default": null,
              "description": "Target index (0-based). Must be valid index for current sequence length."
            }
          ],
          "returns": "bool: True if successful. ",
          "raises": [
            "ValueError: If item not found in sequence.",
            "IndexError: If new_index is out of range [0, count-1]."
          ],
          "example": "            >>> # Make third sense the primary sense\n            >>> third_sense = entry.SensesOS[2]\n            >>> project.Senses.MoveToIndex(entry, third_sense, 0)\n            True\n\n            >>> # Move allomorph to end\n            >>> allo = entry.AlternateFormsOS[1]\n            >>> last_index = entry.AlternateFormsOS.Count - 1\n            >>> project.Allomorphs.MoveToIndex(entry, allo, last_index)\n            True\n\n            >>> # Move example to middle position\n            >>> ex = sense.ExamplesOS[0]\n            >>> project.Examples.MoveToIndex(sense, ex, 2)\n            True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveUp",
          "signature": "MoveUp(parent_or_hvo, item, positions=1)",
          "summary": "Move an item up (toward index 0) by specified number of positions.",
          "description": "Move an item up (toward index 0) by specified number of positions.\n\nMoves an item toward the beginning of the sequence. If the requested\nnumber of positions would move past index 0, the item is clamped at\nindex 0 (no error raised).\n",
          "parameters": [
            {
              "name": "parent_or_hvo",
              "type": "",
              "default": null,
              "description": "The parent object or HVO containing the sequence."
            },
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The item to move (object, not HVO)."
            },
            {
              "name": "positions",
              "type": "",
              "default": 1,
              "description": "Number of positions to move up. Must be positive. Default is 1."
            }
          ],
          "returns": "int: Actual number of positions moved. May be less than requested if item reaches index 0. Returns 0 if already at index 0. ",
          "raises": [
            "ValueError: If item not found in sequence.",
            "ValueError: If positions is negative or zero."
          ],
          "example": "            >>> # Move sense up one position (e.g., from index 3 to 2)\n            >>> sense = entry.SensesOS[3]\n            >>> moved = project.Senses.MoveUp(entry, sense)\n            >>> print(f\"Moved {moved} positions\")\n            Moved 1 positions\n\n            >>> # Move allomorph to top (up 5 positions)\n            >>> allo = entry.AlternateFormsOS[5]\n            >>> moved = project.Allomorphs.MoveUp(entry, allo, positions=5)\n            >>> print(f\"Now at index {list(entry.AlternateFormsOS).index(allo)}\")\n            Now at index 0\n\n            >>> # Try to move past start (clamped at 0)\n            >>> example = sense.ExamplesOS[1]\n            >>> moved = project.Examples.MoveUp(sense, example, positions=10)\n            >>> print(f\"Actually moved {moved} positions\")\n            Actually moved 1 positions\n\n            >>> # Already at start - no movement\n            >>> first = entry.SensesOS[0]\n            >>> moved = project.Senses.MoveUp(entry, first)\n            >>> print(f\"Moved {moved} positions\")\n            Moved 0 positions\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Sort",
          "signature": "Sort(parent_or_hvo, key_func=None, reverse=False)",
          "summary": "Sort items in an owning sequence using a custom key function.",
          "description": "Sort items in an owning sequence using a custom key function.\n\nThis method reorders all items in the sequence according to a\nsorting criterion. The sort is stable and uses Python's built-in\nsort algorithm.\n",
          "parameters": [
            {
              "name": "parent_or_hvo",
              "type": "",
              "default": null,
              "description": "The parent object or HVO containing the sequence."
            },
            {
              "name": "key_func",
              "type": "",
              "default": null,
              "description": "Optional function(item) -> comparable_value. If None, uses natural ordering (may fail if items don't support comparison)."
            },
            {
              "name": "reverse",
              "type": "",
              "default": false,
              "description": "If True, sort in descending order. Default False."
            }
          ],
          "returns": "int: Number of items sorted (length of sequence). ",
          "raises": [
            "TypeError: If key_func is None and items don't support comparison.",
            "Exception: If any error occurs during sorting."
          ],
          "example": "            >>> # Sort allomorphs by form length\n            >>> project.Allomorphs.Sort(entry,\n            ...     key_func=lambda a: len(project.Allomorphs.GetForm(a)))\n            3\n\n            >>> # Sort senses alphabetically by gloss\n            >>> project.Senses.Sort(entry,\n            ...     key_func=lambda s: project.Senses.GetGloss(s))\n            5\n\n            >>> # Sort in reverse order (most complex first)\n            >>> def complexity(allo):\n            ...     env = project.Allomorphs.GetEnvironment(allo)\n            ...     return len(str(env)) if env else 0\n            >>> project.Allomorphs.Sort(entry,\n            ...     key_func=complexity,\n            ...     reverse=True)\n            3\n\n            >>> # Sort examples by length (shortest first)\n            >>> project.Examples.Sort(sense,\n            ...     key_func=lambda ex: len(project.Examples.GetText(ex)))\n            4\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Swap",
          "signature": "Swap(item1, item2)",
          "summary": "Swap the positions of two items in a sequence.",
          "description": "Swap the positions of two items in a sequence.\n\nExchanges the positions of two items. Both items must be in the\nsame sequence (same parent). The parent is automatically determined\nby examining the items' Owner property.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First item to swap (object, not HVO)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second item to swap (object, not HVO)."
            }
          ],
          "returns": "bool: True if successful. ",
          "raises": [
            "ValueError: If items not in same sequence or not found."
          ],
          "example": "            >>> # Swap first and second senses\n            >>> sense1 = entry.SensesOS[0]\n            >>> sense2 = entry.SensesOS[1]\n            >>> project.Senses.Swap(sense1, sense2)\n            True\n\n            >>> # Swap allomorphs\n            >>> allo1 = entry.AlternateFormsOS[0]\n            >>> allo2 = entry.AlternateFormsOS[3]\n            >>> project.Allomorphs.Swap(allo1, allo2)\n            True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize BaseOperations with a FLExProject instance.",
          "description": "Initialize BaseOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [],
      "tags": [
        "general",
        "operations"
      ]
    },
    "FP_ProjectError": {
      "name": "FP_ProjectError",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "Exception raised for any problems opening the project.",
      "description": "Exception raised for any problems opening the project.\n\nAttributes:\n- message -- explanation of the error",
      "example": "",
      "base_classes": [
        "Exception"
      ],
      "methods": [
        {
          "name": "__init__",
          "signature": "__init__(message)",
          "summary": "",
          "description": "",
          "parameters": [
            {
              "name": "message",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "FP_FileNotFoundError": {
      "name": "FP_FileNotFoundError",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "",
      "description": "",
      "example": "",
      "base_classes": [
        "FP_ProjectError"
      ],
      "methods": [
        {
          "name": "__init__",
          "signature": "__init__(projectName, e)",
          "summary": "",
          "description": "",
          "parameters": [
            {
              "name": "projectName",
              "type": "",
              "default": null
            },
            {
              "name": "e",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "FP_FileLockedError": {
      "name": "FP_FileLockedError",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "",
      "description": "",
      "example": "",
      "base_classes": [
        "FP_ProjectError"
      ],
      "methods": [
        {
          "name": "__init__",
          "signature": "__init__()",
          "summary": "",
          "description": "",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "FP_MigrationRequired": {
      "name": "FP_MigrationRequired",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "",
      "description": "",
      "example": "",
      "base_classes": [
        "FP_ProjectError"
      ],
      "methods": [
        {
          "name": "__init__",
          "signature": "__init__()",
          "summary": "",
          "description": "",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "FP_RuntimeError": {
      "name": "FP_RuntimeError",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "Exception raised for any problems running the module.",
      "description": "Exception raised for any problems running the module.\n\nAttributes:\n- message -- explanation of the error",
      "example": "",
      "base_classes": [
        "Exception"
      ],
      "methods": [
        {
          "name": "__init__",
          "signature": "__init__(message)",
          "summary": "",
          "description": "",
          "parameters": [
            {
              "name": "message",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "FP_ReadOnlyError": {
      "name": "FP_ReadOnlyError",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "",
      "description": "",
      "example": "",
      "base_classes": [
        "FP_RuntimeError"
      ],
      "methods": [
        {
          "name": "__init__",
          "signature": "__init__()",
          "summary": "",
          "description": "",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "FP_WritingSystemError": {
      "name": "FP_WritingSystemError",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "",
      "description": "",
      "example": "",
      "base_classes": [
        "FP_RuntimeError"
      ],
      "methods": [
        {
          "name": "__init__",
          "signature": "__init__(writingSystemName)",
          "summary": "",
          "description": "",
          "parameters": [
            {
              "name": "writingSystemName",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "FP_NullParameterError": {
      "name": "FP_NullParameterError",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "",
      "description": "",
      "example": "",
      "base_classes": [
        "FP_RuntimeError"
      ],
      "methods": [
        {
          "name": "__init__",
          "signature": "__init__()",
          "summary": "",
          "description": "",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "FP_ParameterError": {
      "name": "FP_ParameterError",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "",
      "description": "",
      "example": "",
      "base_classes": [
        "FP_RuntimeError"
      ],
      "methods": [
        {
          "name": "__init__",
          "signature": "__init__(msg)",
          "summary": "",
          "description": "",
          "parameters": [
            {
              "name": "msg",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "FLExProject": {
      "name": "FLExProject",
      "type": "class",
      "namespace": "FlexLibs2.FLExProject",
      "source_file": "FLExProject",
      "category": "general",
      "summary": "This class provides convenience methods for accessing a FieldWorks\nproject by hiding some of the complexity of LCM.",
      "description": "This class provides convenience methods for accessing a FieldWorks\nproject by hiding some of the complexity of LCM.\nFor functionality that isn't provided here, LCM data and methods\ncan be used directly via `FLExProject.project`, `FLExProject.lp` and\n`FLExProject.lexDB`.\nHowever, for long term use, new methods should be added to this class.\n\nUsage::\n\nfrom SIL.LCModel.Core.KernelInterfaces import ITsString, ITsStrBldr\nfrom SIL.LCModel.Core.Text import TsStringUtils\n\nproject = FLExProject()\ntry:\nproject.OpenProject(\"my project\",\nwriteEnabled = True/False)\nexcept:\n#\"Failed to open project\"\ndel project\nexit(1)\n\nWSHandle = project.WSHandle('en')\n\n# Traverse the whole lexicon\nfor lexEntry in project.LexiconAllEntries():\nheadword = project.LexiconGetHeadword(lexEntry)\n\n# Use get_String() and set_String() with text fields:\nlexForm = lexEntry.LexemeFormOA\nlexEntryValue = ITsString(lexForm.Form.get_String(WSHandle)).Text\nnewValue = convert_headword(lexEntryValue)\nmkstr = TsStringUtils.MakeString(newValue, WSHandle)\nlexForm.Form.set_String(WSHandle, mkstr)",
      "example": "",
      "base_classes": [
        "object"
      ],
      "methods": [
        {
          "name": "BestStr",
          "signature": "BestStr(stringObj)",
          "summary": "Generic string function for `MultiUnicode` and `MultiString`\nobjects, returning the best analysis or vernacular string.",
          "description": "Generic string function for `MultiUnicode` and `MultiString`\nobjects, returning the best analysis or vernacular string.\n",
          "parameters": [
            {
              "name": "stringObj",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "BuildGotoURL",
          "signature": "BuildGotoURL(objectOrGuid)",
          "summary": "Builds a URL that can be used with `os.",
          "description": "Builds a URL that can be used with `os.startfile()` to jump to the\nobject in Fieldworks. This method currently supports:\n\n- Lexical Entries, Senses and any object within the lexicon\n- Wordforms, Analyses and Wordform Glosses\n- Reversal Entries\n- Texts",
          "parameters": [
            {
              "name": "objectOrGuid",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CloseProject",
          "signature": "CloseProject()",
          "summary": "Save any pending changes and dispose of the LCM object.",
          "description": "Save any pending changes and dispose of the LCM object.",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllAnalysisWSs",
          "signature": "GetAllAnalysisWSs()",
          "summary": "Returns a set of language tags for all analysis writing systems used\nin this project.",
          "description": "Returns a set of language tags for all analysis writing systems used\nin this project.\n",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllSemanticDomains",
          "signature": "GetAllSemanticDomains(flat=False)",
          "summary": "Returns a nested or flat list of all semantic domains defined\nin this project.",
          "description": "Returns a nested or flat list of all semantic domains defined\nin this project. The list is ordered.\n\nReturn items are `ICmSemanticDomain` objects.\n\n.. note::\nThis method delegates to :meth:`SemanticDomainOperations.GetAll`.",
          "parameters": [
            {
              "name": "flat",
              "type": "",
              "default": false
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllVernacularWSs",
          "signature": "GetAllVernacularWSs()",
          "summary": "Returns a set of language tags for all vernacular writing systems used\nin this project.",
          "description": "Returns a set of language tags for all vernacular writing systems used\nin this project.\n",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAudioPath",
          "signature": "GetAudioPath(multistring_field, wsHandle)",
          "summary": "Extract the audio file path from an audio writing system field.",
          "description": "Extract the audio file path from an audio writing system field.\n\nAudio writing systems embed file paths in ITsString objects using\nObject Replacement Characters (ORC, U+FFFC) with FwObjDataTypes.kodtExternalPathName.\n",
          "parameters": [
            {
              "name": "multistring_field",
              "type": "",
              "default": null,
              "description": "ITsMultiString or similar field containing audio data"
            },
            {
              "name": "wsHandle",
              "type": "int",
              "default": null,
              "description": "Audio writing system handle"
            }
          ],
          "returns": "str: Audio file path, or None if not found ",
          "raises": [],
          "example": "            >>> # Get audio path from allomorph form\n            >>> form = proj.Allomorph.GetForm(allomorph)\n            >>> audio_ws = proj.WSHandle(\"en-Zxxx-x-audio\")\n            >>> audio_path = proj.GetAudioPath(form, audio_ws)\n            >>> if audio_path:\n            ...     print(f\"Audio file: {audio_path}\")\n\n        See also:\n            :meth:`IsAudioWritingSystem` - Check if WS is audio type\n            :meth:`SetAudioPath` - Set audio file path",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCustomFieldValue",
          "signature": "GetCustomFieldValue(senseOrEntryOrHvo, fieldID, languageTagOrHandle=None)",
          "summary": "Returns the field value for String, MultiString, Integer\nand List (both single and multiple) fields.",
          "description": "Returns the field value for String, MultiString, Integer\nand List (both single and multiple) fields.\nRaises `FP_ParameterError` for other field types.\n\n`languageTagOrHandle` only applies to MultiStrings; if `None` the\nbest analysis or venacular string is returned.\n",
          "parameters": [
            {
              "name": "senseOrEntryOrHvo",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateLastModified",
          "signature": "GetDateLastModified()",
          "summary": "",
          "description": "",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDefaultAnalysisWS",
          "signature": "GetDefaultAnalysisWS()",
          "summary": "Returns the default analysis writing system: (Language-tag, Name)\n",
          "description": "Returns the default analysis writing system: (Language-tag, Name)\n",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDefaultVernacularWS",
          "signature": "GetDefaultVernacularWS()",
          "summary": "Returns the default vernacular writing system: (Language-tag, Name)\n",
          "description": "Returns the default vernacular writing system: (Language-tag, Name)\n",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFieldID",
          "signature": "GetFieldID(className, fieldName)",
          "summary": "Return the `FieldID` ('flid') for the given field of an LCM class.",
          "description": "Return the `FieldID` ('flid') for the given field of an LCM class.\n`className` and `fieldName` are strings, where `fieldName` may omit\nthe type suffix (e.g. 'OS'). Both are case-sensitive.\nFor example, find the `FieldID` for academic domains with::\n\nGetFieldID(\"LexSense\", \"DomainTypes\")",
          "parameters": [
            {
              "name": "className",
              "type": "",
              "default": null
            },
            {
              "name": "fieldName",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLexicalRelationTypes",
          "signature": "GetLexicalRelationTypes()",
          "summary": "Returns an iterator over `LexRefType` objects, which define a\ntype of lexical relation, such as Part-Whole.",
          "description": "Returns an iterator over `LexRefType` objects, which define a\ntype of lexical relation, such as Part-Whole.\n\nEach `LexRefType` has:\n- `MembersOC`: containing zero or more `LexReference` objects.\n- `MappingType`: an enumeration defining the type of lexical relation.\n\n`LexReference` objects have:\n- `TargetsRS`: the `LexSense` or `LexEntry` objects in the relation.\n\nFor example::\n\nfor lrt in project.GetLexicalRelationTypes():\nif (lrt.MembersOC.Count > 0):\nfor lr in lrt.MembersOC:\nfor target in lr.TargetsRS:\nif target.ClassName == \"LexEntry\":\n# LexEntry\nelse:\n# LexSense\n\n.. note::\nThis method delegates to :meth:`LexReferenceOperations.GetAllTypes`.",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLinkedFilesDir",
          "signature": "GetLinkedFilesDir()",
          "summary": "Get the full path to the project's LinkedFiles directory.",
          "description": "Get the full path to the project's LinkedFiles directory.\n\nThe LinkedFiles directory contains media files organized in subdirectories:\n- AudioVisual/ - Audio and video files\n- Pictures/ - Image files\n- Others/ - Other linked files\n",
          "parameters": [],
          "returns": "str: Absolute path to LinkedFiles directory ",
          "raises": [],
          "example": "            >>> proj = FLExProject()\n            >>> linked_files = proj.GetLinkedFilesDir()\n            >>> print(linked_files)\n            C:\\FLExData\\MyProject\\LinkedFiles\n\n        See also:\n            :meth:`MediaOperations.GetInternalPath` - Get relative path within LinkedFiles\n            :meth:`MediaOperations.GetExternalPath` - Get full filesystem path",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPartsOfSpeech",
          "signature": "GetPartsOfSpeech()",
          "summary": "Returns a list of the parts of speech defined in this project.",
          "description": "Returns a list of the parts of speech defined in this project.\n\n.. note::\nThis method delegates to :meth:`POSOperations.GetAll`.",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPublications",
          "signature": "GetPublications()",
          "summary": "Returns a list of the names of the publications defined in the\nproject.",
          "description": "Returns a list of the names of the publications defined in the\nproject.\n\n.. note::\nThis method delegates to :meth:`PublicationOperations.GetAll`.",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetWritingSystems",
          "signature": "GetWritingSystems()",
          "summary": "Returns the writing systems that are active in this project as a\nlist of tuples: (Name, Language-tag, Handle, IsVernacular).",
          "description": "Returns the writing systems that are active in this project as a\nlist of tuples: (Name, Language-tag, Handle, IsVernacular).\nUse the Language-tag when specifying writing system to other\nfunctions.\n",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsAudioWritingSystem",
          "signature": "IsAudioWritingSystem(wsHandle)",
          "summary": "Check if a writing system is an audio writing system.",
          "description": "Check if a writing system is an audio writing system.\n\nAudio writing systems use the special script code \"Zxxx\" (no written form)\nand typically have \"audio\" in their tag. They store audio file paths\ninstead of text content.\n",
          "parameters": [
            {
              "name": "wsHandle",
              "type": "int",
              "default": null,
              "description": "Writing system handle to check"
            }
          ],
          "returns": "bool: True if this is an audio writing system, False otherwise ",
          "raises": [],
          "example": "            >>> ws_handle = proj.WSHandle(\"en-Zxxx-x-audio\")\n            >>> if proj.IsAudioWritingSystem(ws_handle):\n            ...     print(\"This is an audio writing system\")\n\n        See also:\n            :meth:`GetAudioPath` - Extract audio file path from audio WS field\n            :meth:`SetAudioPath` - Set audio file path in audio WS field",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAddAllomorph",
          "signature": "LexiconAddAllomorph(entry, form, morphType, languageTagOrHandle=None)",
          "summary": "Add an allomorph to an entry.",
          "description": "Add an allomorph to an entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The allomorph form"
            },
            {
              "name": "morphType",
              "type": "",
              "default": null,
              "description": "IMoMorphType object or name string"
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system"
            }
          ],
          "returns": "IMoForm: The newly created allomorph ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> morph_type = project.LexEntry.GetMorphType(entry)\n            >>> allomorph = project.LexiconAddAllomorph(entry, \"runn-\", morph_type)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAddComplexForm",
          "signature": "LexiconAddComplexForm(entry, components, complex_form_type)",
          "summary": "Add a complex form entry.",
          "description": "Add a complex form entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry - The complex form entry"
            },
            {
              "name": "components",
              "type": "",
              "default": null,
              "description": "list of ILexEntry or ILexSense - The component parts"
            },
            {
              "name": "complex_form_type",
              "type": "",
              "default": null,
              "description": "ILexEntryType - The type of complex form"
            }
          ],
          "returns": "ILexEntryRef: The newly created entry reference ",
          "raises": [],
          "example": "            >>> # Create a compound \"blackboard\" from \"black\" + \"board\"\n            >>> blackboard = project.LexEntry.Create(\"blackboard\", \"stem\")\n            >>> black = project.LexEntry.Find(\"black\")\n            >>> board = project.LexEntry.Find(\"board\")\n            >>> # Would need complex_form_type from project\n            >>> # ref = project.LexiconAddComplexForm(blackboard, [black, board], cf_type)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAddEntry",
          "signature": "LexiconAddEntry(lexeme_form, morph_type_name='stem', languageTagOrHandle=None)",
          "summary": "Create a new lexical entry.",
          "description": "Create a new lexical entry.\n",
          "parameters": [
            {
              "name": "lexeme_form",
              "type": "str",
              "default": null,
              "description": "The lexeme form (headword)"
            },
            {
              "name": "morph_type_name",
              "type": "str",
              "default": "stem",
              "description": "Morph type (\"stem\", \"root\", \"prefix\", etc.)"
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system"
            }
          ],
          "returns": "ILexEntry: The newly created entry ",
          "raises": [],
          "example": "            >>> entry = project.LexiconAddEntry(\"walk\", \"stem\")\n            >>> print(project.LexEntry.GetHeadword(entry))\n            walk\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAddPronunciation",
          "signature": "LexiconAddPronunciation(entry, form, languageTagOrHandle=None)",
          "summary": "Add a pronunciation to an entry.",
          "description": "Add a pronunciation to an entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The pronunciation form (IPA, etc.)"
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system"
            }
          ],
          "returns": "ILexPronunciation: The newly created pronunciation ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> pron = project.LexiconAddPronunciation(entry, \"rn\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAddSense",
          "signature": "LexiconAddSense(entry, gloss, languageTagOrHandle=None)",
          "summary": "Add a sense to a lexical entry.",
          "description": "Add a sense to a lexical entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            },
            {
              "name": "gloss",
              "type": "str",
              "default": null,
              "description": "The gloss text"
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system"
            }
          ],
          "returns": "ILexSense: The newly created sense ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> sense = project.LexiconAddSense(entry, \"to move rapidly\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAddTagToField",
          "signature": "LexiconAddTagToField(senseOrEntryOrHvo, fieldID, tag)",
          "summary": "Appends the tag string to the end of the given field in the\nsense or entry inserting a semicolon between tags.",
          "description": "Appends the tag string to the end of the given field in the\nsense or entry inserting a semicolon between tags.\nIf the tag is already in the field then it isn't added.",
          "parameters": [
            {
              "name": "senseOrEntryOrHvo",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            },
            {
              "name": "tag",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAddVariantForm",
          "signature": "LexiconAddVariantForm(entry, form, variant_type, languageTagOrHandle=None)",
          "summary": "Add a variant form to an entry.",
          "description": "Add a variant form to an entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The variant form"
            },
            {
              "name": "variant_type",
              "type": "",
              "default": null,
              "description": "ILexEntryType object or name string"
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system"
            }
          ],
          "returns": "ILexEntryRef: The newly created variant entry reference ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"color\")\n            >>> # This would typically need a variant type from the project\n            >>> # variant = project.LexiconAddVariantForm(entry, \"colour\", variant_type)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAllAllomorphs",
          "signature": "LexiconAllAllomorphs()",
          "summary": "Get all allomorphs in the entire project.",
          "description": "Get all allomorphs in the entire project.\n",
          "parameters": [],
          "returns": "IMoForm: Each allomorph in the project ",
          "raises": [],
          "example": "            >>> for allomorph in project.LexiconAllAllomorphs():\n            ...     form = project.Allomorphs.GetForm(allomorph)\n            ...     print(form)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAllEntries",
          "signature": "LexiconAllEntries()",
          "summary": "Returns an iterator over all entries in the lexicon.",
          "description": "Returns an iterator over all entries in the lexicon.\n\nEach entry is of type::\n\nSIL.LCModel.ILexEntry, which contains:\n- HomographNumber :: integer\n- HomographForm :: string\n- LexemeFormOA ::  SIL.LCModel.IMoForm\n- Form :: SIL.LCModel.MultiUnicodeAccessor\n- GetAlternative : Get String for given WS type\n- SetAlternative : Set string for given WS type\n- SensesOS :: Ordered collection of SIL.LCModel.ILexSense\n- Gloss :: SIL.LCModel.MultiUnicodeAccessor\n- Definition :: SIL.LCModel.MultiStringAccessor\n- SenseNumber :: string\n- ExamplesOS :: Ordered collection of ILexExampleSentence\n- Example :: MultiStringAccessor\n",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconAllEntriesSorted",
          "signature": "LexiconAllEntriesSorted()",
          "summary": "Returns an iterator over all entries in the lexicon sorted by\nthe (lower-case) headword.",
          "description": "Returns an iterator over all entries in the lexicon sorted by\nthe (lower-case) headword.",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconClearField",
          "signature": "LexiconClearField(senseOrEntryOrHvo, fieldID)",
          "summary": "Clears the string field or all of the strings (writing systems)\nin a multi-string field.",
          "description": "Clears the string field or all of the strings (writing systems)\nin a multi-string field.\nCan be used to clear out a custom field.",
          "parameters": [
            {
              "name": "senseOrEntryOrHvo",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconClearListFieldSingle",
          "signature": "LexiconClearListFieldSingle(senseOrEntry, fieldID)",
          "summary": "Clears the value for a 'single' (Atomic) list field.",
          "description": "Clears the value for a 'single' (Atomic) list field.",
          "parameters": [
            {
              "name": "senseOrEntry",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconDeleteObject",
          "signature": "LexiconDeleteObject(obj)",
          "summary": "Delete an object from the database.",
          "description": "Delete an object from the database.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object to delete (ILexEntry, ILexSense, IMoForm, etc.)"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "            >>> sense = entry.SensesOS[0]\n            >>> project.LexiconDeleteObject(sense)\n            >>> # Or delete entire entry:\n            >>> project.LexiconDeleteObject(entry)\n\n        Warning:\n            This is a destructive operation and cannot be undone.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconEntryAnalysesCount",
          "signature": "LexiconEntryAnalysesCount(entry)",
          "summary": "Returns a count of the occurrences of the entry in the text corpus.",
          "description": "Returns a count of the occurrences of the entry in the text corpus.\n\nNOTE: This calculation can produce slightly different results to\nthat shown in FieldWorks (where the same analysis in the same text\nsegment is only counted once in some displays). See LT-13997 for\nmore details.",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconFieldIsAnyStringType",
          "signature": "LexiconFieldIsAnyStringType(fieldID)",
          "summary": "Returns `True` if the given field is any of the string types.",
          "description": "Returns `True` if the given field is any of the string types.\n\nDelegates to: CustomFields.GetFieldType()",
          "parameters": [
            {
              "name": "fieldID",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconFieldIsMultiType",
          "signature": "LexiconFieldIsMultiType(fieldID)",
          "summary": "Returns `True` if the given field is a multi string type\n(MultiUnicode or MultiString)",
          "description": "Returns `True` if the given field is a multi string type\n(MultiUnicode or MultiString)\n\nDelegates to: CustomFields.IsMultiString()",
          "parameters": [
            {
              "name": "fieldID",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconFieldIsStringType",
          "signature": "LexiconFieldIsStringType(fieldID)",
          "summary": "Returns `True` if the given field is a simple string type suitable\nfor use with `LexiconAddTagToField()`, otherwise returns `False`.",
          "description": "Returns `True` if the given field is a simple string type suitable\nfor use with `LexiconAddTagToField()`, otherwise returns `False`.\n\nDelegates to: CustomFields.GetFieldType()",
          "parameters": [
            {
              "name": "fieldID",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetAllomorphCustomFields",
          "signature": "LexiconGetAllomorphCustomFields()",
          "summary": "Returns a list of the custom fields defined at allomorph level.",
          "description": "Returns a list of the custom fields defined at allomorph level.\nEach item in the list is a tuple of (flid, label)\n\nDelegates to: CustomFields.GetAllFields(\"MoForm\")",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetAllomorphForms",
          "signature": "LexiconGetAllomorphForms(entry, languageTagOrHandle=None)",
          "summary": "Get all allomorph forms for an entry.",
          "description": "Get all allomorph forms for an entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system"
            }
          ],
          "returns": "list: List of allomorph form strings ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> forms = project.LexiconGetAllomorphForms(entry)\n            >>> print(forms)\n            ['run', 'ran', 'runn-']\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetAlternateForm",
          "signature": "LexiconGetAlternateForm(entry, languageTagOrHandle=None)",
          "summary": "Returns the Alternate form for the entry in the Default Vernacular WS\nor other WS as specified by languageTagOrHandle.",
          "description": "Returns the Alternate form for the entry in the Default Vernacular WS\nor other WS as specified by languageTagOrHandle.",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetCitationForm",
          "signature": "LexiconGetCitationForm(entry, languageTagOrHandle=None)",
          "summary": "Returns the citation form for `entry` in the default vernacular WS\nor other WS as specified by `languageTagOrHandle`.",
          "description": "Returns the citation form for `entry` in the default vernacular WS\nor other WS as specified by `languageTagOrHandle`.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetComplexFormType",
          "signature": "LexiconGetComplexFormType(entry_ref)",
          "summary": "Get the complex form type of an entry reference.",
          "description": "Get the complex form type of an entry reference.\n",
          "parameters": [
            {
              "name": "entry_ref",
              "type": "",
              "default": null,
              "description": "ILexEntryRef object"
            }
          ],
          "returns": "ILexEntryType or None: The complex form type ",
          "raises": [],
          "example": "            >>> for ref in entry.EntryRefsOS:\n            ...     cf_type = project.LexiconGetComplexFormType(ref)\n            ...     if cf_type:\n            ...         print(cf_type.Name.BestAnalysisAlternative.Text)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetEntry",
          "signature": "LexiconGetEntry(index)",
          "summary": "Get a lexical entry by index.",
          "description": "Get a lexical entry by index.\n",
          "parameters": [
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "Zero-based index into all entries"
            }
          ],
          "returns": "ILexEntry: The entry at the specified index ",
          "raises": [],
          "example": "            >>> first_entry = project.LexiconGetEntry(0)\n            >>> tenth_entry = project.LexiconGetEntry(9)\n\n        Warning:\n            Inefficient for large lexicons - iterates through all entries.\n            Consider using LexEntry.Find() or LexEntry.GetAll() instead.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetEntryCustomFieldNamed",
          "signature": "LexiconGetEntryCustomFieldNamed(fieldName)",
          "summary": "Return the entry-level field ID given its name.",
          "description": "Return the entry-level field ID given its name.\n\nNOTE: `fieldName` is case-sensitive.\n\nDelegates to: CustomFields.FindField(\"LexEntry\", name)",
          "parameters": [
            {
              "name": "fieldName",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetEntryCustomFields",
          "signature": "LexiconGetEntryCustomFields()",
          "summary": "Returns a list of the custom fields defined at entry level.",
          "description": "Returns a list of the custom fields defined at entry level.\nEach item in the list is a tuple of (flid, label)\n\nDelegates to: CustomFields.GetAllFields(\"LexEntry\")",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetExample",
          "signature": "LexiconGetExample(example, languageTagOrHandle=None)",
          "summary": "Returns the example text in the default vernacular WS or\nother WS as specified by `languageTagOrHandle`.",
          "description": "Returns the example text in the default vernacular WS or\nother WS as specified by `languageTagOrHandle`.\n",
          "parameters": [
            {
              "name": "example",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetExampleCustomFields",
          "signature": "LexiconGetExampleCustomFields()",
          "summary": "Returns a list of the custom fields defined at example level.",
          "description": "Returns a list of the custom fields defined at example level.\nEach item in the list is a tuple of (flid, label)\n\nDelegates to: CustomFields.GetAllFields(\"LexExampleSentence\")",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetExampleTranslation",
          "signature": "LexiconGetExampleTranslation(translation, languageTagOrHandle=None)",
          "summary": "Returns the translation of an example in the default analysis WS or\nother WS as specified by `languageTagOrHandle`.",
          "description": "Returns the translation of an example in the default analysis WS or\nother WS as specified by `languageTagOrHandle`.\n\nNOTE: Analysis language translations of example sentences are\nstored as a collection (list). E.g.::\n\nfor translation in example.TranslationsOC:\nprint (project.LexiconGetExampleTranslation(translation))\n",
          "parameters": [
            {
              "name": "translation",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetFieldText",
          "signature": "LexiconGetFieldText(senseOrEntryOrHvo, fieldID, languageTagOrHandle=None)",
          "summary": "Return the text value for the given entry/sense and field ID.",
          "description": "Return the text value for the given entry/sense and field ID.\nProvided for use with custom fields.\nReturns the empty string if the value is null.\n`languageTagOrHandle` only applies to MultiStrings; if `None` the\ndefault analysis writing system is returned.\n",
          "parameters": [
            {
              "name": "senseOrEntryOrHvo",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetHeadWord",
          "signature": "LexiconGetHeadWord(entry)",
          "summary": "Get the headword of an entry.",
          "description": "Get the headword of an entry.\n\nThis is an alias for LexiconGetHeadword() for FlexTools compatibility.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            }
          ],
          "returns": "str: The headword ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> headword = project.LexiconGetHeadWord(entry)\n            >>> print(headword)\n            run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetHeadword",
          "signature": "LexiconGetHeadword(entry)",
          "summary": "Returns the headword for `entry`.",
          "description": "Returns the headword for `entry`.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetLexemeForm",
          "signature": "LexiconGetLexemeForm(entry, languageTagOrHandle=None)",
          "summary": "Returns the lexeme form for `entry` in the default vernacular WS\nor other WS as specified by `languageTagOrHandle`.",
          "description": "Returns the lexeme form for `entry` in the default vernacular WS\nor other WS as specified by `languageTagOrHandle`.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetMorphType",
          "signature": "LexiconGetMorphType(entry)",
          "summary": "Get the morph type of a lexical entry.",
          "description": "Get the morph type of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            }
          ],
          "returns": "IMoMorphType: The morph type object ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> morph_type = project.LexiconGetMorphType(entry)\n            >>> print(morph_type.Name.BestAnalysisAlternative.Text)\n            stem\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetPronunciation",
          "signature": "LexiconGetPronunciation(pronunciation, languageTagOrHandle=None)",
          "summary": "Returns the form for `pronunciation` in the default vernacular WS\nor other WS as specified by `languageTagOrHandle`.",
          "description": "Returns the form for `pronunciation` in the default vernacular WS\nor other WS as specified by `languageTagOrHandle`.\n",
          "parameters": [
            {
              "name": "pronunciation",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetPronunciations",
          "signature": "LexiconGetPronunciations(entry)",
          "summary": "Get all pronunciations for an entry.",
          "description": "Get all pronunciations for an entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            }
          ],
          "returns": "iterator: Iterator of ILexPronunciation objects ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> for pron in project.LexiconGetPronunciations(entry):\n            ...     form = project.Pronunciations.GetForm(pron)\n            ...     print(form)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetPublishInCount",
          "signature": "LexiconGetPublishInCount(entry)",
          "summary": "Returns the number of dictionaries that `entry` is configured\nto be published in.",
          "description": "Returns the number of dictionaries that `entry` is configured\nto be published in.",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetSense",
          "signature": "LexiconGetSense(entry, index)",
          "summary": "Get a sense by index from an entry.",
          "description": "Get a sense by index from an entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "Zero-based index"
            }
          ],
          "returns": "ILexSense or None: The sense at the index, or None if out of range ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> first_sense = project.LexiconGetSense(entry, 0)\n            >>> second_sense = project.LexiconGetSense(entry, 1)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetSenseByName",
          "signature": "LexiconGetSenseByName(entry, gloss_text, languageTagOrHandle=None)",
          "summary": "Find a sense by its gloss text.",
          "description": "Find a sense by its gloss text.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            },
            {
              "name": "gloss_text",
              "type": "str",
              "default": null,
              "description": "The gloss text to search for"
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system"
            }
          ],
          "returns": "ILexSense or None: The first sense with matching gloss, or None ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> sense = project.LexiconGetSenseByName(entry, \"to move rapidly\")\n            >>> if sense:\n            ...     print(f\"Found sense: {sense.Guid}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetSenseCustomFieldNamed",
          "signature": "LexiconGetSenseCustomFieldNamed(fieldName)",
          "summary": "Return the sense-level field ID given its name.",
          "description": "Return the sense-level field ID given its name.\n\nNOTE: `fieldName` is case-sensitive.\n\nDelegates to: CustomFields.FindField(\"LexSense\", name)",
          "parameters": [
            {
              "name": "fieldName",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetSenseCustomFields",
          "signature": "LexiconGetSenseCustomFields()",
          "summary": "Returns a list of the custom fields defined at sense level.",
          "description": "Returns a list of the custom fields defined at sense level.\nEach item in the list is a tuple of (flid, label)\n\nDelegates to: CustomFields.GetAllFields(\"LexSense\")",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetSenseDefinition",
          "signature": "LexiconGetSenseDefinition(sense, languageTagOrHandle=None)",
          "summary": "Returns the definition for the sense in the default analysis WS or\nother WS as specified by `languageTagOrHandle`.",
          "description": "Returns the definition for the sense in the default analysis WS or\nother WS as specified by `languageTagOrHandle`.\n",
          "parameters": [
            {
              "name": "sense",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetSenseGloss",
          "signature": "LexiconGetSenseGloss(sense, languageTagOrHandle=None)",
          "summary": "Returns the gloss for the sense in the default analysis WS or\nother WS as specified by `languageTagOrHandle`.",
          "description": "Returns the gloss for the sense in the default analysis WS or\nother WS as specified by `languageTagOrHandle`.\n",
          "parameters": [
            {
              "name": "sense",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetSenseNumber",
          "signature": "LexiconGetSenseNumber(sense)",
          "summary": "Returns the sense number for the sense.",
          "description": "Returns the sense number for the sense. (This is not available\ndirectly from `ILexSense`.)\n",
          "parameters": [
            {
              "name": "sense",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetSensePOS",
          "signature": "LexiconGetSensePOS(sense)",
          "summary": "Returns the part of speech abbreviation for the sense.",
          "description": "Returns the part of speech abbreviation for the sense.\n",
          "parameters": [
            {
              "name": "sense",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetSenseSemanticDomains",
          "signature": "LexiconGetSenseSemanticDomains(sense)",
          "summary": "Returns a list of semantic domain objects belonging to the sense.",
          "description": "Returns a list of semantic domain objects belonging to the sense.\n`ToString()` and `Hvo` are available.\n\nMethods available for SemanticDomainsRC::\n\nCount\nAdd(Hvo)\nContains(Hvo)\nRemove(Hvo)\nRemoveAll()\n",
          "parameters": [
            {
              "name": "sense",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconGetVariantType",
          "signature": "LexiconGetVariantType(variant)",
          "summary": "Get the variant type of a variant entry reference.",
          "description": "Get the variant type of a variant entry reference.\n",
          "parameters": [
            {
              "name": "variant",
              "type": "",
              "default": null,
              "description": "ILexEntryRef object"
            }
          ],
          "returns": "ILexEntryType: The variant type ",
          "raises": [],
          "example": "            >>> for variant_ref in entry.EntryRefsOS:\n            ...     var_type = project.LexiconGetVariantType(variant_ref)\n            ...     if var_type:\n            ...         print(var_type.Name.BestAnalysisAlternative.Text)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconNumberOfEntries",
          "signature": "LexiconNumberOfEntries()",
          "summary": "",
          "description": "",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconNumberOfSenses",
          "signature": "LexiconNumberOfSenses(entry)",
          "summary": "Get the number of senses in a lexical entry.",
          "description": "Get the number of senses in a lexical entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            }
          ],
          "returns": "int: Number of senses ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> count = project.LexiconNumberOfSenses(entry)\n            >>> print(f\"Entry has {count} senses\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSenseAnalysesCount",
          "signature": "LexiconSenseAnalysesCount(sense)",
          "summary": "Returns a count of the occurrences of the sense in the text corpus.",
          "description": "Returns a count of the occurrences of the sense in the text corpus.\n",
          "parameters": [
            {
              "name": "sense",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSetComplexFormType",
          "signature": "LexiconSetComplexFormType(entry_ref, complex_form_type)",
          "summary": "Set the complex form type of an entry reference.",
          "description": "Set the complex form type of an entry reference.\n",
          "parameters": [
            {
              "name": "entry_ref",
              "type": "",
              "default": null,
              "description": "ILexEntryRef object"
            },
            {
              "name": "complex_form_type",
              "type": "",
              "default": null,
              "description": "ILexEntryType object"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "            >>> # Get or create complex form type\n            >>> # cf_type = ... (from project)\n            >>> # entry_ref = entry.EntryRefsOS[0]\n            >>> # project.LexiconSetComplexFormType(entry_ref, cf_type)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSetExample",
          "signature": "LexiconSetExample(example, newString, languageTagOrHandle=None)",
          "summary": "Set the default vernacular string for `example`:\n- `newString` is the new string value.",
          "description": "Set the default vernacular string for `example`:\n- `newString` is the new string value.\n- `languageTagOrHandle` specifies a non-default writing system.\n\nNOTE: using this function will lose any formatting that might\nhave been present in the example string.\n",
          "parameters": [
            {
              "name": "example",
              "type": "",
              "default": null
            },
            {
              "name": "newString",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSetFieldInteger",
          "signature": "LexiconSetFieldInteger(senseOrEntryOrHvo, fieldID, integer)",
          "summary": "Sets the integer value for the given entry/sense and field ID.",
          "description": "Sets the integer value for the given entry/sense and field ID.\nProvided for use with custom fields.",
          "parameters": [
            {
              "name": "senseOrEntryOrHvo",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            },
            {
              "name": "integer",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSetFieldText",
          "signature": "LexiconSetFieldText(senseOrEntryOrHvo, fieldID, text, languageTagOrHandle=None)",
          "summary": "Set the text value for the given entry/sense and field ID.",
          "description": "Set the text value for the given entry/sense and field ID.\nProvided for use with custom fields.\n\nNOTE: writes the string in one writing system only (defaults\nto the default analysis WS).\n\nFor normal fields the object can be used directly with\n`set_String()`. E.g.::\n\nlexForm = lexEntry.LexemeFormOA\nmkstr = TsStringUtils.MakeString(\"text to write\", WSHandle)\nlexForm.Form.set_String(WSHandle, mkstr)",
          "parameters": [
            {
              "name": "senseOrEntryOrHvo",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSetLexemeForm",
          "signature": "LexiconSetLexemeForm(entry, form, languageTagOrHandle=None)",
          "summary": "Set the lexeme form for `entry`:\n- `form` is the new lexeme form string.",
          "description": "Set the lexeme form for `entry`:\n- `form` is the new lexeme form string.\n- `languageTagOrHandle` specifies a non-default writing system.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null
            },
            {
              "name": "form",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSetListFieldMultiple",
          "signature": "LexiconSetListFieldMultiple(senseOrEntry, fieldID, listOfValues)",
          "summary": "Sets the value(s) for a 'multiple' (Collection) list field.",
          "description": "Sets the value(s) for a 'multiple' (Collection) list field.\n`listOfValues` can be a list of:\n\n- `CmPossibility` objects; or\n- `CmPossibility` hvos; or\n- `str` (either the full name or the abbreviation; case-sensitive).\n\nUse `ListFieldPossibilities()` to find the valid values for the list.\n",
          "parameters": [
            {
              "name": "senseOrEntry",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            },
            {
              "name": "listOfValues",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSetListFieldSingle",
          "signature": "LexiconSetListFieldSingle(senseOrEntry, fieldID, possibilityOrString)",
          "summary": "Sets the value for a 'single' (Atomic) list field.",
          "description": "Sets the value for a 'single' (Atomic) list field.\n`possibilityOrString` can be a `CmPossibility` object, or a string.\nA string value can be the full name or the abbreviation (case-sensitive).\n\nUse `ListFieldPossibilities()` to find the valid values for the list.\n",
          "parameters": [
            {
              "name": "senseOrEntry",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            },
            {
              "name": "possibilityOrString",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSetMorphType",
          "signature": "LexiconSetMorphType(entry, morph_type_or_name)",
          "summary": "Set the morph type of a lexical entry.",
          "description": "Set the morph type of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "ILexEntry object or HVO"
            },
            {
              "name": "morph_type_or_name",
              "type": "",
              "default": null,
              "description": "IMoMorphType object or name string (\"stem\", \"root\", \"prefix\", \"suffix\", etc.)"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"-ing\")\n            >>> project.LexiconSetMorphType(entry, \"suffix\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexiconSetSenseGloss",
          "signature": "LexiconSetSenseGloss(sense, gloss, languageTagOrHandle=None)",
          "summary": "Set the default analysis gloss for `sense`:\n- `gloss` is the new gloss string.",
          "description": "Set the default analysis gloss for `sense`:\n- `gloss` is the new gloss string.\n- `languageTagOrHandle` specifies a non-default writing system.\n",
          "parameters": [
            {
              "name": "sense",
              "type": "",
              "default": null
            },
            {
              "name": "gloss",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ListFieldLookup",
          "signature": "ListFieldLookup(senseOrEntry, fieldID, value)",
          "summary": "Looks up the value (a string) in the `CmPossibilityList` for the\ngiven field.",
          "description": "Looks up the value (a string) in the `CmPossibilityList` for the\ngiven field.\nReturns the `CmPossibility` object, or `None` if it can't be found.",
          "parameters": [
            {
              "name": "senseOrEntry",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            },
            {
              "name": "value",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ListFieldPossibilities",
          "signature": "ListFieldPossibilities(senseOrEntry, fieldID)",
          "summary": "Returns the `PossibilitiesOS` for the given list field.",
          "description": "Returns the `PossibilitiesOS` for the given list field. This\nis a list of `CmPossibility` objects.\nRaises an exception if the field is not a list (single/Atomic\nor multiple/Collection)\n",
          "parameters": [
            {
              "name": "senseOrEntry",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ListFieldPossibilityList",
          "signature": "ListFieldPossibilityList(senseOrEntry, fieldID)",
          "summary": "Return the `CmPossibilityList` object for the given list field.",
          "description": "Return the `CmPossibilityList` object for the given list field.\nRaises an exception if the field is not a list (single/Atomic\nor multiple/Collection)",
          "parameters": [
            {
              "name": "senseOrEntry",
              "type": "",
              "default": null
            },
            {
              "name": "fieldID",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Object",
          "signature": "Object(hvoOrGuid)",
          "summary": "Returns the `CmObject` for the given Hvo or guid (`str` or `System.",
          "description": "Returns the `CmObject` for the given Hvo or guid (`str` or `System.Guid`).\nRefer to `.ClassName` to determine the LCM class.",
          "parameters": [
            {
              "name": "hvoOrGuid",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ObjectCountFor",
          "signature": "ObjectCountFor(repository)",
          "summary": "Returns the number of objects in `repository`.",
          "description": "Returns the number of objects in `repository`.\n`repository` is specified by the interface class, such as:\n\n- `ITextRepository`\n- `ILexEntryRepository`\n\nAll repository names can be viewed by opening a project in\nLCMBrowser, which can be launched via the Help menu. Add \"I\"\nto the front and import from `SIL.LCModel`.",
          "parameters": [
            {
              "name": "repository",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ObjectRepository",
          "signature": "ObjectRepository(repository)",
          "summary": "Returns an object repository.",
          "description": "Returns an object repository.\n`repository` is specified by the interface class, such as:\n\n- `ITextRepository`\n- `ILexEntryRepository`",
          "parameters": [
            {
              "name": "repository",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ObjectsIn",
          "signature": "ObjectsIn(repository)",
          "summary": "Returns an iterator over all the objects in `repository`.",
          "description": "Returns an iterator over all the objects in `repository`.\n`repository` is specified by the interface class, such as:\n\n- `ITextRepository`\n- `ILexEntryRepository`\n\nAll repository names can be viewed by opening a project in\nLCMBrowser, which can be launched via the Help menu. Add \"I\"\nto the front and import from `SIL.LCModel`.",
          "parameters": [
            {
              "name": "repository",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "OpenProject",
          "signature": "OpenProject(projectName, writeEnabled=False)",
          "summary": "Open a project.",
          "description": "Open a project. The project must be closed with `CloseProject()` to\nsave any changes, and release the lock.\n\nprojectName:\n- Either the full path including \".fwdata\" suffix, or\n- The name only, to open from the default project location.\n\nwriteEnabled:\nEnables changes to be written to the project, which will be\nsaved on a call to `CloseProject()`.\nLCM will raise an exception if changes are attempted without\nopening the project in this mode.\n",
          "parameters": [
            {
              "name": "projectName",
              "type": "",
              "default": null
            },
            {
              "name": "writeEnabled",
              "type": "",
              "default": false
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ProjectName",
          "signature": "ProjectName()",
          "summary": "Returns the display name of the current project.",
          "description": "Returns the display name of the current project.",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "PublicationType",
          "signature": "PublicationType(publicationName)",
          "summary": "Returns the `PublicationType` object (a `CmPossibility`) for the\ngiven publication name.",
          "description": "Returns the `PublicationType` object (a `CmPossibility`) for the\ngiven publication name. (A list of publication names can be\nfound using `GetPublications()`.)\n\n.. note::\nThis method delegates to :meth:`PublicationOperations.Find`.",
          "parameters": [
            {
              "name": "publicationName",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ReversalEntries",
          "signature": "ReversalEntries(languageTag)",
          "summary": "Returns an iterator for the reversal entries for `languageTag` (eg 'en').",
          "description": "Returns an iterator for the reversal entries for `languageTag` (eg 'en').\nReturns `None` if there is no reversal index for that writing system.\n\n.. note::\nThis method delegates to :meth:`ReversalOperations.GetIndex` and\n:meth:`ReversalOperations.GetAll`.",
          "parameters": [
            {
              "name": "languageTag",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ReversalGetForm",
          "signature": "ReversalGetForm(entry, languageTagOrHandle=None)",
          "summary": "Returns the citation form for the reversal entry in the default\nvernacular WS or other WS as specified by `languageTagOrHandle`.",
          "description": "Returns the citation form for the reversal entry in the default\nvernacular WS or other WS as specified by `languageTagOrHandle`.\n\n.. note::\nThis method delegates to :meth:`ReversalOperations.GetForm`.",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ReversalIndex",
          "signature": "ReversalIndex(languageTag)",
          "summary": "Returns the reversal index for `languageTag` (eg 'en').",
          "description": "Returns the reversal index for `languageTag` (eg 'en').\nReturns `None` if there is no reversal index for\nthat writing system.\n\n.. note::\nThis method delegates to :meth:`ReversalOperations.GetIndex`.",
          "parameters": [
            {
              "name": "languageTag",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ReversalSetForm",
          "signature": "ReversalSetForm(entry, form, languageTagOrHandle=None)",
          "summary": "Sets the default analysis reversal form for the given reversal entry:\n- `form` is the new reversal form string.",
          "description": "Sets the default analysis reversal form for the given reversal entry:\n- `form` is the new reversal form string.\n- `languageTagOrHandle` specifies a non-default writing system.\n\n.. note::\nThis method delegates to :meth:`ReversalOperations.SetForm`.",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null
            },
            {
              "name": "form",
              "type": "",
              "default": null
            },
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAudioPath",
          "signature": "SetAudioPath(multistring_field, wsHandle, file_path)",
          "summary": "Set the audio file path in an audio writing system field.",
          "description": "Set the audio file path in an audio writing system field.\n\nEmbeds the file path using Object Replacement Character (ORC) with\nFwObjDataTypes.kodtExternalPathName.\n",
          "parameters": [
            {
              "name": "multistring_field",
              "type": "",
              "default": null,
              "description": "ITsMultiString or similar field to update"
            },
            {
              "name": "wsHandle",
              "type": "int",
              "default": null,
              "description": "Audio writing system handle"
            },
            {
              "name": "file_path",
              "type": "str",
              "default": null,
              "description": "Path to audio file (can be relative or absolute)"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "            >>> # Set audio for allomorph form\n            >>> allomorph = proj.Allomorph.GetAll()[0]\n            >>> audio_ws = proj.WSHandle(\"en-Zxxx-x-audio\")\n            >>> audio_path = \"LinkedFiles/AudioVisual/hello.wav\"\n            >>> proj.Allomorph.SetFormAudio(allomorph, audio_path, audio_ws)\n\n        See also:\n            :meth:`IsAudioWritingSystem` - Check if WS is audio type\n            :meth:`GetAudioPath` - Get audio file path",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "TextsGetAll",
          "signature": "TextsGetAll(supplyName=True, supplyText=True)",
          "summary": "A generator that returns all the texts in the project as\ntuples of (`name`, `text`) where:",
          "description": "A generator that returns all the texts in the project as\ntuples of (`name`, `text`) where:\n\n- `name` is the best vernacular or analysis name.\n- `text` is a string with newlines separating paragraphs.\n\nPassing `supplyName`/`Text` = `False` returns only the texts or names.\n",
          "parameters": [
            {
              "name": "supplyName",
              "type": "",
              "default": true
            },
            {
              "name": "supplyText",
              "type": "",
              "default": true
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "TextsNumberOfTexts",
          "signature": "TextsNumberOfTexts()",
          "summary": "Returns the total number of texts in the project.",
          "description": "Returns the total number of texts in the project.\n",
          "parameters": [],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "UnpackNestedPossibilityList",
          "signature": "UnpackNestedPossibilityList(possibilityList, objClass, flat=False)",
          "summary": "Returns a nested or flat list of a Fieldworks possibility list.",
          "description": "Returns a nested or flat list of a Fieldworks possibility list.\n`objClass` is the class of object to cast the `CmPossibility` elements into.\n\nReturn items are objects with properties/methods:\n- `Hvo`         - ID (value not the same across projects)\n- `Guid`        - Global Unique ID (same across all projects)\n- `ToString()`  - String representation.",
          "parameters": [
            {
              "name": "possibilityList",
              "type": "",
              "default": null
            },
            {
              "name": "objClass",
              "type": "",
              "default": null
            },
            {
              "name": "flat",
              "type": "",
              "default": false
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "WSHandle",
          "signature": "WSHandle(languageTag)",
          "summary": "Returns the handle of the writing system for `languageTag`.",
          "description": "Returns the handle of the writing system for `languageTag`.\nIgnores case and '-'/'_' differences.\nReturns `None` if the language tag is not found.",
          "parameters": [
            {
              "name": "languageTag",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "WSUIName",
          "signature": "WSUIName(languageTagOrHandle)",
          "summary": "Returns the UI name of the writing system for the given language tag\nor handle.",
          "description": "Returns the UI name of the writing system for the given language tag\nor handle.\nIgnores case and '-'/'_' differences.\nReturns `None` if the language tag is not found.\n",
          "parameters": [
            {
              "name": "languageTagOrHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [
        {
          "name": "POS",
          "signature": "POS()",
          "summary": "Access to Parts of Speech operations.",
          "description": "Access to Parts of Speech operations.\n",
          "parameters": [],
          "returns": "POSOperations: Instance providing POS management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all parts of speech\n            >>> for pos in project.POS.GetAll():\n            ...     print(f\"{project.POS.GetName(pos)} ({project.POS.GetAbbreviation(pos)})\")\n            >>> # Create a new POS\n            >>> noun = project.POS.Create(\"Noun\", \"N\")\n            >>> # Find and update\n            >>> verb = project.POS.Find(\"Verb\")\n            >>> if verb:\n            ...     project.POS.SetAbbreviation(verb, \"V\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexEntry",
          "signature": "LexEntry()",
          "summary": "Access to Lexical Entry operations.",
          "description": "Access to Lexical Entry operations.\n",
          "parameters": [],
          "returns": "LexEntryOperations: Instance providing lexical entry management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all entries\n            >>> for entry in project.LexEntry.GetAll():\n            ...     print(project.LexEntry.GetHeadword(entry))\n            >>> # Create a new entry\n            >>> entry = project.LexEntry.Create(\"run\", \"stem\")\n            >>> # Add a sense\n            >>> sense = project.LexEntry.AddSense(entry, \"to move rapidly on foot\")\n            >>> # Set citation form\n            >>> project.LexEntry.SetCitationForm(entry, \"run\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Texts",
          "signature": "Texts()",
          "summary": "Access to Text operations.",
          "description": "Access to Text operations.\n",
          "parameters": [],
          "returns": "TextOperations: Instance providing text management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create a new text\n            >>> text = project.Texts.Create(\"Genesis\")\n            >>> # List all texts\n            >>> for t in project.Texts.GetAll():\n            ...     print(project.Texts.GetName(t))\n            >>> # Update text name\n            >>> project.Texts.SetName(text, \"Genesis Chapter 1\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Wordforms",
          "signature": "Wordforms()",
          "summary": "Access to wordform operations (Work Stream 3 - MOST ACTIVE: 727+ commits in 2024).",
          "description": "Access to wordform operations (Work Stream 3 - MOST ACTIVE: 727+ commits in 2024).\n",
          "parameters": [],
          "returns": "WfiWordformOperations: Instance providing wordform inventory management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Find or create wordform (most common pattern)\n            >>> wf = project.Wordforms.FindOrCreate(\"hlauka\")\n            >>> # Get all analyses\n            >>> for analysis in project.Wordforms.GetAnalyses(wf):\n            ...     approved = project.WfiAnalyses.IsHumanApproved(analysis)\n            ...     print(f\"Analysis: {'approved' if approved else 'parser guess'}\")\n            >>> # Set approved analysis\n            >>> if wf.AnalysesOC.Count > 0:\n            ...     project.Wordforms.SetApprovedAnalysis(wf, wf.AnalysesOC[0])",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "WfiAnalyses",
          "signature": "WfiAnalyses()",
          "summary": "Access to wordform analysis operations (Work Stream 3).",
          "description": "Access to wordform analysis operations (Work Stream 3).\n",
          "parameters": [],
          "returns": "WfiAnalysisOperations: Instance providing wordform analysis management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get wordform and create analysis\n            >>> wf = project.Wordforms.FindOrCreate(\"hlauka\")\n            >>> analysis = project.WfiAnalyses.Create(wf)\n            >>> # Set category (part of speech)\n            >>> verb = project.POS.Find(\"verb\")\n            >>> if verb:\n            ...     project.WfiAnalyses.SetCategory(analysis, verb)\n            >>> # Mark as human-approved\n            >>> project.WfiAnalyses.Approve(analysis)\n            >>> # Get morph bundles\n            >>> bundles = project.WfiAnalyses.GetMorphBundles(analysis)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Paragraphs",
          "signature": "Paragraphs()",
          "summary": "Access to paragraph operations.",
          "description": "Access to paragraph operations.\n",
          "parameters": [],
          "returns": "ParagraphOperations: Instance providing paragraph management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> para = list(text.ContentsOA.ParagraphsOS)[0]\n            >>> # Get translations\n            >>> trans = project.Paragraphs.GetTranslations(para)\n            >>> # Set translation\n            >>> project.Paragraphs.SetTranslation(para, \"In the beginning...\", \"en\")\n            >>> # Add note\n            >>> note = project.Paragraphs.AddNote(para, \"Check translation\")\n            >>> # Get style\n            >>> style = project.Paragraphs.GetStyleName(para)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Segments",
          "signature": "Segments()",
          "summary": "Access to segment operations.",
          "description": "Access to segment operations.\n",
          "parameters": [],
          "returns": "SegmentOperations: Instance providing segment management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all segments in a paragraph\n            >>> para = project.Object(para_hvo)\n            >>> for segment in project.Segments.GetAll(para):\n            ...     baseline = project.Segments.GetBaselineText(segment)\n            ...     print(baseline)\n            >>> # Set translations\n            >>> segment = list(project.Segments.GetAll(para))[0]\n            >>> project.Segments.SetFreeTranslation(segment, \"In the beginning...\")\n            >>> project.Segments.SetLiteralTranslation(segment, \"In-the beginning...\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Phonemes",
          "signature": "Phonemes()",
          "summary": "Access to phoneme operations.",
          "description": "Access to phoneme operations.\n",
          "parameters": [],
          "returns": "PhonemeOperations: Instance providing phoneme management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all phonemes\n            >>> for phoneme in project.Phonemes.GetAll():\n            ...     repr = project.Phonemes.GetRepresentation(phoneme)\n            ...     desc = project.Phonemes.GetDescription(phoneme)\n            ...     print(f\"{repr}: {desc}\")\n            >>> # Create a new phoneme\n            >>> phoneme = project.Phonemes.Create(\"/p/\")\n            >>> project.Phonemes.SetDescription(phoneme, \"voiceless bilabial stop\")\n            >>> # Add allophonic codes\n            >>> project.Phonemes.AddCode(phoneme, \"[p]\")\n            >>> project.Phonemes.AddCode(phoneme, \"[p]\")\n            >>> # Check phoneme type\n            >>> if project.Phonemes.IsConsonant(phoneme):\n            ...     print(\"Consonant phoneme\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "NaturalClasses",
          "signature": "NaturalClasses()",
          "summary": "Access to natural class operations.",
          "description": "Access to natural class operations.\n",
          "parameters": [],
          "returns": "NaturalClassOperations: Instance providing natural class management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all natural classes\n            >>> for nc in project.NaturalClasses.GetAll():\n            ...     name = project.NaturalClasses.GetName(nc)\n            ...     print(f\"Natural class: {name}\")\n            >>> # Create a new natural class\n            >>> nc = project.NaturalClasses.Create(\"Voiced Stops\")\n            >>> # Add phonemes to the class\n            >>> phoneme_b = project.Phonemes.Find(\"/b/\")\n            >>> project.NaturalClasses.AddPhoneme(nc, phoneme_b)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Environments",
          "signature": "Environments()",
          "summary": "Access to phonological environment operations.",
          "description": "Access to phonological environment operations.\n",
          "parameters": [],
          "returns": "EnvironmentOperations: Instance providing environment management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all environments\n            >>> for env in project.Environments.GetAll():\n            ...     name = project.Environments.GetName(env)\n            ...     repr = project.Environments.GetStringRepresentation(env)\n            ...     print(f\"{name}: {repr}\")\n            >>> # Create a new environment\n            >>> env = project.Environments.Create(\"Between vowels\", \"V_V\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Allomorphs",
          "signature": "Allomorphs()",
          "summary": "Access to allomorph operations.",
          "description": "Access to allomorph operations.\n",
          "parameters": [],
          "returns": "AllomorphOperations: Instance providing allomorph management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all allomorphs for an entry\n            >>> entry = project.LexiconGetFirstEntry()\n            >>> for allo in project.Allomorphs.GetAll(entry):\n            ...     form = project.Allomorphs.GetForm(allo)\n            ...     print(f\"Allomorph: {form}\")\n            >>> # Create a new allomorph\n            >>> allo = project.Allomorphs.Create(entry, \"-ed\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MorphRules",
          "signature": "MorphRules()",
          "summary": "Access to morphological rule operations.",
          "description": "Access to morphological rule operations.\n",
          "parameters": [],
          "returns": "MorphRuleOperations: Instance providing morph rule management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all morphological rules\n            >>> for rule in project.MorphRules.GetAll():\n            ...     name = project.MorphRules.GetName(rule)\n            ...     active = project.MorphRules.IsActive(rule)\n            ...     print(f\"{name}: {'active' if active else 'inactive'}\")\n            >>> # Create a new rule\n            >>> rule = project.MorphRules.Create(\"Plural formation\", \"Lexical\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "InflectionFeatures",
          "signature": "InflectionFeatures()",
          "summary": "Access to inflection feature operations.",
          "description": "Access to inflection feature operations.\n",
          "parameters": [],
          "returns": "InflectionFeatureOperations: Instance providing inflection feature management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all inflection classes\n            >>> for ic in project.InflectionFeatures.GetAllClasses():\n            ...     name = project.InflectionFeatures.GetClassName(ic)\n            ...     print(f\"Inflection class: {name}\")\n            >>> # Get all features\n            >>> for feat in project.InflectionFeatures.GetAllFeatures():\n            ...     name = project.InflectionFeatures.GetFeatureName(feat)\n            ...     print(f\"Feature: {name}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GramCat",
          "signature": "GramCat()",
          "summary": "Access to grammatical category operations.",
          "description": "Access to grammatical category operations.\n",
          "parameters": [],
          "returns": "GramCatOperations: Instance providing grammatical category management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all grammatical categories\n            >>> for gc in project.GramCat.GetAll():\n            ...     name = project.GramCat.GetName(gc)\n            ...     print(f\"Category: {name}\")\n            >>> # Create a new category\n            >>> gc = project.GramCat.Create(\"Transitive\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "PhonRules",
          "signature": "PhonRules()",
          "summary": "Access to phonological rule operations.",
          "description": "Access to phonological rule operations.\n",
          "parameters": [],
          "returns": "PhonologicalRuleOperations: Instance providing phonological rule management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create a phonological rule\n            >>> rule = project.PhonRules.Create(\"Voicing Assimilation\",\n            ...     \"Voiceless stops become voiced between vowels\")\n            >>> # Add input and output\n            >>> phoneme_t = project.Phonemes.Find(\"/t/\")\n            >>> phoneme_d = project.Phonemes.Find(\"/d/\")\n            >>> project.PhonRules.AddInputSegment(rule, phoneme_t)\n            >>> project.PhonRules.AddOutputSegment(rule, phoneme_d)\n            >>> # Set context\n            >>> vowels = project.NaturalClasses.Find(\"Vowels\")\n            >>> project.PhonRules.SetLeftContext(rule, vowels)\n            >>> project.PhonRules.SetRightContext(rule, vowels)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Senses",
          "signature": "Senses()",
          "summary": "Access to lexical sense operations.",
          "description": "Access to lexical sense operations.\n",
          "parameters": [],
          "returns": "LexSenseOperations: Instance providing sense management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all senses for an entry\n            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> for sense in project.Senses.GetAll(entry):\n            ...     gloss = project.Senses.GetGloss(sense)\n            ...     print(f\"Sense: {gloss}\")\n            >>> # Create a new sense\n            >>> sense = project.Senses.Create(entry, \"to run\", \"en\")\n            >>> # Set definition\n            >>> project.Senses.SetDefinition(sense, \"To move swiftly on foot\")\n            >>> # Add semantic domain\n            >>> domains = project.GetAllSemanticDomains(flat=True)\n            >>> if domains:\n            ...     project.Senses.AddSemanticDomain(sense, domains[0])",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Examples",
          "signature": "Examples()",
          "summary": "Access to example sentence operations.",
          "description": "Access to example sentence operations.\n",
          "parameters": [],
          "returns": "ExampleOperations: Instance providing example sentence management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get first entry and sense\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> # Get all examples\n            >>> for example in project.Examples.GetAll(sense):\n            ...     text = project.Examples.GetExample(example)\n            ...     trans = project.Examples.GetTranslation(example)\n            ...     print(f\"{text} - {trans}\")\n            >>> # Create a new example\n            >>> example = project.Examples.Create(sense, \"The cat slept.\")\n            >>> project.Examples.SetTranslation(example, \"Le chat a dormi.\")\n            >>> project.Examples.SetReference(example, \"Corpus A:123\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LexReferences",
          "signature": "LexReferences()",
          "summary": "Access to lexical reference and relation operations.",
          "description": "Access to lexical reference and relation operations.\n",
          "parameters": [],
          "returns": "LexReferenceOperations: Instance providing lexical reference management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all reference types\n            >>> for ref_type in project.LexReferences.GetAllTypes():\n            ...     name = project.LexReferences.GetTypeName(ref_type)\n            ...     mapping = project.LexReferences.GetMappingType(ref_type)\n            ...     print(f\"{name}: {mapping}\")\n            >>> # Create a synonym relation\n            >>> syn_type = project.LexReferences.FindType(\"Synonym\")\n            >>> if not syn_type:\n            ...     syn_type = project.LexReferences.CreateType(\"Synonym\", \"Symmetric\")\n            >>> # Link two senses\n            >>> entry1 = project.LexEntry.Find(\"run\")\n            >>> entry2 = project.LexEntry.Find(\"jog\")\n            >>> if entry1 and entry2:\n            ...     sense1 = list(project.Senses.GetAll(entry1))[0]\n            ...     sense2 = list(project.Senses.GetAll(entry2))[0]\n            ...     ref = project.LexReferences.Create(syn_type, [sense1, sense2])\n            >>> # Get all references for a sense\n            >>> for ref in project.LexReferences.GetAll(sense1):\n            ...     targets = project.LexReferences.GetTargets(ref)\n            ...     print(f\"Related to {len(targets)} items\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Reversal",
          "signature": "Reversal()",
          "summary": "Access to reversal entry operations.",
          "description": "Access to reversal entry operations.\n",
          "parameters": [],
          "returns": "ReversalOperations: Instance providing reversal entry management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all reversal indexes\n            >>> for index in project.Reversal.GetAllIndexes():\n            ...     ws = index.WritingSystem\n            ...     print(f\"Reversal index: {ws}\")\n            >>> # Get English reversal index\n            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> if en_index:\n            ...     # Get all entries\n            ...     for entry in project.Reversal.GetAll(en_index):\n            ...         form = project.Reversal.GetForm(entry)\n            ...         print(f\"Reversal: {form}\")\n            ...     # Create a new reversal entry\n            ...     entry = project.Reversal.Create(en_index, \"run\", \"en\")\n            ...     # Link to a sense\n            ...     lexentry = project.LexEntry.Find(\"run\")\n            ...     if lexentry:\n            ...         senses = project.LexEntry.GetSenses(lexentry)\n            ...         if senses:\n            ...             project.Reversal.AddSense(entry, senses[0])",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ReversalIndexes",
          "signature": "ReversalIndexes()",
          "summary": "Access to reversal index operations (Work Stream 3).",
          "description": "Access to reversal index operations (Work Stream 3).\n",
          "parameters": [],
          "returns": "ReversalIndexOperations: Instance providing reversal index management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create English reversal index\n            >>> en_ws = project.WSHandle('en')\n            >>> idx = project.ReversalIndexes.Create(\"English\", en_ws)\n            >>> # Find by writing system\n            >>> idx = project.ReversalIndexes.FindByWritingSystem(en_ws)\n            >>> # Get all entries in index\n            >>> for entry in project.ReversalIndexes.GetEntries(idx):\n            ...     form = project.ReversalEntries.GetForm(entry)\n            ...     print(f\"Reversal: {form}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ReversalEntries",
          "signature": "ReversalEntries()",
          "summary": "Access to reversal index entry operations (Work Stream 3).",
          "description": "Access to reversal index entry operations (Work Stream 3).\n",
          "parameters": [],
          "returns": "ReversalIndexEntryOperations: Instance providing reversal entry management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get reversal index\n            >>> idx = project.ReversalIndexes.FindByWritingSystem('en')\n            >>> # Create reversal entry\n            >>> entry = project.ReversalEntries.Create(idx, \"run\")\n            >>> # Link to lexical sense\n            >>> lex_entry = project.LexEntry.Find(\"hlauka\")\n            >>> if lex_entry and lex_entry.SensesOS.Count > 0:\n            ...     sense = lex_entry.SensesOS[0]\n            ...     project.ReversalEntries.AddSense(entry, sense)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SemanticDomains",
          "signature": "SemanticDomains()",
          "summary": "Access to semantic domain operations.",
          "description": "Access to semantic domain operations.\n",
          "parameters": [],
          "returns": "SemanticDomainOperations: Instance providing semantic domain management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all semantic domains\n            >>> for domain in project.SemanticDomains.GetAll(flat=True):\n            ...     number = project.SemanticDomains.GetNumber(domain)\n            ...     name = project.SemanticDomains.GetName(domain)\n            ...     print(f\"{number} - {name}\")\n            >>> # Find a specific domain\n            >>> walk_domain = project.SemanticDomains.Find(\"7.2.1\")\n            >>> if walk_domain:\n            ...     desc = project.SemanticDomains.GetDescription(walk_domain)\n            ...     senses = project.SemanticDomains.GetSensesInDomain(walk_domain)\n            ...     print(f\"Domain has {len(senses)} senses\")\n            >>> # Create a custom domain\n            >>> custom = project.SemanticDomains.Create(\"Technology\", \"900\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Pronunciations",
          "signature": "Pronunciations()",
          "summary": "Access to pronunciation operations.",
          "description": "Access to pronunciation operations.\n",
          "parameters": [],
          "returns": "PronunciationOperations: Instance providing pronunciation management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all pronunciations for an entry\n            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> for pron in project.Pronunciations.GetAll(entry):\n            ...     ipa = project.Pronunciations.GetForm(pron, \"en-fonipa\")\n            ...     print(f\"IPA: {ipa}\")\n            >>> # Create a new pronunciation\n            >>> pron = project.Pronunciations.Create(entry, \"rn\", \"en-fonipa\")\n            >>> # Add audio file\n            >>> project.Pronunciations.AddMediaFile(pron, \"/path/to/audio.wav\")\n            >>> # Get media files\n            >>> media = project.Pronunciations.GetMediaFiles(pron)\n            >>> print(f\"Audio files: {len(media)}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Variants",
          "signature": "Variants()",
          "summary": "Access to variant form operations.",
          "description": "Access to variant form operations.\n",
          "parameters": [],
          "returns": "VariantOperations: Instance providing variant management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all variant types\n            >>> for vtype in project.Variants.GetAllTypes():\n            ...     name = project.Variants.GetTypeName(vtype)\n            ...     print(f\"Variant type: {name}\")\n            >>> # Find a specific variant type\n            >>> spelling_type = project.Variants.FindType(\"Spelling Variant\")\n            >>> # Create a variant\n            >>> entry = project.LexEntry.Find(\"color\")\n            >>> variant = project.Variants.Create(entry, \"colour\", spelling_type)\n            >>> # Get all variants for an entry\n            >>> for var in project.Variants.GetAll(entry):\n            ...     form = project.Variants.GetForm(var)\n            ...     vtype = project.Variants.GetType(var)\n            ...     print(f\"Variant: {form}\")\n            >>> # For irregularly inflected forms\n            >>> go_entry = project.LexEntry.Find(\"go\")\n            >>> went_entry = project.LexEntry.Find(\"went\")\n            >>> irregular_type = project.Variants.FindType(\"Irregularly Inflected Form\")\n            >>> variant_ref = project.Variants.Create(went_entry, \"went\", irregular_type)\n            >>> project.Variants.AddComponentLexeme(variant_ref, go_entry)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Etymology",
          "signature": "Etymology()",
          "summary": "Access to etymology operations.",
          "description": "Access to etymology operations.\n",
          "parameters": [],
          "returns": "EtymologyOperations: Instance providing etymology tracking methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get an entry\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> # Create etymology for compound word components\n            >>> etym1 = project.Etymology.Create(entry, \"Ancient Greek\", \" (tele)\", \"far, distant\")\n            >>> project.Etymology.SetComment(etym1, \"Combining form from Greek \")\n            >>> etym2 = project.Etymology.Create(entry, \"Ancient Greek\", \" (phn)\", \"sound, voice\")\n            >>> # Query etymologies\n            >>> for etym in project.Etymology.GetAll(entry):\n            ...     source = project.Etymology.GetSource(etym)\n            ...     form = project.Etymology.GetForm(etym)\n            ...     gloss = project.Etymology.GetGloss(etym)\n            ...     print(f\"{source}: {form} ({gloss})\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "PossibilityLists",
          "signature": "PossibilityLists()",
          "summary": "Access to generic possibility list operations.",
          "description": "Access to generic possibility list operations.\n",
          "parameters": [],
          "returns": "PossibilityListOperations: Instance providing possibility list management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all possibility lists in the project\n            >>> for poss_list in project.PossibilityLists.GetAllLists():\n            ...     name = project.PossibilityLists.GetListName(poss_list)\n            ...     items = project.PossibilityLists.GetItems(poss_list, flat=True)\n            ...     print(f\"{name}: {len(items)} items\")\n            Semantic Domains: 1435 items\n            Parts of Speech: 45 items\n            Text Genres: 12 items\n            ...\n            >>> # Work with a specific list\n            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> if genre_list:\n            ...     # Get all items\n            ...     for item in project.PossibilityLists.GetItems(genre_list):\n            ...         name = project.PossibilityLists.GetItemName(item)\n            ...         depth = project.PossibilityLists.GetDepth(item)\n            ...         print(f\"{'  ' * depth}{name}\")\n            ...     # Create a new genre\n            ...     narrative = project.PossibilityLists.CreateItem(\n            ...         genre_list, \"Narrative\", \"en\")\n            ...     # Create a sub-genre\n            ...     folktale = project.PossibilityLists.CreateItem(\n            ...         genre_list, \"Folktale\", \"en\", parent=narrative)\n            ...     # Move items in hierarchy\n            ...     project.PossibilityLists.MoveItem(folktale, None)  # Move to top",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CustomFields",
          "signature": "CustomFields()",
          "summary": "Access to custom field operations.",
          "description": "Access to custom field operations.\n",
          "parameters": [],
          "returns": "CustomFieldOperations: Instance providing custom field management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all custom fields for entries\n            >>> entry_fields = project.CustomFields.GetAllFields(\"LexEntry\")\n            >>> for field_id, label in entry_fields:\n            ...     print(f\"Field: {label} (ID: {field_id})\")\n            >>> # Find a specific field\n            >>> field_id = project.CustomFields.FindField(\"LexEntry\", \"Etymology Source\")\n            >>> # Get and set field values\n            >>> entry = project.LexEntry.Find(\"run\")\n            >>> if field_id:\n            ...     value = project.CustomFields.GetValue(entry, \"Etymology Source\")\n            ...     print(f\"Current value: {value}\")\n            ...     project.CustomFields.SetValue(entry, \"Etymology Source\", \"Latin currere\")\n            >>> # Work with list fields\n            >>> sense = entry.SensesOS[0]\n            >>> regions = project.CustomFields.GetListValues(sense, \"Regions\")\n            >>> project.CustomFields.AddListValue(sense, \"Regions\", \"North\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "WritingSystems",
          "signature": "WritingSystems()",
          "summary": "Access to writing system operations.",
          "description": "Access to writing system operations.\n",
          "parameters": [],
          "returns": "WritingSystemOperations: Instance providing writing system management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all writing systems\n            >>> for ws in project.WritingSystems.GetAll():\n            ...     name = project.WritingSystems.GetDisplayName(ws)\n            ...     tag = project.WritingSystems.GetLanguageTag(ws)\n            ...     print(f\"{name} ({tag})\")\n            >>> # Configure a writing system\n            >>> ws = list(project.WritingSystems.GetVernacular())[0]\n            >>> project.WritingSystems.SetFontName(ws, \"Charis SIL\")\n            >>> project.WritingSystems.SetFontSize(ws, 14)\n            >>> # Set RTL for Arabic\n            >>> if project.WritingSystems.Exists(\"ar\"):\n            ...     project.WritingSystems.SetRightToLeft(\"ar\", True)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "WfiGlosses",
          "signature": "WfiGlosses()",
          "summary": "Access to wordform gloss operations (Work Stream 3).",
          "description": "Access to wordform gloss operations (Work Stream 3).\n",
          "parameters": [],
          "returns": "WfiGlossOperations: Instance providing wordform gloss management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get analysis and create gloss\n            >>> analysis = project.WfiAnalyses.Create(wordform)\n            >>> gloss = project.WfiGlosses.Create(analysis, \"run\", project.WSHandle('en'))\n            >>> # Mark as human-approved\n            >>> project.WfiGlosses.Approve(gloss)\n            >>> # Get all glosses\n            >>> for g in project.WfiGlosses.GetAll(analysis):\n            ...         form = project.WfiGlosses.GetForm(g, \"en\")\n            ...         print(f\"Gloss: {form}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "WfiMorphBundles",
          "signature": "WfiMorphBundles()",
          "summary": "Access to wordform morpheme bundle operations (Work Stream 3).",
          "description": "Access to wordform morpheme bundle operations (Work Stream 3).\n",
          "parameters": [],
          "returns": "WfiMorphBundleOperations: Instance providing morpheme bundle management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create morpheme bundles for morphological breakdown\n            >>> analysis = project.WfiAnalyses.Create(wordform)\n            >>> stem = project.WfiMorphBundles.Create(analysis, \"hlauk-\")\n            >>> suffix = project.WfiMorphBundles.Create(analysis, \"-a\")\n            >>> # Link to lexical entries\n            >>> stem_entry = project.LexEntry.Find(\"hlauk\")\n            >>> if stem_entry and stem_entry.SensesOS.Count > 0:\n            ...     project.WfiMorphBundles.SetSense(stem, stem_entry.SensesOS[0])\n            >>> # Set morpheme type\n            >>> project.WfiMorphBundles.SetMorphemeType(stem, \"stem\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Media",
          "signature": "Media()",
          "summary": "Access to media file operations.",
          "description": "Access to media file operations.\n",
          "parameters": [],
          "returns": "MediaOperations: Instance providing media file management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all media files\n            >>> for media in project.Media.GetAll():\n            ...     filename = project.Media.GetFilename(media)\n            ...     mtype = project.Media.GetMediaType(media)\n            ...     print(f\"{filename} ({mtype})\")\n            >>> # Add a media file\n            >>> media = project.Media.Create(\"/path/to/audio.wav\", \"My Recording\")\n            >>> # Copy file to project\n            >>> project.Media.CopyToProject(media)\n            >>> # Find orphaned media\n            >>> orphans = project.Media.GetOrphanedMedia()\n            >>> print(f\"Found {len(orphans)} orphaned files\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Notes",
          "signature": "Notes()",
          "summary": "Access to note and annotation operations.",
          "description": "Access to note and annotation operations.\n",
          "parameters": [],
          "returns": "NoteOperations: Instance providing note management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create a note on an entry\n            >>> entry = project.LexEntry.Find(\"run\")\n            >>> note = project.Notes.Create(entry, \"Check etymology\", \"en\")\n            >>> # Add a reply\n            >>> reply = project.Notes.AddReply(note, \"Verified - from Latin currere\", \"en\")\n            >>> # Get all notes for an object\n            >>> for n in project.Notes.GetAll(entry):\n            ...     content = project.Notes.GetContent(n, \"en\")\n            ...     replies = project.Notes.GetReplies(n)\n            ...     print(f\"Note: {content} ({len(replies)} replies)\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Filters",
          "signature": "Filters()",
          "summary": "Access to filter and query operations.",
          "description": "Access to filter and query operations.\n",
          "parameters": [],
          "returns": "FilterOperations: Instance providing filter management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create a filter for incomplete entries\n            >>> filter_def = {\n            ...     \"name\": \"Incomplete Entries\",\n            ...     \"type\": \"LexEntry\",\n            ...     \"conditions\": [\n            ...         {\"field\": \"SensesOS\", \"operator\": \"isEmpty\"}\n            ...     ]\n            ... }\n            >>> filter_obj = project.Filters.Create(filter_def)\n            >>> # Apply the filter\n            >>> results = project.Filters.ApplyFilter(filter_obj)\n            >>> print(f\"Found {len(results)} incomplete entries\")\n            >>> # Export filter\n            >>> json_str = project.Filters.ExportFilter(filter_obj)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Discourse",
          "signature": "Discourse()",
          "summary": "Access to discourse chart operations.",
          "description": "Access to discourse chart operations.\n",
          "parameters": [],
          "returns": "DiscourseOperations: Instance providing discourse chart management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get a text\n            >>> text = list(project.TextCatalog())[0]\n            >>> # Create a discourse chart\n            >>> chart = project.Discourse.CreateChart(text, \"Constituent Chart\", \"en\")\n            >>> # Add rows\n            >>> row1 = project.Discourse.AddRow(chart, 0)\n            >>> # Get all charts\n            >>> for c in project.Discourse.GetAllCharts():\n            ...     name = project.Discourse.GetChartName(c, \"en\")\n            ...     rows = project.Discourse.GetRows(c)\n            ...     print(f\"Chart: {name} ({len(rows)} rows)\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Person",
          "signature": "Person()",
          "summary": "Access to person operations for managing consultants, speakers, and researchers.",
          "description": "Access to person operations for managing consultants, speakers, and researchers.\n",
          "parameters": [],
          "returns": "PersonOperations: Instance providing person management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create a person\n            >>> consultant = project.Person.Create(\"Maria Garcia\", \"en\")\n            >>> # Set properties\n            >>> project.Person.SetGender(consultant, \"Female\", \"en\")\n            >>> project.Person.SetEmail(consultant, \"maria@example.com\", \"en\")\n            >>> project.Person.SetEducation(consultant, \"PhD Linguistics\", \"en\")\n            >>> # Add residence\n            >>> location = project.Location.Find(\"Lima\")\n            >>> if location:\n            ...     project.Person.AddResidence(consultant, location)\n            >>> # Get all people\n            >>> for person in project.Person.GetAll():\n            ...     name = project.Person.GetName(person)\n            ...     email = project.Person.GetEmail(person)\n            ...     print(f\"{name}: {email}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Location",
          "signature": "Location()",
          "summary": "Access to location operations for managing geographic places.",
          "description": "Access to location operations for managing geographic places.\n",
          "parameters": [],
          "returns": "LocationOperations: Instance providing location management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create a location\n            >>> region = project.Location.Create(\"Cusco Region\", \"en\", alias=\"CUS\")\n            >>> project.Location.SetCoordinates(region, -13.5319, -71.9675)\n            >>> project.Location.SetElevation(region, 3400)\n            >>> # Create sublocation\n            >>> city = project.Location.CreateSublocation(region, \"Cusco\", \"en\")\n            >>> project.Location.SetDescription(city, \"Historic capital of Inca Empire\", \"en\")\n            >>> # Find nearby locations\n            >>> nearby = project.Location.GetNearby(city, radius_km=100)\n            >>> for loc in nearby:\n            ...     name = project.Location.GetName(loc)\n            ...     coords = project.Location.GetCoordinates(loc)\n            ...     print(f\"{name}: {coords}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Anthropology",
          "signature": "Anthropology()",
          "summary": "Access to anthropology operations for managing cultural/ethnographic data.",
          "description": "Access to anthropology operations for managing cultural/ethnographic data.\n",
          "parameters": [],
          "returns": "AnthropologyOperations: Instance providing anthropology management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create anthropology items\n            >>> marriage = project.Anthropology.Create(\n            ...     \"Marriage Customs\", \"MAR\", \"586\")\n            >>> project.Anthropology.SetDescription(marriage,\n            ...     \"Traditional marriage practices and ceremonies\", \"en\")\n            >>> # Create subitem\n            >>> wedding = project.Anthropology.CreateSubitem(\n            ...     marriage, \"Wedding Ceremony\", \"WED\", \"586.1\")\n            >>> # Link to text\n            >>> text = project.Texts.Find(\"Wedding Story\")\n            >>> if text:\n            ...     project.Anthropology.AddText(marriage, text)\n            >>> # Query items\n            >>> items = project.Anthropology.GetItemsForText(text)\n            >>> for item in items:\n            ...     name = project.Anthropology.GetName(item)\n            ...     code = project.Anthropology.GetAnthroCode(item)\n            ...     print(f\"{code}: {name}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ProjectSettings",
          "signature": "ProjectSettings()",
          "summary": "Access to project settings operations.",
          "description": "Access to project settings operations.\n",
          "parameters": [],
          "returns": "ProjectSettingsOperations: Instance providing project configuration methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get project info\n            >>> name = project.ProjectSettings.GetProjectName()\n            >>> desc = project.ProjectSettings.GetDescription(\"en\")\n            >>> # Configure writing systems\n            >>> vern_wss = project.ProjectSettings.GetVernacularWSs()\n            >>> project.ProjectSettings.SetDefaultVernacular(\"qaa-x-spec\")\n            >>> # Set default font\n            >>> project.ProjectSettings.SetDefaultFont(\"en\", \"Charis SIL\")\n            >>> project.ProjectSettings.SetDefaultFontSize(\"en\", 14)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Publications",
          "signature": "Publications()",
          "summary": "Access to publication operations.",
          "description": "Access to publication operations.\n",
          "parameters": [],
          "returns": "PublicationOperations: Instance providing publication management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create publication\n            >>> pub = project.Publications.Create(\"Dictionary\", \"en\")\n            >>> project.Publications.SetPageWidth(pub, 8.5)\n            >>> project.Publications.SetPageHeight(pub, 11)\n            >>> # Get all publications\n            >>> for p in project.Publications.GetAll():\n            ...     name = project.Publications.GetName(p)\n            ...     is_default = project.Publications.GetIsDefault(p)\n            ...     print(f\"{name} (default: {is_default})\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Agents",
          "signature": "Agents()",
          "summary": "Access to agent operations.",
          "description": "Access to agent operations.\n",
          "parameters": [],
          "returns": "AgentOperations: Instance providing agent management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create human agent\n            >>> person = project.Person.Create(\"John Smith\", \"en\")\n            >>> agent = project.Agents.CreateHumanAgent(\"John Smith\", person)\n            >>> # Create parser agent\n            >>> parser = project.Agents.CreateParserAgent(\"MyParser\", \"1.0.0\")\n            >>> # Query agents\n            >>> for a in project.Agents.GetAll():\n            ...     name = project.Agents.GetName(a)\n            ...     if project.Agents.IsHuman(a):\n            ...         print(f\"Human: {name}\")\n            ...     else:\n            ...         version = project.Agents.GetVersion(a)\n            ...         print(f\"Parser: {name} v{version}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Confidence",
          "signature": "Confidence()",
          "summary": "Access to confidence level operations.",
          "description": "Access to confidence level operations.\n",
          "parameters": [],
          "returns": "ConfidenceOperations: Instance providing confidence management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all confidence levels\n            >>> for level in project.Confidence.GetAll():\n            ...     name = project.Confidence.GetName(level)\n            ...     print(f\"Confidence: {name}\")\n            >>> # Create custom confidence level\n            >>> verified = project.Confidence.Create(\"Speaker Verified\", \"en\")\n            >>> project.Confidence.SetDescription(verified,\n            ...     \"Confirmed by native speaker\", \"en\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Overlays",
          "signature": "Overlays()",
          "summary": "Access to discourse overlay operations.",
          "description": "Access to discourse overlay operations.\n",
          "parameters": [],
          "returns": "OverlayOperations: Instance providing overlay management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get a chart\n            >>> text = list(project.TextCatalog())[0]\n            >>> chart = project.Discourse.CreateChart(text, \"Chart\", \"en\")\n            >>> # Create overlay\n            >>> overlay = project.Overlays.Create(chart, \"Temporal\", \"en\")\n            >>> project.Overlays.SetVisible(overlay, True)\n            >>> # Get visible overlays\n            >>> for o in project.Overlays.GetVisibleOverlays(chart):\n            ...     name = project.Overlays.GetName(o)\n            ...     print(f\"Overlay: {name}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "TranslationTypes",
          "signature": "TranslationTypes()",
          "summary": "Access to translation type operations.",
          "description": "Access to translation type operations.\n",
          "parameters": [],
          "returns": "TranslationTypeOperations: Instance providing translation type methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get predefined types\n            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> literal = project.TranslationTypes.GetLiteralTranslationType()\n            >>> # Create custom type\n            >>> gloss = project.TranslationTypes.Create(\"Interlinear Gloss\", \"IG\", \"en\")\n            >>> # Get all types\n            >>> for t in project.TranslationTypes.GetAll():\n            ...     name = project.TranslationTypes.GetName(t)\n            ...     abbr = project.TranslationTypes.GetAbbreviation(t)\n            ...     print(f\"{name} ({abbr})\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AnnotationDefs",
          "signature": "AnnotationDefs()",
          "summary": "Access to annotation definition operations.",
          "description": "Access to annotation definition operations.\n",
          "parameters": [],
          "returns": "AnnotationDefOperations: Instance providing annotation definition methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get all annotation definitions\n            >>> for defn in project.AnnotationDefs.GetAll():\n            ...     name = project.AnnotationDefs.GetName(defn)\n            ...     can_create = project.AnnotationDefs.GetUserCanCreate(defn)\n            ...     print(f\"{name} (user-creatable: {can_create})\")\n            >>> # Create custom annotation type\n            >>> note_type = project.AnnotationDefs.Create(\"Field Note\", \"en\")\n            >>> project.AnnotationDefs.SetUserCanCreate(note_type, True)",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Checks",
          "signature": "Checks()",
          "summary": "Access to consistency check operations.",
          "description": "Access to consistency check operations.\n",
          "parameters": [],
          "returns": "CheckOperations: Instance providing check management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create check type\n            >>> check = project.Checks.CreateCheckType(\"Missing Gloss\", \"en\")\n            >>> project.Checks.SetDescription(check,\n            ...     \"Find senses without glosses\", \"en\")\n            >>> # Run check\n            >>> results = project.Checks.RunCheck(check)\n            >>> print(f\"Errors: {results['errors']}\")\n            >>> print(f\"Warnings: {results['warnings']}\")\n            >>> # Get enabled checks\n            >>> for c in project.Checks.GetEnabledChecks():\n            ...     name = project.Checks.GetName(c)\n            ...     status = project.Checks.GetCheckStatus(c)\n            ...     print(f\"{name}: {status}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "DataNotebook",
          "signature": "DataNotebook()",
          "summary": "Access to data notebook operations for research notes and observations.",
          "description": "Access to data notebook operations for research notes and observations.\n",
          "parameters": [],
          "returns": "DataNotebookOperations: Instance providing notebook record management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create notebook record\n            >>> record = project.DataNotebook.Create(\n            ...     \"Field Interview\", \"Notes from interview with speaker\")\n            >>> project.DataNotebook.SetDateOfEvent(record, \"2024-01-15\")\n            >>> # Link researcher\n            >>> researcher = project.Person.Find(\"John Smith\")\n            >>> project.DataNotebook.AddResearcher(record, researcher)\n            >>> # Create sub-record\n            >>> sub = project.DataNotebook.CreateSubRecord(\n            ...     record, \"Kinship Terms\", \"Analysis of family terms\")\n            >>> # Set status\n            >>> project.DataNotebook.SetStatus(record, \"Reviewed\")\n            >>> # Query records\n            >>> for rec in project.DataNotebook.FindByResearcher(researcher):\n            ...     title = project.DataNotebook.GetTitle(rec)\n            ...     date = project.DataNotebook.GetDateOfEvent(rec)\n            ...     print(f\"{title} ({date})\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ConstCharts",
          "signature": "ConstCharts()",
          "summary": "Access to constituent chart operations for discourse analysis.",
          "description": "Access to constituent chart operations for discourse analysis.\n",
          "parameters": [],
          "returns": "ConstChartOperations: Instance providing constituent chart management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Create a constituent chart\n            >>> chart = project.ConstCharts.Create(\"Genesis 1 Analysis\")\n            >>> # Set properties\n            >>> project.ConstCharts.SetName(chart, \"Genesis 1 - Updated\")\n            >>> # Get all charts\n            >>> for chart in project.ConstCharts.GetAll():\n            ...     name = project.ConstCharts.GetName(chart)\n            ...     rows = project.ConstCharts.GetRows(chart)\n            ...     print(f\"Chart: {name} ({len(rows)} rows)\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ConstChartRows",
          "signature": "ConstChartRows()",
          "summary": "Access to constituent chart row operations for discourse analysis.",
          "description": "Access to constituent chart row operations for discourse analysis.\n",
          "parameters": [],
          "returns": "ConstChartRowOperations: Instance providing chart row management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get a chart\n            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> # Create a row\n            >>> row = project.ConstChartRows.Create(chart, label=\"Verse 1\")\n            >>> # Set properties\n            >>> project.ConstChartRows.SetLabel(row, \"Verse 1a\")\n            >>> project.ConstChartRows.SetNotes(row, \"Complex structure\")\n            >>> # Get all rows\n            >>> for row in project.ConstChartRows.GetAll(chart):\n            ...     label = project.ConstChartRows.GetLabel(row)\n            ...     print(f\"Row: {label}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ConstChartWordGroups",
          "signature": "ConstChartWordGroups()",
          "summary": "Access to word group operations for constituent chart rows.",
          "description": "Access to word group operations for constituent chart rows.\n",
          "parameters": [],
          "returns": "ConstChartWordGroupOperations: Instance providing word group management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get text segments\n            >>> text = project.Texts.Find(\"Genesis 1\")\n            >>> para = text.ContentsOA.ParagraphsOS[0]\n            >>> segments = list(para.SegmentsOS)\n            >>> # Create word group\n            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> wg = project.ConstChartWordGroups.Create(row, segments[0], segments[2])\n            >>> # Get all word groups\n            >>> for wg in project.ConstChartWordGroups.GetAll(row):\n            ...     begin = project.ConstChartWordGroups.GetBeginSegment(wg)\n            ...     print(f\"Word group starts at segment {begin.Hvo}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ConstChartMovedText",
          "signature": "ConstChartMovedText()",
          "summary": "Access to moved text marker operations for constituent charts.",
          "description": "Access to moved text marker operations for constituent charts.\n",
          "parameters": [],
          "returns": "ConstChartMovedTextOperations: Instance providing moved text marker methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get a word group\n            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> # Mark as preposed text\n            >>> marker = project.ConstChartMovedText.Create(wg, preposed=True)\n            >>> # Check if preposed\n            >>> if project.ConstChartMovedText.IsPreposed(marker):\n            ...     print(\"Text is preposed\")\n            >>> # Get all moved text markers in chart\n            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> for marker in project.ConstChartMovedText.GetAll(chart):\n            ...     wg = project.ConstChartMovedText.GetWordGroup(marker)\n            ...     print(f\"Moved text in word group {wg.Hvo}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ConstChartTags",
          "signature": "ConstChartTags()",
          "summary": "Access to chart tag operations for constituent charts.",
          "description": "Access to chart tag operations for constituent charts.\n",
          "parameters": [],
          "returns": "ConstChartTagOperations: Instance providing chart tag management methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get a chart\n            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> # Create a tag\n            >>> tag = project.ConstChartTags.Create(chart, \"Topic\")\n            >>> project.ConstChartTags.SetDescription(tag, \"Marks sentence topic\")\n            >>> # Get all tags\n            >>> for tag in project.ConstChartTags.GetAll(chart):\n            ...     name = project.ConstChartTags.GetName(tag)\n            ...     desc = project.ConstChartTags.GetDescription(tag)\n            ...     print(f\"Tag: {name} - {desc}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ConstChartClauseMarkers",
          "signature": "ConstChartClauseMarkers()",
          "summary": "Access to clause marker operations for constituent chart rows.",
          "description": "Access to clause marker operations for constituent chart rows.\n",
          "parameters": [],
          "returns": "ConstChartClauseMarkerOperations: Instance providing clause marker methods ",
          "raises": [],
          "example": "            >>> project = FLExProject()\n            >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n            >>> # Get a row and word group\n            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> # Create clause marker\n            >>> marker = project.ConstChartClauseMarkers.Create(row, wg)\n            >>> # Add dependent clause\n            >>> dep_wg = project.ConstChartWordGroups.Find(row, 1)\n            >>> dep_marker = project.ConstChartClauseMarkers.Create(row, dep_wg)\n            >>> project.ConstChartClauseMarkers.AddDependentClause(marker, dep_marker)\n            >>> # Get all markers\n            >>> for marker in project.ConstChartClauseMarkers.GetAll(row):\n            ...     wg = project.ConstChartClauseMarkers.GetWordGroup(marker)\n            ...     print(f\"Clause marker for word group {wg.Hvo}\")",
          "is_property": true,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ],
      "tags": [
        "general"
      ]
    },
    "ConstChartClauseMarkerOperations": {
      "name": "ConstChartClauseMarkerOperations",
      "type": "class",
      "namespace": "FlexLibs2.Discourse.ConstChartClauseMarkerOperations",
      "source_file": "Discourse/ConstChartClauseMarkerOperations",
      "category": "discourse",
      "summary": "This class provides operations for managing clause markers in constituent\ncharts for discourse analysis in FieldWorks projects.",
      "description": "This class provides operations for managing clause markers in constituent\ncharts for discourse analysis in FieldWorks projects.\n\nClause markers identify clausal relationships and dependencies within the\ndiscourse structure. They link word groups and mark clause boundaries.\n\nThis class should be accessed via FLExProject.ConstChartClauseMarkers property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a row and word group\nchart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\nrow = project.ConstChartRows.Find(chart, 0)\nwg = project.ConstChartWordGroups.Find(row, 0)\n\n# Create a clause marker\nmarker = project.ConstChartClauseMarkers.Create(row, wg)\n\n# Get all markers in a row\nfor marker in project.ConstChartClauseMarkers.GetAll(row):\n# Process clause marker\npass\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddDependentClause",
          "signature": "AddDependentClause(marker_or_hvo, clause_marker)",
          "summary": "Add a dependent clause to a clause marker.",
          "description": "Add a dependent clause to a clause marker.\n\nCreates a hierarchical relationship showing that one clause is dependent\non another in the discourse structure.\n",
          "parameters": [
            {
              "name": "marker_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartClauseMarker object or its HVO"
            },
            {
              "name": "clause_marker",
              "type": "",
              "default": null,
              "description": "IConstChartClauseMarker object to add as dependent"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If marker_or_hvo or clause_marker is None",
            "FP_ParameterError: If clause_marker is invalid type"
          ],
          "example": "            >>> # Create main clause marker\n            >>> main_marker = project.ConstChartClauseMarkers.Create(row, main_wg)\n            >>>\n            >>> # Create dependent clause marker\n            >>> dep_marker = project.ConstChartClauseMarkers.Create(row, dep_wg)\n            >>>\n            >>> # Add as dependent\n            >>> project.ConstChartClauseMarkers.AddDependentClause(\n            ...     main_marker, dep_marker)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(row_or_hvo, word_group)",
          "summary": "Create a new clause marker in a chart row.",
          "description": "Create a new clause marker in a chart row.\n\nClause markers mark clausal boundaries and dependencies in the discourse\nanalysis. They associate with word groups to identify clause structure.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            },
            {
              "name": "word_group",
              "type": "",
              "default": null,
              "description": "IConstChartWordGroup object this marker refers to"
            }
          ],
          "returns": "IConstChartClauseMarker: The newly created clause marker object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If row_or_hvo or word_group is None",
            "FP_ParameterError: If word_group is invalid type"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> marker = project.ConstChartClauseMarkers.Create(row, wg)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(marker_or_hvo)",
          "summary": "Delete a clause marker from its row.",
          "description": "Delete a clause marker from its row.\n",
          "parameters": [
            {
              "name": "marker_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartClauseMarker object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If marker_or_hvo is None"
          ],
          "example": "            >>> marker = project.ConstChartClauseMarkers.Find(row, 0)\n            >>> if marker:\n            ...     project.ConstChartClauseMarkers.Delete(marker)\n\n        Warning:\n            - This is a destructive operation\n            - Dependent clause references will be lost\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(row_or_hvo, index)",
          "summary": "Find a clause marker in a row by its index position.",
          "description": "Find a clause marker in a row by its index position.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "Zero-based index of the marker to find"
            }
          ],
          "returns": "IConstChartClauseMarker or None: The marker if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If row_or_hvo is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> marker = project.ConstChartClauseMarkers.Find(row, 0)\n            >>> if marker:\n            ...     wg = project.ConstChartClauseMarkers.GetWordGroup(marker)\n            ...     print(f\"Marker references word group {wg.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(row_or_hvo)",
          "summary": "Get all clause markers in a chart row.",
          "description": "Get all clause markers in a chart row.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            }
          ],
          "returns": "list: List of IConstChartClauseMarker objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If row_or_hvo is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> markers = project.ConstChartClauseMarkers.GetAll(row)\n            >>> for marker in markers:\n            ...     wg = project.ConstChartClauseMarkers.GetWordGroup(marker)\n            ...     print(f\"Marker for word group {wg.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDependentClauses",
          "signature": "GetDependentClauses(marker_or_hvo)",
          "summary": "Get the dependent clauses associated with a clause marker.",
          "description": "Get the dependent clauses associated with a clause marker.\n\nDependent clauses show the hierarchical structure of clausal relationships\nin the discourse.\n",
          "parameters": [
            {
              "name": "marker_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartClauseMarker object or its HVO"
            }
          ],
          "returns": "list: List of dependent clause markers (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If marker_or_hvo is None"
          ],
          "example": "            >>> marker = project.ConstChartClauseMarkers.Find(row, 0)\n            >>> dependents = project.ConstChartClauseMarkers.GetDependentClauses(marker)\n            >>> print(f\"Marker has {len(dependents)} dependent clauses\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetWordGroup",
          "signature": "GetWordGroup(marker_or_hvo)",
          "summary": "Get the word group associated with a clause marker.",
          "description": "Get the word group associated with a clause marker.\n",
          "parameters": [
            {
              "name": "marker_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartClauseMarker object or its HVO"
            }
          ],
          "returns": "IConstChartWordGroup or None: The word group, or None if not set ",
          "raises": [
            "FP_NullParameterError: If marker_or_hvo is None"
          ],
          "example": "            >>> marker = project.ConstChartClauseMarkers.Find(row, 0)\n            >>> wg = project.ConstChartClauseMarkers.GetWordGroup(marker)\n            >>> if wg:\n            ...     print(f\"Marker references word group {wg.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ConstChartClauseMarkerOperations with a FLExProject instance.",
          "description": "Initialize ConstChartClauseMarkerOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartRow",
        "IConstChartWordGroup"
      ],
      "tags": [
        "discourse",
        "operations"
      ]
    },
    "ConstChartMovedTextOperations": {
      "name": "ConstChartMovedTextOperations",
      "type": "class",
      "namespace": "FlexLibs2.Discourse.ConstChartMovedTextOperations",
      "source_file": "Discourse/ConstChartMovedTextOperations",
      "category": "discourse",
      "summary": "This class provides operations for managing moved text markers in constituent\ncharts for discourse analysis in FieldWorks projects.",
      "description": "This class provides operations for managing moved text markers in constituent\ncharts for discourse analysis in FieldWorks projects.\n\nMoved text markers indicate that a word group represents text that has been\nmoved from its canonical position (preposed or postposed) in the discourse\nstructure.\n\nThis class should be accessed via FLExProject.ConstChartMovedText property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a word group\nchart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\nrow = project.ConstChartRows.Find(chart, 0)\nwg = project.ConstChartWordGroups.Find(row, 0)\n\n# Mark as preposed text\nmarker = project.ConstChartMovedText.Create(wg, preposed=True)\n\n# Check if preposed\nif project.ConstChartMovedText.IsPreposed(marker):\nprint(\"Text is preposed\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(word_group_or_hvo, preposed=True)",
          "summary": "Create a moved text marker for a word group.",
          "description": "Create a moved text marker for a word group.\n\nMarks a word group as containing moved text (either preposed or postposed\nfrom its canonical position in the discourse).\n",
          "parameters": [
            {
              "name": "word_group_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartWordGroup object or its HVO"
            },
            {
              "name": "preposed",
              "type": "bool",
              "default": true,
              "description": "True if text is preposed (moved earlier), False if postposed (moved later). Default is True."
            }
          ],
          "returns": "IConstChartMovedTextMarker: The newly created marker object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If word_group_or_hvo is None"
          ],
          "example": "            >>> # Mark word group as preposed\n            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> marker = project.ConstChartMovedText.Create(wg, preposed=True)\n            >>> print(project.ConstChartMovedText.IsPreposed(marker))\n            True\n\n            >>> # Mark as postposed\n            >>> marker = project.ConstChartMovedText.Create(wg, preposed=False)\n            >>> print(project.ConstChartMovedText.IsPreposed(marker))\n            False\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(marker_or_hvo)",
          "summary": "Delete a moved text marker.",
          "description": "Delete a moved text marker.\n",
          "parameters": [
            {
              "name": "marker_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartMovedTextMarker object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If marker_or_hvo is None"
          ],
          "example": "            >>> marker = project.ConstChartMovedText.Find(wg)\n            >>> if marker:\n            ...     project.ConstChartMovedText.Delete(marker)\n\n        Warning:\n            - This is a destructive operation\n            - Cannot be undone\n            - Word group will no longer be marked as moved\n\n        See Also:\n            Create, Find",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(word_group_or_hvo)",
          "summary": "Find the moved text marker for a word group.",
          "description": "Find the moved text marker for a word group.\n",
          "parameters": [
            {
              "name": "word_group_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartWordGroup object or its HVO"
            }
          ],
          "returns": "IConstChartMovedTextMarker or None: The marker if exists, None otherwise ",
          "raises": [
            "FP_NullParameterError: If word_group_or_hvo is None"
          ],
          "example": "            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> marker = project.ConstChartMovedText.Find(wg)\n            >>> if marker:\n            ...     print(\"Word group has moved text marker\")\n            ...     if project.ConstChartMovedText.IsPreposed(marker):\n            ...         print(\"Text is preposed\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(chart_or_hvo)",
          "summary": "Get all moved text markers in a constituent chart.",
          "description": "Get all moved text markers in a constituent chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            }
          ],
          "returns": "list: List of IConstChartMovedTextMarker objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> markers = project.ConstChartMovedText.GetAll(chart)\n            >>> preposed_count = sum(1 for m in markers\n            ...     if project.ConstChartMovedText.IsPreposed(m))\n            >>> print(f\"Found {preposed_count} preposed markers\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetWordGroup",
          "signature": "GetWordGroup(marker_or_hvo)",
          "summary": "Get the word group associated with a moved text marker.",
          "description": "Get the word group associated with a moved text marker.\n",
          "parameters": [
            {
              "name": "marker_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartMovedTextMarker object or its HVO"
            }
          ],
          "returns": "IConstChartWordGroup or None: The word group, or None if not found ",
          "raises": [
            "FP_NullParameterError: If marker_or_hvo is None"
          ],
          "example": "            >>> marker = project.ConstChartMovedText.Find(wg)\n            >>> if marker:\n            ...     word_group = project.ConstChartMovedText.GetWordGroup(marker)\n            ...     if word_group:\n            ...         print(f\"Marker belongs to word group {word_group.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsPreposed",
          "signature": "IsPreposed(marker_or_hvo)",
          "summary": "Check if a moved text marker indicates preposed text.",
          "description": "Check if a moved text marker indicates preposed text.\n",
          "parameters": [
            {
              "name": "marker_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartMovedTextMarker object or its HVO"
            }
          ],
          "returns": "bool: True if text is preposed, False if postposed ",
          "raises": [
            "FP_NullParameterError: If marker_or_hvo is None"
          ],
          "example": "            >>> marker = project.ConstChartMovedText.Find(wg)\n            >>> if marker:\n            ...     if project.ConstChartMovedText.IsPreposed(marker):\n            ...         print(\"Text moved earlier\")\n            ...     else:\n            ...         print(\"Text moved later\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetPreposed",
          "signature": "SetPreposed(marker_or_hvo, value)",
          "summary": "Set whether moved text is preposed or postposed.",
          "description": "Set whether moved text is preposed or postposed.\n",
          "parameters": [
            {
              "name": "marker_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartMovedTextMarker object or its HVO"
            },
            {
              "name": "value",
              "type": "bool",
              "default": null,
              "description": "True for preposed, False for postposed"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If marker_or_hvo or value is None"
          ],
          "example": "            >>> marker = project.ConstChartMovedText.Find(wg)\n            >>> if marker:\n            ...     # Change from preposed to postposed\n            ...     project.ConstChartMovedText.SetPreposed(marker, False)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ConstChartMovedTextOperations with a FLExProject instance.",
          "description": "Initialize ConstChartMovedTextOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartWordGroup",
        "IDsConstChart"
      ],
      "tags": [
        "discourse",
        "operations"
      ]
    },
    "ConstChartOperations": {
      "name": "ConstChartOperations",
      "type": "class",
      "namespace": "FlexLibs2.Discourse.ConstChartOperations",
      "source_file": "Discourse/ConstChartOperations",
      "category": "discourse",
      "summary": "This class provides operations for managing constituent charts in a\nFieldWorks project for discourse analysis.",
      "description": "This class provides operations for managing constituent charts in a\nFieldWorks project for discourse analysis.\n\nConstituent charts are used to analyze the structure of texts, showing\nhow clauses, phrases, and other discourse elements are organized. Each\nchart contains rows that represent segments of the analyzed text.\n\nThis class should be accessed via FLExProject.ConstCharts property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Create a new constituent chart\nchart = project.ConstCharts.Create(\"Genesis 1 Analysis\")\n\n# Get all charts\nfor chart in project.ConstCharts.GetAll():\nname = project.ConstCharts.GetName(chart)\nprint(f\"Chart: {name}\")\n\n# Find a specific chart\nchart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(name, template=None)",
          "summary": "Create a new constituent chart for discourse analysis.",
          "description": "Create a new constituent chart for discourse analysis.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the chart (e.g., \"Genesis 1 Analysis\")"
            },
            {
              "name": "template",
              "type": "ICmPossibility, optional",
              "default": null,
              "description": "Chart template to use. If None, creates a chart without a template."
            }
          ],
          "returns": "IDsConstChart: The newly created chart object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> # Create a simple chart\n            >>> chart = project.ConstCharts.Create(\"Matthew 5 Analysis\")\n            >>> print(project.ConstCharts.GetName(chart))\n            Matthew 5 Analysis\n\n            >>> # Create chart with template\n            >>> template = project.ConstCharts.GetTemplate(existing_chart)\n            >>> chart = project.ConstCharts.Create(\"New Analysis\", template)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(chart_or_hvo)",
          "summary": "Delete a constituent chart from the project.",
          "description": "Delete a constituent chart from the project.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO (database ID)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If chart_or_hvo is None",
            "FP_ParameterError: If chart doesn't exist"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Old Analysis\")\n            >>> if chart:\n            ...     project.ConstCharts.Delete(chart)\n\n            >>> # Delete by HVO\n            >>> project.ConstCharts.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - All rows, word groups, and markers will be deleted\n            - Cannot be undone\n            - Chart will be removed from discourse data\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find a constituent chart by its name.",
          "description": "Find a constituent chart by its name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The chart name to search for"
            }
          ],
          "returns": "IDsConstChart or None: The chart object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> if chart:\n            ...     name = project.ConstCharts.GetName(chart)\n            ...     print(f\"Found: {name}\")\n            Found: Genesis 1 Analysis\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByHvo",
          "signature": "FindByHvo(hvo)",
          "summary": "Find a constituent chart by its HVO (database ID).",
          "description": "Find a constituent chart by its HVO (database ID).\n",
          "parameters": [
            {
              "name": "hvo",
              "type": "int",
              "default": null,
              "description": "The HVO to search for"
            }
          ],
          "returns": "IDsConstChart or None: The chart object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.FindByHvo(12345)\n            >>> if chart:\n            ...     print(\"Chart found\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all constituent charts in the project.",
          "description": "Get all constituent charts in the project.\n\nThis method returns an iterator over all IDsConstChart objects in the\nproject database, allowing iteration over all discourse analysis charts.\n",
          "parameters": [],
          "returns": "IDsConstChart: Each constituent chart object in the project ",
          "raises": [],
          "example": "            >>> for chart in project.ConstCharts.GetAll():\n            ...     name = project.ConstCharts.GetName(chart)\n            ...     row_count = chart.RowsOS.Count\n            ...     print(f\"{name} ({row_count} rows)\")\n            Genesis 1 Analysis (45 rows)\n            Mark 1 Analysis (32 rows)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(chart_or_hvo)",
          "summary": "Get the name of a constituent chart.",
          "description": "Get the name of a constituent chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            }
          ],
          "returns": "str: The chart name (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> name = project.ConstCharts.GetName(chart)\n            >>> print(name)\n            Genesis 1 Analysis\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRows",
          "signature": "GetRows(chart_or_hvo)",
          "summary": "Get all rows in a constituent chart.",
          "description": "Get all rows in a constituent chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            }
          ],
          "returns": "list: List of IConstChartRow objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> rows = project.ConstCharts.GetRows(chart)\n            >>> for row in rows:\n            ...     label = project.ConstChartRows.GetLabel(row)\n            ...     print(f\"Row: {label}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTemplate",
          "signature": "GetTemplate(chart_or_hvo)",
          "summary": "Get the template associated with a constituent chart.",
          "description": "Get the template associated with a constituent chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            }
          ],
          "returns": "ICmPossibility or None: The template object, or None if not set ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> template = project.ConstCharts.GetTemplate(chart)\n            >>> if template:\n            ...     print(\"Chart has template\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(chart_or_hvo, name)",
          "summary": "Set the name of a constituent chart.",
          "description": "Set the name of a constituent chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new chart name"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If chart_or_hvo or name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Old Name\")\n            >>> project.ConstCharts.SetName(chart, \"New Name\")\n            >>> print(project.ConstCharts.GetName(chart))\n            New Name\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetTemplate",
          "signature": "SetTemplate(chart_or_hvo, template)",
          "summary": "Set the template for a constituent chart.",
          "description": "Set the template for a constituent chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            },
            {
              "name": "template",
              "type": "",
              "default": null,
              "description": "ICmPossibility template object (can be None to clear)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If chart_or_hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> template = project.ConstCharts.GetTemplate(other_chart)\n            >>> project.ConstCharts.SetTemplate(chart, template)\n\n            >>> # Clear template\n            >>> project.ConstCharts.SetTemplate(chart, None)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ConstChartOperations with a FLExProject instance.",
          "description": "Initialize ConstChartOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ],
      "tags": [
        "discourse",
        "operations"
      ]
    },
    "ConstChartRowOperations": {
      "name": "ConstChartRowOperations",
      "type": "class",
      "namespace": "FlexLibs2.Discourse.ConstChartRowOperations",
      "source_file": "Discourse/ConstChartRowOperations",
      "category": "discourse",
      "summary": "This class provides operations for managing constituent chart rows in a\nFieldWorks project for discourse analysis.",
      "description": "This class provides operations for managing constituent chart rows in a\nFieldWorks project for discourse analysis.\n\nChart rows represent segments or units of analyzed text within a constituent\nchart. Each row can contain word groups, labels, and notes describing the\ndiscourse structure.\n\nThis class should be accessed via FLExProject.ConstChartRows property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a chart\nchart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n\n# Create a new row\nrow = project.ConstChartRows.Create(chart, label=\"Verse 1\")\n\n# Get all rows in a chart\nfor row in project.ConstChartRows.GetAll(chart):\nlabel = project.ConstChartRows.GetLabel(row)\nprint(f\"Row: {label}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(chart_or_hvo, label='', notes='')",
          "summary": "Create a new row in a constituent chart.",
          "description": "Create a new row in a constituent chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            },
            {
              "name": "label",
              "type": "str, optional",
              "default": "",
              "description": "Label for the row (e.g., \"Verse 1\", \"Line 3\")"
            },
            {
              "name": "notes",
              "type": "str, optional",
              "default": "",
              "description": "Notes describing the row"
            }
          ],
          "returns": "IConstChartRow: The newly created row object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If chart_or_hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> row = project.ConstChartRows.Create(chart, label=\"Verse 1\")\n            >>> print(project.ConstChartRows.GetLabel(row))\n            Verse 1\n\n            >>> # Create with label and notes\n            >>> row = project.ConstChartRows.Create(chart,\n            ...     label=\"Verse 2\",\n            ...     notes=\"Complex sentence structure\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(row_or_hvo)",
          "summary": "Delete a row from its constituent chart.",
          "description": "Delete a row from its constituent chart.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO (database ID)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If row_or_hvo is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> if row:\n            ...     project.ConstChartRows.Delete(row)\n\n            >>> # Delete by HVO\n            >>> project.ConstChartRows.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - All word groups and markers in the row will be deleted\n            - Cannot be undone\n            - Row will be removed from the chart\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(chart_or_hvo, index)",
          "summary": "Find a row in a chart by its index position.",
          "description": "Find a row in a chart by its index position.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "Zero-based index of the row to find"
            }
          ],
          "returns": "IConstChartRow or None: The row object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> row = project.ConstChartRows.Find(chart, 0)  # First row\n            >>> if row:\n            ...     label = project.ConstChartRows.GetLabel(row)\n            ...     print(f\"First row: {label}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(chart_or_hvo)",
          "summary": "Get all rows in a constituent chart.",
          "description": "Get all rows in a constituent chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            }
          ],
          "returns": "list: List of IConstChartRow objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> rows = project.ConstChartRows.GetAll(chart)\n            >>> for i, row in enumerate(rows):\n            ...     label = project.ConstChartRows.GetLabel(row)\n            ...     print(f\"Row {i}: {label}\")\n            Row 0: Verse 1\n            Row 1: Verse 2\n            Row 2: Verse 3\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLabel",
          "signature": "GetLabel(row_or_hvo, ws=None)",
          "summary": "Get the label of a chart row.",
          "description": "Get the label of a chart row.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The row label (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If row_or_hvo is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> label = project.ConstChartRows.GetLabel(row)\n            >>> print(label)\n            Verse 1\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetNotes",
          "signature": "GetNotes(row_or_hvo, ws=None)",
          "summary": "Get the notes of a chart row.",
          "description": "Get the notes of a chart row.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The row notes (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If row_or_hvo is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> notes = project.ConstChartRows.GetNotes(row)\n            >>> print(notes)\n            Complex sentence with embedded clause\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetWordGroups",
          "signature": "GetWordGroups(row_or_hvo)",
          "summary": "Get all word groups in a chart row.",
          "description": "Get all word groups in a chart row.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            }
          ],
          "returns": "list: List of IConstChartWordGroup objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If row_or_hvo is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> word_groups = project.ConstChartRows.GetWordGroups(row)\n            >>> for wg in word_groups:\n            ...     # Process word group\n            ...     pass\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveTo",
          "signature": "MoveTo(row_or_hvo, chart_or_hvo, index)",
          "summary": "Move a row to a specific position in a chart.",
          "description": "Move a row to a specific position in a chart.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            },
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Target chart (can be same or different chart)"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "Target index position (zero-based)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If row_or_hvo or chart_or_hvo is None",
            "FP_ParameterError: If index is out of range"
          ],
          "example": "            >>> # Move row to beginning of same chart\n            >>> row = project.ConstChartRows.Find(chart, 5)\n            >>> project.ConstChartRows.MoveTo(row, chart, 0)\n\n            >>> # Move row to different chart\n            >>> other_chart = project.ConstCharts.Find(\"Other Analysis\")\n            >>> project.ConstChartRows.MoveTo(row, other_chart, 0)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLabel",
          "signature": "SetLabel(row_or_hvo, text, ws=None)",
          "summary": "Set the label of a chart row.",
          "description": "Set the label of a chart row.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new label text"
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If row_or_hvo or text is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> project.ConstChartRows.SetLabel(row, \"Verse 1a\")\n            >>> print(project.ConstChartRows.GetLabel(row))\n            Verse 1a\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetNotes",
          "signature": "SetNotes(row_or_hvo, text, ws=None)",
          "summary": "Set the notes of a chart row.",
          "description": "Set the notes of a chart row.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new notes text"
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If row_or_hvo or text is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> project.ConstChartRows.SetNotes(row,\n            ...     \"Subject-predicate structure with modifier\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ConstChartRowOperations with a FLExProject instance.",
          "description": "Initialize ConstChartRowOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "discourse",
        "operations"
      ]
    },
    "ConstChartTagOperations": {
      "name": "ConstChartTagOperations",
      "type": "class",
      "namespace": "FlexLibs2.Discourse.ConstChartTagOperations",
      "source_file": "Discourse/ConstChartTagOperations",
      "category": "discourse",
      "summary": "This class provides operations for managing chart tags (discourse markers)\nin constituent charts for discourse analysis in FieldWorks projects.",
      "description": "This class provides operations for managing chart tags (discourse markers)\nin constituent charts for discourse analysis in FieldWorks projects.\n\nChart tags are possibility items that can be used to categorize and mark\nelements within discourse charts. They provide a vocabulary for discourse\nannotation.\n\nThis class should be accessed via FLExProject.ConstChartTags property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a chart\nchart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n\n# Create a tag\ntag = project.ConstChartTags.Create(chart, \"Topic\")\n\n# Get all tags\nfor tag in project.ConstChartTags.GetAll(chart):\nname = project.ConstChartTags.GetName(tag)\nprint(f\"Tag: {name}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(chart_or_hvo, tag_name)",
          "summary": "Create a new chart tag possibility.",
          "description": "Create a new chart tag possibility.\n\nCreates a tag that can be used to mark elements in the discourse chart.\nTags are stored as possibility items within the chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            },
            {
              "name": "tag_name",
              "type": "str",
              "default": null,
              "description": "The name of the tag (e.g., \"Topic\", \"Focus\", \"Tail\")"
            }
          ],
          "returns": "ICmPossibility: The newly created tag possibility object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If chart_or_hvo or tag_name is None",
            "FP_ParameterError: If tag_name is empty"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> tag = project.ConstChartTags.Create(chart, \"Topic\")\n            >>> print(project.ConstChartTags.GetName(tag))\n            Topic\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(tag_or_hvo)",
          "summary": "Delete a chart tag.",
          "description": "Delete a chart tag.\n",
          "parameters": [
            {
              "name": "tag_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a tag possibility object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If tag_or_hvo is None"
          ],
          "example": "            >>> tag = project.ConstChartTags.Find(chart, \"Old Tag\")\n            >>> if tag:\n            ...     project.ConstChartTags.Delete(tag)\n\n        Warning:\n            - This is a destructive operation\n            - Cannot be undone\n            - References to this tag from word groups may become invalid\n\n        See Also:\n            Create, Find",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(chart_or_hvo, name)",
          "summary": "Find a chart tag by its name.",
          "description": "Find a chart tag by its name.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The tag name to search for"
            }
          ],
          "returns": "ICmPossibility or None: The tag if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo or name is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> tag = project.ConstChartTags.Find(chart, \"Topic\")\n            >>> if tag:\n            ...     desc = project.ConstChartTags.GetDescription(tag)\n            ...     print(f\"Tag: {desc}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(chart_or_hvo)",
          "summary": "Get all chart tags for a constituent chart.",
          "description": "Get all chart tags for a constituent chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IDsConstChart object or its HVO"
            }
          ],
          "returns": "list: List of tag possibility objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None"
          ],
          "example": "            >>> chart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\n            >>> tags = project.ConstChartTags.GetAll(chart)\n            >>> for tag in tags:\n            ...     name = project.ConstChartTags.GetName(tag)\n            ...     print(f\"Tag: {name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(tag_or_hvo, ws=None)",
          "summary": "Get the description of a chart tag.",
          "description": "Get the description of a chart tag.\n",
          "parameters": [
            {
              "name": "tag_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a tag possibility object or its HVO"
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The tag description (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If tag_or_hvo is None"
          ],
          "example": "            >>> tag = project.ConstChartTags.Find(chart, \"Topic\")\n            >>> desc = project.ConstChartTags.GetDescription(tag)\n            >>> print(desc)\n            Marks the topic of the sentence\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(tag_or_hvo)",
          "summary": "Get the name of a chart tag.",
          "description": "Get the name of a chart tag.\n",
          "parameters": [
            {
              "name": "tag_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a tag possibility object or its HVO"
            }
          ],
          "returns": "str: The tag name (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If tag_or_hvo is None"
          ],
          "example": "            >>> tag = project.ConstChartTags.Find(chart, \"Topic\")\n            >>> name = project.ConstChartTags.GetName(tag)\n            >>> print(name)\n            Topic\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(tag_or_hvo, text, ws=None)",
          "summary": "Set the description of a chart tag.",
          "description": "Set the description of a chart tag.\n",
          "parameters": [
            {
              "name": "tag_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a tag possibility object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new description text"
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If tag_or_hvo or text is None"
          ],
          "example": "            >>> tag = project.ConstChartTags.Find(chart, \"Topic\")\n            >>> project.ConstChartTags.SetDescription(tag,\n            ...     \"Marks the topic of the sentence\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(tag_or_hvo, name)",
          "summary": "Set the name of a chart tag.",
          "description": "Set the name of a chart tag.\n",
          "parameters": [
            {
              "name": "tag_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a tag possibility object or its HVO"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new tag name"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If tag_or_hvo or name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> tag = project.ConstChartTags.Find(chart, \"Old Name\")\n            >>> project.ConstChartTags.SetName(tag, \"New Name\")\n            >>> print(project.ConstChartTags.GetName(tag))\n            New Name\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ConstChartTagOperations with a FLExProject instance.",
          "description": "Initialize ConstChartTagOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "discourse",
        "operations"
      ]
    },
    "ConstChartWordGroupOperations": {
      "name": "ConstChartWordGroupOperations",
      "type": "class",
      "namespace": "FlexLibs2.Discourse.ConstChartWordGroupOperations",
      "source_file": "Discourse/ConstChartWordGroupOperations",
      "category": "discourse",
      "summary": "This class provides operations for managing word groups in constituent chart rows\nfor discourse analysis in FieldWorks projects.",
      "description": "This class provides operations for managing word groups in constituent chart rows\nfor discourse analysis in FieldWorks projects.\n\nWord groups represent segments of text being analyzed in a discourse chart. Each\nword group references a range of segments (words/morphemes) from the analyzed text.\n\nThis class should be accessed via FLExProject.ConstChartWordGroups property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a row\nchart = project.ConstCharts.Find(\"Genesis 1 Analysis\")\nrow = project.ConstChartRows.Find(chart, 0)\n\n# Create a word group (referencing text segments)\nwg = project.ConstChartWordGroups.Create(row, begin_segment, end_segment)\n\n# Get all word groups in a row\nfor wg in project.ConstChartWordGroups.GetAll(row):\n# Process word group\npass\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(row_or_hvo, begin_segment, end_segment)",
          "summary": "Create a new word group in a chart row.",
          "description": "Create a new word group in a chart row.\n\nWord groups represent a range of text segments being analyzed. The\nbegin and end segments define the span of text this word group covers.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            },
            {
              "name": "begin_segment",
              "type": "",
              "default": null,
              "description": "ISegment object marking the start of the range"
            },
            {
              "name": "end_segment",
              "type": "",
              "default": null,
              "description": "ISegment object marking the end of the range (inclusive)"
            }
          ],
          "returns": "IConstChartWordGroup: The newly created word group object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If any parameter is None",
            "FP_ParameterError: If segments are invalid"
          ],
          "example": "            >>> # Get segments from a text\n            >>> text = project.Texts.Find(\"Genesis 1\")\n            >>> para = text.ContentsOA.ParagraphsOS[0]\n            >>> segments = list(para.SegmentsOS)\n            >>>\n            >>> # Create word group spanning first 3 words\n            >>> wg = project.ConstChartWordGroups.Create(\n            ...     row,\n            ...     segments[0],  # Begin\n            ...     segments[2]   # End\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(group_or_hvo)",
          "summary": "Delete a word group from its chart row.",
          "description": "Delete a word group from its chart row.\n",
          "parameters": [
            {
              "name": "group_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartWordGroup object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If group_or_hvo is None"
          ],
          "example": "            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> if wg:\n            ...     project.ConstChartWordGroups.Delete(wg)\n\n        Warning:\n            - This is a destructive operation\n            - All moved text markers and clause markers will be deleted\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(row_or_hvo, index)",
          "summary": "Find a word group in a row by its index position.",
          "description": "Find a word group in a row by its index position.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "Zero-based index of the word group to find"
            }
          ],
          "returns": "IConstChartWordGroup or None: The word group object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If row_or_hvo is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> wg = project.ConstChartWordGroups.Find(row, 0)  # First word group\n            >>> if wg:\n            ...     begin = project.ConstChartWordGroups.GetBeginSegment(wg)\n            ...     print(f\"Word group starts at segment {begin.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(row_or_hvo)",
          "summary": "Get all word groups in a chart row.",
          "description": "Get all word groups in a chart row.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO"
            }
          ],
          "returns": "list: List of IConstChartWordGroup objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If row_or_hvo is None"
          ],
          "example": "            >>> row = project.ConstChartRows.Find(chart, 0)\n            >>> word_groups = project.ConstChartWordGroups.GetAll(row)\n            >>> for i, wg in enumerate(word_groups):\n            ...     print(f\"Word group {i}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBeginSegment",
          "signature": "GetBeginSegment(group_or_hvo)",
          "summary": "Get the beginning segment of a word group.",
          "description": "Get the beginning segment of a word group.\n",
          "parameters": [
            {
              "name": "group_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartWordGroup object or its HVO"
            }
          ],
          "returns": "ISegment or None: The beginning segment, or None if not set ",
          "raises": [
            "FP_NullParameterError: If group_or_hvo is None"
          ],
          "example": "            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> begin_seg = project.ConstChartWordGroups.GetBeginSegment(wg)\n            >>> if begin_seg:\n            ...     print(f\"Starts at segment {begin_seg.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetColumn",
          "signature": "GetColumn(group_or_hvo)",
          "summary": "Get the column position of a word group in the chart.",
          "description": "Get the column position of a word group in the chart.\n",
          "parameters": [
            {
              "name": "group_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartWordGroup object or its HVO"
            }
          ],
          "returns": "ICmPossibility or None: The column object, or None if not set ",
          "raises": [
            "FP_NullParameterError: If group_or_hvo is None"
          ],
          "example": "            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> column = project.ConstChartWordGroups.GetColumn(wg)\n            >>> if column:\n            ...     col_name = ITsString(column.Name.BestAnalysisAlternative).Text\n            ...     print(f\"Column: {col_name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEndSegment",
          "signature": "GetEndSegment(group_or_hvo)",
          "summary": "Get the ending segment of a word group.",
          "description": "Get the ending segment of a word group.\n",
          "parameters": [
            {
              "name": "group_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartWordGroup object or its HVO"
            }
          ],
          "returns": "ISegment or None: The ending segment, or None if not set ",
          "raises": [
            "FP_NullParameterError: If group_or_hvo is None"
          ],
          "example": "            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> end_seg = project.ConstChartWordGroups.GetEndSegment(wg)\n            >>> if end_seg:\n            ...     print(f\"Ends at segment {end_seg.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetBeginSegment",
          "signature": "SetBeginSegment(group_or_hvo, segment)",
          "summary": "Set the beginning segment of a word group.",
          "description": "Set the beginning segment of a word group.\n",
          "parameters": [
            {
              "name": "group_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartWordGroup object or its HVO"
            },
            {
              "name": "segment",
              "type": "",
              "default": null,
              "description": "ISegment object to set as beginning (can be None to clear)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If group_or_hvo is None",
            "FP_ParameterError: If segment is invalid type"
          ],
          "example": "            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> new_segment = segments[5]\n            >>> project.ConstChartWordGroups.SetBeginSegment(wg, new_segment)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetColumn",
          "signature": "SetColumn(group_or_hvo, column)",
          "summary": "Set the column position of a word group in the chart.",
          "description": "Set the column position of a word group in the chart.\n",
          "parameters": [
            {
              "name": "group_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartWordGroup object or its HVO"
            },
            {
              "name": "column",
              "type": "",
              "default": null,
              "description": "ICmPossibility column object (can be None to clear)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If group_or_hvo is None"
          ],
          "example": "            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> # Get column from template\n            >>> template = project.ConstCharts.GetTemplate(chart)\n            >>> column = template.SubPossibilitiesOS[0]  # First column\n            >>> project.ConstChartWordGroups.SetColumn(wg, column)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetEndSegment",
          "signature": "SetEndSegment(group_or_hvo, segment)",
          "summary": "Set the ending segment of a word group.",
          "description": "Set the ending segment of a word group.\n",
          "parameters": [
            {
              "name": "group_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartWordGroup object or its HVO"
            },
            {
              "name": "segment",
              "type": "",
              "default": null,
              "description": "ISegment object to set as ending (can be None to clear)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If group_or_hvo is None",
            "FP_ParameterError: If segment is invalid type"
          ],
          "example": "            >>> wg = project.ConstChartWordGroups.Find(row, 0)\n            >>> new_segment = segments[10]\n            >>> project.ConstChartWordGroups.SetEndSegment(wg, new_segment)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ConstChartWordGroupOperations with a FLExProject instance.",
          "description": "Initialize ConstChartWordGroupOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ],
      "tags": [
        "discourse",
        "operations"
      ]
    },
    "EnvironmentOperations": {
      "name": "EnvironmentOperations",
      "type": "class",
      "namespace": "FlexLibs2.Grammar.EnvironmentOperations",
      "source_file": "Grammar/EnvironmentOperations",
      "category": "grammar",
      "summary": "This class provides operations for managing phonological environments in a\nFieldWorks project.",
      "description": "This class provides operations for managing phonological environments in a\nFieldWorks project.\n\nPhonological environments specify the context in which phonological rules\napply. They describe what precedes and follows a segment, using notation\nlike V_V (between vowels), #_ (word-initially), _# (word-finally), etc.\n\nUsage::\n\nfrom flexlibs import FLExProject, EnvironmentOperations\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\nenvOps = EnvironmentOperations(project)\n\n# Get all environments\nfor env in envOps.GetAll():\nname = envOps.GetName(env)\nnotation = envOps.GetStringRepresentation(env)\nprint(f\"{name}: {notation}\")\n\n# Create a new environment\nword_initial = envOps.Create(\"Word Initial\", \"At the beginning of a word\")\nenvOps.SetStringRepresentation(word_initial, \"#_\")\n\n# Create more environments\nbetween_vowels = envOps.Create(\"Between Vowels\")\nenvOps.SetStringRepresentation(between_vowels, \"V_V\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two environments and return detailed differences.",
          "description": "Compare two environments and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First environment to compare (from source project)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second environment to compare (from target project)."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional EnvironmentOperations instance for item1's project. Defaults to self."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional EnvironmentOperations instance for item2's project. Defaults to self."
            }
          ],
          "returns": "tuple: (is_different, differences) where: - is_different (bool): True if items differ - differences (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> env1 = project1_envOps.Find(\"Word Initial\")\n            >>> env2 = project2_envOps.Find(\"Word Initial\")\n            >>> is_diff, diffs = project1_envOps.CompareTo(\n            ...     env1, env2,\n            ...     ops1=project1_envOps,\n            ...     ops2=project2_envOps\n            ... )\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} -> {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, description=None)",
          "summary": "Create a new phonological environment.",
          "description": "Create a new phonological environment.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the environment (e.g., \"Word Initial\", \"Between Vowels\")."
            },
            {
              "name": "description",
              "type": "str, optional",
              "default": null,
              "description": "Optional description of when this environment applies. Defaults to None."
            }
          ],
          "returns": "IPhEnvironment: The newly created environment object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> word_initial = envOps.Create(\"Word Initial\", \"At word start\")\n            >>> envOps.SetStringRepresentation(word_initial, \"#_\")\n            >>> print(envOps.GetName(word_initial))\n            Word Initial\n\n            >>> between_vowels = envOps.Create(\"Between Vowels\")\n            >>> envOps.SetStringRepresentation(between_vowels, \"V_V\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(env_or_hvo)",
          "summary": "Delete a phonological environment.",
          "description": "Delete a phonological environment.\n",
          "parameters": [
            {
              "name": "env_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If env_or_hvo is None.",
            "FP_ParameterError: If the environment is in use and cannot be deleted."
          ],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> obsolete = envOps.Create(\"Obsolete Environment\")\n            >>> # ... realize it's not needed\n            >>> envOps.Delete(obsolete)\n\n        Warning:\n            - Deleting an environment that is in use may raise an error from FLEx\n            - This includes environments used in phonological rules and allomorph\n              conditions\n            - Deletion is permanent and cannot be undone\n            - Consider checking usage before deletion\n\n        See Also:\n            Create, GetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a phonological environment, creating a new copy with a new GUID.",
          "description": "Duplicate a phonological environment, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source environment. If False, insert at end of environments list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, deep copy owned context objects (LeftContextOA, RightContextOA). If False (default), contexts are not copied."
            }
          ],
          "returns": "IPhEnvironment: The newly created duplicate environment with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> word_initial = envOps.Create(\"Word Initial\")\n            >>> envOps.SetStringRepresentation(word_initial, \"#_\")\n            >>> # Shallow copy (no context objects)\n            >>> copy = envOps.Duplicate(word_initial)\n            >>> print(envOps.GetName(copy))\n            Word Initial\n\n            >>> # Deep copy (includes owned context objects)\n            >>> between_vowels = envOps.Create(\"Between Vowels\")\n            >>> copy = envOps.Duplicate(between_vowels, deep=True)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all phonological environments in the project.",
          "description": "Get all phonological environments in the project.\n",
          "parameters": [],
          "returns": "IPhEnvironment: Each environment object in the project's environment list. ",
          "raises": [],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> for env in envOps.GetAll():\n            ...     name = envOps.GetName(env)\n            ...     notation = envOps.GetStringRepresentation(env)\n            ...     print(f\"{name}: {notation}\")\n            Word Initial: #_\n            Word Final: _#\n            Between Vowels: V_V\n            Before Consonant: _C\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLeftContextPattern",
          "signature": "GetLeftContextPattern(env_or_hvo)",
          "summary": "Get the left context pattern of a phonological environment (READ-ONLY).",
          "description": "Get the left context pattern of a phonological environment (READ-ONLY).\n\nThis is a computed property that returns the left context specification\nof the environment, representing what must precede the target position.\n",
          "parameters": [
            {
              "name": "env_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO."
            }
          ],
          "returns": "object or None: The left context object (IPhPhonContext) if set, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If env_or_hvo is None."
          ],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> env = envOps.Create(\"After Vowel\")\n            >>> left_ctx = envOps.GetLeftContextPattern(env)\n            >>> if left_ctx:\n            ...     print(f\"Has left context: {left_ctx}\")\n            >>> else:\n            ...     print(\"No left context constraint\")\n\n            >>> # Check all environments for left context\n            >>> for env in envOps.GetAll():\n            ...     name = envOps.GetName(env)\n            ...     left_ctx = envOps.GetLeftContextPattern(env)\n            ...     if left_ctx:\n            ...         print(f\"{name} has left context\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(env_or_hvo, wsHandle=None)",
          "summary": "Get the name of a phonological environment.",
          "description": "Get the name of a phonological environment.\n",
          "parameters": [
            {
              "name": "env_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The environment name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If env_or_hvo is None."
          ],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> for env in envOps.GetAll():\n            ...     name = envOps.GetName(env)\n            ...     print(name)\n            Word Initial\n            Word Final\n            Between Vowels\n\n            >>> # Get name in a specific writing system\n            >>> env = list(envOps.GetAll())[0]\n            >>> name = envOps.GetName(env, project.WSHandle('en'))\n\n        See Also:\n            SetName, GetStringRepresentation",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRightContextPattern",
          "signature": "GetRightContextPattern(env_or_hvo)",
          "summary": "Get the right context pattern of a phonological environment (READ-ONLY).",
          "description": "Get the right context pattern of a phonological environment (READ-ONLY).\n\nThis is a computed property that returns the right context specification\nof the environment, representing what must follow the target position.\n",
          "parameters": [
            {
              "name": "env_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO."
            }
          ],
          "returns": "object or None: The right context object (IPhPhonContext) if set, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If env_or_hvo is None."
          ],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> env = envOps.Create(\"Before Consonant\")\n            >>> right_ctx = envOps.GetRightContextPattern(env)\n            >>> if right_ctx:\n            ...     print(f\"Has right context: {right_ctx}\")\n            >>> else:\n            ...     print(\"No right context constraint\")\n\n            >>> # Check all environments for right context\n            >>> for env in envOps.GetAll():\n            ...     name = envOps.GetName(env)\n            ...     right_ctx = envOps.GetRightContextPattern(env)\n            ...     if right_ctx:\n            ...         print(f\"{name} has right context\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetStringRepresentation",
          "signature": "GetStringRepresentation(env_or_hvo, wsHandle=None)",
          "summary": "Get the string representation (notation) of a phonological environment.",
          "description": "Get the string representation (notation) of a phonological environment.\n",
          "parameters": [
            {
              "name": "env_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The environment's string representation (e.g., \"V_V\", \"#_\", \"_#\"), or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If env_or_hvo is None."
          ],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> for env in envOps.GetAll():\n            ...     name = envOps.GetName(env)\n            ...     notation = envOps.GetStringRepresentation(env)\n            ...     print(f\"{name:20} {notation}\")\n            Word Initial         #_\n            Word Final           _#\n            Between Vowels       V_V\n            After Nasal          N_\n            Before Stop          _P\n\n            >>> # Use in rule description\n            >>> env = list(envOps.GetAll())[0]\n            >>> notation = envOps.GetStringRepresentation(env)\n            >>> print(f\"Rule applies in: {notation}\")\n            Rule applies in: V_V\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get dictionary of syncable properties for cross-project synchronization.",
          "description": "Get dictionary of syncable properties for cross-project synchronization.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values. Keys are property names, values are the property values. ",
          "raises": [],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> env = list(envOps.GetAll())[0]\n            >>> props = envOps.GetSyncableProperties(env)\n            >>> print(props.keys())\n            dict_keys(['Name', 'Description', 'StringRepresentation'])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(env_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a phonological environment.",
          "description": "Set the name of a phonological environment.\n",
          "parameters": [
            {
              "name": "env_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If env_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> env = list(envOps.GetAll())[0]\n            >>> envOps.SetName(env, \"Word Initial Position\")\n\n            >>> # Use standard terminology\n            >>> envOps.SetName(env, \"Intervocalic\")  # Better than custom names\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetStringRepresentation",
          "signature": "SetStringRepresentation(env_or_hvo, notation, wsHandle=None)",
          "summary": "Set the string representation (notation) of a phonological environment.",
          "description": "Set the string representation (notation) of a phonological environment.\n",
          "parameters": [
            {
              "name": "env_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO."
            },
            {
              "name": "notation",
              "type": "str",
              "default": null,
              "description": "The environment representation (e.g., \"V_V\", \"#_\", \"_#\")."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If env_or_hvo or notation is None."
          ],
          "example": "            >>> envOps = EnvironmentOperations(project)\n            >>> # Create and define common environments\n            >>> word_initial = envOps.Create(\"Word Initial\")\n            >>> envOps.SetStringRepresentation(word_initial, \"#_\")\n\n            >>> word_final = envOps.Create(\"Word Final\")\n            >>> envOps.SetStringRepresentation(word_final, \"_#\")\n\n            >>> between_vowels = envOps.Create(\"Between Vowels\")\n            >>> envOps.SetStringRepresentation(between_vowels, \"V_V\")\n\n            >>> # Complex environment: after nasal, before stop\n            >>> env = envOps.Create(\"Nasal-Stop Cluster\")\n            >>> envOps.SetStringRepresentation(env, \"N_P\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize EnvironmentOperations with a FLExProject instance.",
          "description": "Initialize EnvironmentOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "grammar",
        "operations"
      ]
    },
    "GramCatOperations": {
      "name": "GramCatOperations",
      "type": "class",
      "namespace": "FlexLibs2.Grammar.GramCatOperations",
      "source_file": "Grammar/GramCatOperations",
      "category": "grammar",
      "summary": "This class provides operations for managing Grammatical Categories in a\nFieldWorks project.",
      "description": "This class provides operations for managing Grammatical Categories in a\nFieldWorks project.\n\nGrammatical categories are used to classify and describe grammatical\nproperties such as person, number, gender, tense, aspect, mood, case,\nand other morphosyntactic features used in linguistic analysis.\n\nUsage::\n\nfrom flexlibs import FLExProject, GramCatOperations\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\ngramCatOps = GramCatOperations(project)\n\n# Get all grammatical categories\nfor cat in gramCatOps.GetAll():\nprint(gramCatOps.GetName(cat))\n\n# Create a new category\nperson = gramCatOps.Create(\"person\")\n\n# Create subcategories\nfirst = gramCatOps.Create(\"1st person\", parent=person)\nsecond = gramCatOps.Create(\"2nd person\", parent=person)\nthird = gramCatOps.Create(\"3rd person\", parent=person)\n\n# Navigate hierarchy\nparent = gramCatOps.GetParent(first)\nsubcats = gramCatOps.GetSubcategories(person)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two grammatical categories and return detailed differences.",
          "description": "Compare two grammatical categories and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First category to compare (from source project)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second category to compare (from target project)."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional GramCatOperations instance for item1's project. Defaults to self."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional GramCatOperations instance for item2's project. Defaults to self."
            }
          ],
          "returns": "tuple: (is_different, differences) where: - is_different (bool): True if items differ - differences (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> cat1 = project1_gramCatOps.Find(\"person\")\n            >>> cat2 = project2_gramCatOps.Find(\"person\")\n            >>> is_diff, diffs = project1_gramCatOps.CompareTo(\n            ...     cat1, cat2,\n            ...     ops1=project1_gramCatOps,\n            ...     ops2=project2_gramCatOps\n            ... )\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} -> {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, parent=None)",
          "summary": "Create a new grammatical category.",
          "description": "Create a new grammatical category.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the category (e.g., \"person\", \"1st person\")."
            },
            {
              "name": "parent",
              "type": "ICmPossibility or int, optional",
              "default": null,
              "description": "Optional parent category for creating subcategories. Can be an ICmPossibility object or an HVO. Defaults to None (creates top-level category)."
            }
          ],
          "returns": "ICmPossibility: The newly created grammatical category object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty, or if a category with this",
            "name already exists."
          ],
          "example": "            >>> gramCatOps = GramCatOperations(project)\n            >>> # Create top-level category\n            >>> person = gramCatOps.Create(\"person\")\n            >>> print(gramCatOps.GetName(person))\n            person\n\n            >>> # Create subcategories\n            >>> first = gramCatOps.Create(\"1st person\", parent=person)\n            >>> second = gramCatOps.Create(\"2nd person\", parent=person)\n            >>> third = gramCatOps.Create(\"3rd person\", parent=person)\n\n            >>> # Create nested hierarchy\n            >>> number = gramCatOps.Create(\"number\")\n            >>> singular = gramCatOps.Create(\"singular\", parent=number)\n            >>> plural = gramCatOps.Create(\"plural\", parent=number)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(cat_or_hvo)",
          "summary": "Delete a grammatical category.",
          "description": "Delete a grammatical category.\n",
          "parameters": [
            {
              "name": "cat_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If cat_or_hvo is None.",
            "FP_ParameterError: If the category is in use and cannot be deleted."
          ],
          "example": "            >>> gramCatOps = GramCatOperations(project)\n            >>> obsolete = gramCatOps.Create(\"obsolete_feature\")\n            >>> # Later, if not needed...\n            >>> gramCatOps.Delete(obsolete)\n\n        Warning:\n            - Deleting a category that is in use may raise an error from FLEx\n            - Will also delete all subcategories recursively\n            - Deletion is permanent and cannot be undone\n            - Morphological rules or entries using this may be affected\n\n        See Also:\n            Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a grammatical category, creating a new copy with a new GUID.",
          "description": "Duplicate a grammatical category, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source category. If False, insert at end of parent's possibilities list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, recursively duplicate all subcategories. If False (default), only duplicate the category itself."
            }
          ],
          "returns": "ICmPossibility: The newly created duplicate category with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> gramCatOps = GramCatOperations(project)\n            >>> person = gramCatOps.Create(\"person\")\n            >>> # Shallow copy (no subcategories)\n            >>> person_copy = gramCatOps.Duplicate(person)\n            >>> print(gramCatOps.GetName(person_copy))\n            person\n\n            >>> # Deep copy (includes all subcategories)\n            >>> number = gramCatOps.Create(\"number\")\n            >>> singular = gramCatOps.Create(\"singular\", parent=number)\n            >>> plural = gramCatOps.Create(\"plural\", parent=number)\n            >>> number_copy = gramCatOps.Duplicate(number, deep=True)\n            >>> orig_subs = gramCatOps.GetSubcategories(number)\n            >>> copy_subs = gramCatOps.GetSubcategories(number_copy)\n            >>> print(f\"Original has {len(orig_subs)} subcategories\")\n            >>> print(f\"Copy has {len(copy_subs)} subcategories\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all grammatical categories in the project.",
          "description": "Get all grammatical categories in the project.\n",
          "parameters": [],
          "returns": "ICmPossibility: Each top-level grammatical category object in the project's feature system. ",
          "raises": [],
          "example": "            >>> gramCatOps = GramCatOperations(project)\n            >>> for cat in gramCatOps.GetAll():\n            ...     name = gramCatOps.GetName(cat)\n            ...     subcats = gramCatOps.GetSubcategories(cat)\n            ...     print(f\"{name}: {len(subcats)} subcategories\")\n            person: 3 subcategories\n            number: 2 subcategories\n            gender: 3 subcategories\n            tense: 5 subcategories\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(cat_or_hvo, wsHandle=None)",
          "summary": "Get the name of a grammatical category.",
          "description": "Get the name of a grammatical category.\n",
          "parameters": [
            {
              "name": "cat_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The category name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If cat_or_hvo is None."
          ],
          "example": "            >>> gramCatOps = GramCatOperations(project)\n            >>> person = gramCatOps.Create(\"person\")\n            >>> name = gramCatOps.GetName(person)\n            >>> print(name)\n            person\n\n            >>> # Get name in a specific writing system\n            >>> vern_name = gramCatOps.GetName(person, project.WSHandle('en'))\n\n            >>> # List all categories\n            >>> for cat in gramCatOps.GetAll():\n            ...     print(gramCatOps.GetName(cat))\n\n        See Also:\n            SetName, GetSubcategories",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParent",
          "signature": "GetParent(cat_or_hvo)",
          "summary": "Get the parent category of a grammatical category.",
          "description": "Get the parent category of a grammatical category.\n",
          "parameters": [
            {
              "name": "cat_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "ICmPossibility or None: Parent category, or None if top-level. ",
          "raises": [
            "FP_NullParameterError: If cat_or_hvo is None."
          ],
          "example": "            >>> gramCatOps = GramCatOperations(project)\n            >>> person = gramCatOps.Create(\"person\")\n            >>> first = gramCatOps.Create(\"1st person\", parent=person)\n            >>>\n            >>> parent = gramCatOps.GetParent(first)\n            >>> print(gramCatOps.GetName(parent))\n            person\n            >>>\n            >>> # Top-level categories have no parent\n            >>> print(gramCatOps.GetParent(person))\n            None\n\n            >>> # Traverse up the hierarchy\n            >>> cat = first\n            >>> while cat:\n            ...     print(gramCatOps.GetName(cat))\n            ...     cat = gramCatOps.GetParent(cat)\n            1st person\n            person\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubcategories",
          "signature": "GetSubcategories(cat_or_hvo)",
          "summary": "Get all subcategories of a grammatical category.",
          "description": "Get all subcategories of a grammatical category.\n",
          "parameters": [
            {
              "name": "cat_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "list: List of ICmPossibility subcategory objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If cat_or_hvo is None."
          ],
          "example": "            >>> gramCatOps = GramCatOperations(project)\n            >>> person = gramCatOps.Create(\"person\")\n            >>> first = gramCatOps.Create(\"1st person\", parent=person)\n            >>> second = gramCatOps.Create(\"2nd person\", parent=person)\n            >>> third = gramCatOps.Create(\"3rd person\", parent=person)\n            >>>\n            >>> subcats = gramCatOps.GetSubcategories(person)\n            >>> for subcat in subcats:\n            ...     print(gramCatOps.GetName(subcat))\n            1st person\n            2nd person\n            3rd person\n\n            >>> # Check if category has subcategories\n            >>> if gramCatOps.GetSubcategories(cat):\n            ...     print(\"This category has subcategories\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get dictionary of syncable properties for cross-project synchronization.",
          "description": "Get dictionary of syncable properties for cross-project synchronization.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmPossibility (grammatical category) object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values. Keys are property names, values are the property values. ",
          "raises": [],
          "example": "            >>> gramCatOps = GramCatOperations(project)\n            >>> cat = list(gramCatOps.GetAll())[0]\n            >>> props = gramCatOps.GetSyncableProperties(cat)\n            >>> print(props.keys())\n            dict_keys(['Name', 'Abbreviation', 'Description'])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(cat_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a grammatical category.",
          "description": "Set the name of a grammatical category.\n",
          "parameters": [
            {
              "name": "cat_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If cat_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> gramCatOps = GramCatOperations(project)\n            >>> cat = gramCatOps.Create(\"prson\")  # typo\n            >>> gramCatOps.SetName(cat, \"person\")  # fix it\n\n            >>> # Set name in vernacular WS\n            >>> gramCatOps.SetName(cat, \"persona\", project.WSHandle('es'))\n\n        See Also:\n            GetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize GramCatOperations with a FLExProject instance.",
          "description": "Initialize GramCatOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "grammar",
        "operations"
      ]
    },
    "InflectionFeatureOperations": {
      "name": "InflectionFeatureOperations",
      "type": "class",
      "namespace": "FlexLibs2.Grammar.InflectionFeatureOperations",
      "source_file": "Grammar/InflectionFeatureOperations",
      "category": "grammar",
      "summary": "This class provides operations for managing inflection classes, feature\nstructures, and features in a FieldWorks project.",
      "description": "This class provides operations for managing inflection classes, feature\nstructures, and features in a FieldWorks project.\n\nInflection classes group lexical items that inflect similarly (e.g., Latin\nnoun declensions, Spanish verb conjugations). Feature structures and features\nrepresent grammatical properties like person, number, gender, tense, aspect,\nmood, etc.\n\nUsage::\n\nfrom flexlibs import FLExProject, InflectionFeatureOperations\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\ninflOps = InflectionFeatureOperations(project)\n\n# Get all inflection classes\nfor ic in inflOps.InflectionClassGetAll():\nname = inflOps.InflectionClassGetName(ic)\nprint(f\"Inflection Class: {name}\")\n\n# Create a new inflection class\nfirst_decl = inflOps.InflectionClassCreate(\"First Declension\")\n\n# Work with features\nfor feature in inflOps.FeatureGetAll():\nprint(f\"Feature: {feature}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two inflection classes and return detailed differences.",
          "description": "Compare two inflection classes and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First inflection class to compare (from source project)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second inflection class to compare (from target project)."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional InflectionFeatureOperations instance for item1's project. Defaults to self."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional InflectionFeatureOperations instance for item2's project. Defaults to self."
            }
          ],
          "returns": "tuple: (is_different, differences) where: - is_different (bool): True if items differ - differences (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> ic1 = project1_inflOps.InflectionClassFind(\"First Declension\")\n            >>> ic2 = project2_inflOps.InflectionClassFind(\"First Declension\")\n            >>> is_diff, diffs = project1_inflOps.CompareTo(\n            ...     ic1, ic2,\n            ...     ops1=project1_inflOps,\n            ...     ops2=project2_inflOps\n            ... )\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} -> {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FeatureCreate",
          "signature": "FeatureCreate(name, type)",
          "summary": "Create a new feature definition.",
          "description": "Create a new feature definition.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the feature (e.g., \"person\", \"number\", \"tense\")."
            },
            {
              "name": "type",
              "type": "str",
              "default": null,
              "description": "The type of feature (e.g., \"complex\" for structured features)."
            }
          ],
          "returns": "IFsFeatureDefn: The newly created feature definition object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name or type is None.",
            "FP_ParameterError: If name or type is empty, or if a feature with",
            "this name already exists."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> person = inflOps.FeatureCreate(\"person\", \"complex\")\n            >>> number = inflOps.FeatureCreate(\"number\", \"complex\")\n            >>> tense = inflOps.FeatureCreate(\"tense\", \"complex\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FeatureDelete",
          "signature": "FeatureDelete(feature_or_hvo)",
          "summary": "Delete a feature definition.",
          "description": "Delete a feature definition.\n",
          "parameters": [
            {
              "name": "feature_or_hvo",
              "type": "",
              "default": null,
              "description": "The IFsFeatureDefn object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If feature_or_hvo is None."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> # Find and delete a test feature\n            >>> for feature in inflOps.FeatureGetAll():\n            ...     ws = project.project.DefaultAnalWs\n            ...     name = ITsString(feature.Name.get_String(ws)).Text\n            ...     if name == \"test_feature\":\n            ...         inflOps.FeatureDelete(feature)\n            ...         break\n\n        Warning:\n            - Cannot delete if used in feature structures\n            - Cannot delete if referenced by entries or morphemes\n            - Check dependencies before deletion\n            - Deletion is permanent and cannot be undone\n\n        See Also:\n            FeatureCreate, FeatureGetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FeatureGetAll",
          "signature": "FeatureGetAll()",
          "summary": "Get all feature definitions in the project.",
          "description": "Get all feature definitions in the project.\n",
          "parameters": [],
          "returns": "IFsFeatureDefn: Each feature definition object in the project. ",
          "raises": [],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> for feature in inflOps.FeatureGetAll():\n            ...     print(f\"Feature: {feature}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FeatureGetValues",
          "signature": "FeatureGetValues(feature_or_hvo)",
          "summary": "Get all possible values for a feature.",
          "description": "Get all possible values for a feature.\n",
          "parameters": [
            {
              "name": "feature_or_hvo",
              "type": "",
              "default": null,
              "description": "The IFsFeatureDefn object or HVO."
            }
          ],
          "returns": "list: List of feature value objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If feature_or_hvo is None."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> person = inflOps.FeatureCreate(\"person\", \"complex\")\n            >>> # After adding values 1st, 2nd, 3rd...\n            >>> values = inflOps.FeatureGetValues(person)\n            >>> print(f\"Person has {len(values)} values\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FeatureStructureCreate",
          "signature": "FeatureStructureCreate()",
          "summary": "Create a new feature structure.",
          "description": "Create a new feature structure.\n",
          "parameters": [],
          "returns": "IFsFeatStruc: The newly created feature structure object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> fs = inflOps.FeatureStructureCreate()\n            >>> print(f\"Created feature structure: {fs.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FeatureStructureDelete",
          "signature": "FeatureStructureDelete(fs_or_hvo)",
          "summary": "Delete a feature structure.",
          "description": "Delete a feature structure.\n",
          "parameters": [
            {
              "name": "fs_or_hvo",
              "type": "",
              "default": null,
              "description": "The IFsFeatStruc object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If fs_or_hvo is None."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> fs = inflOps.FeatureStructureCreate()\n            >>> inflOps.FeatureStructureDelete(fs)\n\n        Warning:\n            - Cannot delete if referenced by entries, morphemes, or rules\n            - Check dependencies before deletion\n            - Deletion is permanent and cannot be undone\n\n        See Also:\n            FeatureStructureCreate, FeatureStructureGetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FeatureStructureGetAll",
          "signature": "FeatureStructureGetAll()",
          "summary": "Get all feature structures in the project.",
          "description": "Get all feature structures in the project.\n",
          "parameters": [],
          "returns": "IFsFeatStruc: Each feature structure object in the project. ",
          "raises": [],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> for fs in inflOps.FeatureStructureGetAll():\n            ...     print(f\"Feature Structure HVO: {fs.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFeatureConstraints",
          "signature": "GetFeatureConstraints(feature_system_or_hvo)",
          "summary": "Get all feature constraints in the feature system (READ-ONLY).",
          "description": "Get all feature constraints in the feature system (READ-ONLY).\n",
          "parameters": [
            {
              "name": "feature_system_or_hvo",
              "type": "",
              "default": null,
              "description": "The feature system object or HVO."
            }
          ],
          "returns": "list: List of feature constraint objects. ",
          "raises": [
            "FP_NullParameterError: If feature_system_or_hvo is None."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> # Get the feature system\n            >>> feature_system = project.lp.MsFeatureSystemOA\n            >>> if feature_system:\n            ...     constraints = inflOps.GetFeatureConstraints(feature_system)\n            ...     print(f\"Feature system has {len(constraints)} constraints\")\n            ...     for constraint in constraints:\n            ...         print(f\"  - Constraint HVO: {constraint.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFeatures",
          "signature": "GetFeatures(feature_system_or_hvo)",
          "summary": "Get all features in the feature system (READ-ONLY).",
          "description": "Get all features in the feature system (READ-ONLY).\n",
          "parameters": [
            {
              "name": "feature_system_or_hvo",
              "type": "",
              "default": null,
              "description": "The feature system object or HVO."
            }
          ],
          "returns": "list: List of feature definition objects (IFsFeatDefn). ",
          "raises": [
            "FP_NullParameterError: If feature_system_or_hvo is None."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> # Get the feature system\n            >>> feature_system = project.lp.MsFeatureSystemOA\n            >>> if feature_system:\n            ...     features = inflOps.GetFeatures(feature_system)\n            ...     print(f\"Feature system has {len(features)} features\")\n            ...     for feature in features:\n            ...         wsHandle = project.project.DefaultAnalWs\n            ...         name = ITsString(feature.Name.get_String(wsHandle)).Text\n            ...         print(f\"  - {name}\")\n            Feature system has 3 features\n              - person\n              - number\n              - tense\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get dictionary of syncable properties for cross-project synchronization.",
          "description": "Get dictionary of syncable properties for cross-project synchronization.\n\nThis method works with inflection classes (IMoInflClass). For features and\nfeature structures, use separate sync methods if needed.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IMoInflClass (inflection class) object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values. Keys are property names, values are the property values. ",
          "raises": [],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> ic = list(inflOps.InflectionClassGetAll())[0]\n            >>> props = inflOps.GetSyncableProperties(ic)\n            >>> print(props.keys())\n            dict_keys(['Name', 'Abbreviation', 'Description'])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTypes",
          "signature": "GetTypes(feature_system_or_hvo)",
          "summary": "Get the feature types collection from a feature system (READ-ONLY).",
          "description": "Get the feature types collection from a feature system (READ-ONLY).\n\nThis is a getter-only method that returns the collection of feature types\ndefined in the morphosyntactic feature system. Feature types categorize\nfeatures into groups (e.g., inflectional features, agreement features).\n",
          "parameters": [
            {
              "name": "feature_system_or_hvo",
              "type": "",
              "default": null,
              "description": "The IFsFeatureSystem object or HVO, or None to use the project's default feature system."
            }
          ],
          "returns": "list: List of feature type objects (IFsFeatDefn) from the TypesOC collection, or empty list if none defined. ",
          "raises": [
            "FP_NullParameterError: If feature_system_or_hvo is explicitly None",
            "and no default feature system exists."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> # Get types from default feature system\n            >>> types = inflOps.GetTypes(None)\n            >>> for ftype in types:\n            ...     print(f\"Feature type: {ftype}\")\n\n            >>> # Get types from specific feature system\n            >>> fs = project.lp.MsFeatureSystemOA\n            >>> types = inflOps.GetTypes(fs)\n            >>> print(f\"Found {len(types)} feature types\")\n\n            >>> # Iterate and display type names\n            >>> for ftype in types:\n            ...     ws = project.project.DefaultAnalWs\n            ...     name = ITsString(ftype.Name.get_String(ws)).Text\n            ...     print(f\"Type: {name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "InflectionClassCreate",
          "signature": "InflectionClassCreate(name)",
          "summary": "Create a new inflection class.",
          "description": "Create a new inflection class.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the inflection class (e.g., \"First Declension\")."
            }
          ],
          "returns": "IMoInflClass: The newly created inflection class object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty or if a class with this name",
            "already exists."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> first_decl = inflOps.InflectionClassCreate(\"First Declension\")\n            >>> print(inflOps.InflectionClassGetName(first_decl))\n            First Declension\n\n            >>> # Create Spanish verb conjugation classes\n            >>> ar_verbs = inflOps.InflectionClassCreate(\"AR Verbs\")\n            >>> er_verbs = inflOps.InflectionClassCreate(\"ER Verbs\")\n            >>> ir_verbs = inflOps.InflectionClassCreate(\"IR Verbs\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "InflectionClassDelete",
          "signature": "InflectionClassDelete(ic_or_hvo)",
          "summary": "Delete an inflection class.",
          "description": "Delete an inflection class.\n",
          "parameters": [
            {
              "name": "ic_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoInflClass object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If ic_or_hvo is None.",
            "FP_ParameterError: If the class is in use and cannot be deleted."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> # Find and delete an obsolete class\n            >>> for ic in inflOps.InflectionClassGetAll():\n            ...     if inflOps.InflectionClassGetName(ic) == \"Obsolete\":\n            ...         inflOps.InflectionClassDelete(ic)\n            ...         break\n\n        Warning:\n            - Deleting a class that is in use may raise an error from FLEx\n            - Entries using this class should be updated first\n            - Deletion is permanent and cannot be undone\n            - Check for references before deletion\n\n        See Also:\n            InflectionClassCreate, InflectionClassGetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "InflectionClassGetAll",
          "signature": "InflectionClassGetAll()",
          "summary": "Get all inflection classes in the project.",
          "description": "Get all inflection classes in the project.\n",
          "parameters": [],
          "returns": "IMoInflClass: Each inflection class object in the project. ",
          "raises": [],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> for ic in inflOps.InflectionClassGetAll():\n            ...     name = inflOps.InflectionClassGetName(ic)\n            ...     print(f\"Class: {name}\")\n            Class: First Declension\n            Class: Second Declension\n            Class: Irregular Verb\n            Class: Regular Verb\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "InflectionClassGetName",
          "signature": "InflectionClassGetName(ic_or_hvo, wsHandle=None)",
          "summary": "Get the name of an inflection class.",
          "description": "Get the name of an inflection class.\n",
          "parameters": [
            {
              "name": "ic_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoInflClass object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The inflection class name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If ic_or_hvo is None."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> for ic in inflOps.InflectionClassGetAll():\n            ...     name = inflOps.InflectionClassGetName(ic)\n            ...     print(f\"Inflection Class: {name}\")\n            Inflection Class: First Declension\n            Inflection Class: Second Declension\n\n        See Also:\n            InflectionClassSetName, InflectionClassGetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "InflectionClassSetName",
          "signature": "InflectionClassSetName(ic_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of an inflection class.",
          "description": "Set the name of an inflection class.\n",
          "parameters": [
            {
              "name": "ic_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoInflClass object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If ic_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> inflOps = InflectionFeatureOperations(project)\n            >>> ic = inflOps.InflectionClassCreate(\"1st Decl\")\n            >>> inflOps.InflectionClassSetName(ic, \"First Declension\")\n            >>> print(inflOps.InflectionClassGetName(ic))\n            First Declension\n\n        See Also:\n            InflectionClassGetName, InflectionClassCreate",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize InflectionFeatureOperations with a FLExProject instance.",
          "description": "Initialize InflectionFeatureOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "grammar",
        "operations"
      ]
    },
    "MorphRuleOperations": {
      "name": "MorphRuleOperations",
      "type": "class",
      "namespace": "FlexLibs2.Grammar.MorphRuleOperations",
      "source_file": "Grammar/MorphRuleOperations",
      "category": "grammar",
      "summary": "This class provides operations for managing morphological rules in a\nFieldWorks project.",
      "description": "This class provides operations for managing morphological rules in a\nFieldWorks project.\n\nMorphological rules define systematic patterns of word formation, including\naffixation processes, templates, and other morphological transformations\nused in the language.\n\nUsage::\n\nfrom flexlibs import FLExProject, MorphRuleOperations\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\nruleOps = MorphRuleOperations(project)\n\n# Get all morphological rules\nfor rule in ruleOps.GetAll():\nname = ruleOps.GetName(rule)\ndescription = ruleOps.GetDescription(rule)\nactive = ruleOps.IsActive(rule)\nprint(f\"{name}: {description} (active={active})\")\n\n# Create a new rule\nrule = ruleOps.Create(\"Plural Formation\", \"Adds plural suffix\")\nruleOps.SetActive(rule, True)\n\n# Update rule\nruleOps.SetDescription(rule, \"Forms plural nouns by adding -s\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two morphological rules and return detailed differences.",
          "description": "Compare two morphological rules and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First rule to compare (from source project)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second rule to compare (from target project)."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional MorphRuleOperations instance for item1's project. Defaults to self."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional MorphRuleOperations instance for item2's project. Defaults to self."
            }
          ],
          "returns": "tuple: (is_different, differences) where: - is_different (bool): True if items differ - differences (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> rule1 = project1_ruleOps.Find(\"Plural Formation\")\n            >>> rule2 = project2_ruleOps.Find(\"Plural Formation\")\n            >>> is_diff, diffs = project1_ruleOps.CompareTo(\n            ...     rule1, rule2,\n            ...     ops1=project1_ruleOps,\n            ...     ops2=project2_ruleOps\n            ... )\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} -> {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, description=None)",
          "summary": "Create a new morphological rule.",
          "description": "Create a new morphological rule.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the rule (e.g., \"Plural Formation\")."
            },
            {
              "name": "description",
              "type": "str, optional",
              "default": null,
              "description": "Optional description of what this rule does. Defaults to None."
            }
          ],
          "returns": "IMoMorphRule: The newly created rule object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> plural = ruleOps.Create(\"Plural Formation\", \"Adds -s suffix\")\n            >>> print(ruleOps.GetName(plural))\n            Plural Formation\n\n            >>> past = ruleOps.Create(\"Past Tense\")\n            >>> ruleOps.SetDescription(past, \"Forms past tense verbs\")\n            >>> ruleOps.SetActive(past, True)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(rule_or_hvo)",
          "summary": "Delete a morphological rule.",
          "description": "Delete a morphological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> obsolete = ruleOps.Create(\"Obsolete Rule\")\n            >>> # ... realize it's not needed\n            >>> ruleOps.Delete(obsolete)\n\n        Warning:\n            - Deleting a rule that is in use may cause errors\n            - This includes rules referenced by:\n              - Morphological processes\n              - Allomorph conditions\n              - Other rule definitions\n            - Deletion is permanent and cannot be undone\n            - Consider deactivating instead of deleting\n\n        See Also:\n            Create, SetActive, GetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a morphological rule, creating a new copy with a new GUID.",
          "description": "Duplicate a morphological rule, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source rule. If False, insert at end of rules list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "Reserved for future use (rules have complex owned objects)."
            }
          ],
          "returns": "IMoMorphRule: The newly created duplicate rule with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> plural = ruleOps.Create(\"Plural Formation\", \"Adds -s suffix\")\n            >>> # Duplicate the rule\n            >>> copy = ruleOps.Duplicate(plural)\n            >>> print(ruleOps.GetName(copy))\n            Plural Formation\n\n            >>> # Modify the duplicate\n            >>> ruleOps.SetName(copy, \"Plural Formation (Variant)\")\n            >>> ruleOps.SetActive(copy, True)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all morphological rules in the project.",
          "description": "Get all morphological rules in the project.\n",
          "parameters": [],
          "returns": "IMoMorphRule: Each morphological rule object in the project. ",
          "raises": [],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> for rule in ruleOps.GetAll():\n            ...     name = ruleOps.GetName(rule)\n            ...     active = ruleOps.IsActive(rule)\n            ...     status = \"active\" if active else \"inactive\"\n            ...     print(f\"{name} ({status})\")\n            Plural Formation (active)\n            Past Tense (active)\n            Verb Template (inactive)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(rule_or_hvo, wsHandle=None)",
          "summary": "Get the description of a morphological rule.",
          "description": "Get the description of a morphological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The rule description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> for rule in ruleOps.GetAll():\n            ...     name = ruleOps.GetName(rule)\n            ...     desc = ruleOps.GetDescription(rule)\n            ...     print(f\"{name}: {desc}\")\n            Plural Formation: Adds -s suffix to form plural nouns\n            Past Tense: Adds -ed suffix to form past tense verbs\n\n            >>> # Get description in a specific writing system\n            >>> rule = list(ruleOps.GetAll())[0]\n            >>> desc = ruleOps.GetDescription(rule, project.WSHandle('en'))\n\n        See Also:\n            SetDescription, GetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(rule_or_hvo, wsHandle=None)",
          "summary": "Get the name of a morphological rule.",
          "description": "Get the name of a morphological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The rule name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> for rule in ruleOps.GetAll():\n            ...     name = ruleOps.GetName(rule)\n            ...     print(name)\n            Plural Formation\n            Past Tense\n            Progressive Aspect\n\n            >>> # Get name in a specific writing system\n            >>> rule = list(ruleOps.GetAll())[0]\n            >>> name = ruleOps.GetName(rule, project.WSHandle('en'))\n\n        See Also:\n            SetName, GetDescription",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetStratum",
          "signature": "GetStratum(rule_or_hvo)",
          "summary": "Get the stratum of a morphological rule.",
          "description": "Get the stratum of a morphological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO."
            }
          ],
          "returns": "IMoStratum or None: The stratum object if set, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> rule = list(ruleOps.GetAll())[0]\n            >>> stratum = ruleOps.GetStratum(rule)\n            >>> if stratum:\n            ...     print(f\"Rule uses stratum: {stratum.Name.BestAnalysisAlternative.Text}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get dictionary of syncable properties for cross-project synchronization.",
          "description": "Get dictionary of syncable properties for cross-project synchronization.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values. Keys are property names, values are the property values. ",
          "raises": [],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> rule = list(ruleOps.GetAll())[0]\n            >>> props = ruleOps.GetSyncableProperties(rule)\n            >>> print(props.keys())\n            dict_keys(['Name', 'Description', 'Active', 'StratumGuid'])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsActive",
          "signature": "IsActive(rule_or_hvo)",
          "summary": "Check if a morphological rule is active.",
          "description": "Check if a morphological rule is active.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO."
            }
          ],
          "returns": "bool: True if the rule is active, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> for rule in ruleOps.GetAll():\n            ...     name = ruleOps.GetName(rule)\n            ...     active = ruleOps.IsActive(rule)\n            ...     status = \"active\" if active else \"inactive\"\n            ...     print(f\"{name}: {status}\")\n            Plural Formation: active\n            Obsolete Rule: inactive\n\n            >>> # Check before applying rule\n            >>> rule = list(ruleOps.GetAll())[0]\n            >>> if ruleOps.IsActive(rule):\n            ...     print(f\"{ruleOps.GetName(rule)} will be applied\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetActive",
          "signature": "SetActive(rule_or_hvo, active)",
          "summary": "Set the active state of a morphological rule.",
          "description": "Set the active state of a morphological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO."
            },
            {
              "name": "active",
              "type": "bool",
              "default": null,
              "description": "True to activate the rule, False to deactivate."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo or active is None."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> rule = list(ruleOps.GetAll())[0]\n\n            >>> # Activate a rule\n            >>> ruleOps.SetActive(rule, True)\n            >>> print(f\"Active: {ruleOps.IsActive(rule)}\")\n            Active: True\n\n            >>> # Deactivate obsolete rules\n            >>> for rule in ruleOps.GetAll():\n            ...     name = ruleOps.GetName(rule)\n            ...     if \"obsolete\" in name.lower():\n            ...         ruleOps.SetActive(rule, False)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(rule_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of a morphological rule.",
          "description": "Set the description of a morphological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo or description is None."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> rule = list(ruleOps.GetAll())[0]\n            >>> ruleOps.SetDescription(rule, \"Adds -s suffix to form plural nouns\")\n\n            >>> # Provide detailed descriptions\n            >>> desc = \"Forms past tense by adding -ed to regular verb stems\"\n            >>> ruleOps.SetDescription(rule, desc)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(rule_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a morphological rule.",
          "description": "Set the name of a morphological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> rule = list(ruleOps.GetAll())[0]\n            >>> ruleOps.SetName(rule, \"Noun Pluralization\")\n\n            >>> # Use descriptive names\n            >>> ruleOps.SetName(rule, \"Plural Formation (Regular Nouns)\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetStratum",
          "signature": "SetStratum(rule_or_hvo, stratum)",
          "summary": "Set the stratum of a morphological rule.",
          "description": "Set the stratum of a morphological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoMorphRule object or HVO."
            },
            {
              "name": "stratum",
              "type": "",
              "default": null,
              "description": "The IMoStratum object, HVO, or None to clear."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> ruleOps = MorphRuleOperations(project)\n            >>> rule = list(ruleOps.GetAll())[0]\n\n            >>> # Create or get a stratum\n            >>> morph_data = project.lp.MorphologicalDataOA\n            >>> if morph_data.StrataOS.Count > 0:\n            ...     stratum = morph_data.StrataOS[0]\n            ...     ruleOps.SetStratum(rule, stratum)\n\n            >>> # Clear stratum assignment\n            >>> ruleOps.SetStratum(rule, None)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize MorphRuleOperations with a FLExProject instance.",
          "description": "Initialize MorphRuleOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ],
      "tags": [
        "grammar",
        "operations"
      ]
    },
    "NaturalClassOperations": {
      "name": "NaturalClassOperations",
      "type": "class",
      "namespace": "FlexLibs2.Grammar.NaturalClassOperations",
      "source_file": "Grammar/NaturalClassOperations",
      "category": "grammar",
      "summary": "This class provides operations for managing natural classes in a\nFieldWorks project.",
      "description": "This class provides operations for managing natural classes in a\nFieldWorks project.\n\nNatural classes are groups of phonemes that share common phonological\nfeatures and pattern together in phonological rules. For example,\nvoiceless stops {/p/, /t/, /k/} or vowels {/a/, /e/, /i/, /o/, /u/}.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all natural classes\nfor nc in project.NaturalClasses.GetAll():\nname = project.NaturalClasses.GetName(nc)\nabbr = project.NaturalClasses.GetAbbreviation(nc)\nphonemes = project.NaturalClasses.GetPhonemes(nc)\nprint(f\"{name} ({abbr}): {len(phonemes)} phonemes\")\n\n# Create a new natural class\nstops = project.NaturalClasses.Create(\"Voiceless Stops\", \"VLS\")\n\n# Add phonemes to the class\np_phoneme = project.Phonemes.Find(\"/p/\")\nif p_phoneme:\nproject.NaturalClasses.AddPhoneme(stops, p_phoneme)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddPhoneme",
          "signature": "AddPhoneme(nc_or_hvo, phoneme_or_hvo)",
          "summary": "Add a phoneme to a natural class.",
          "description": "Add a phoneme to a natural class.\n",
          "parameters": [
            {
              "name": "nc_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhNaturalClass object or HVO."
            },
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO to add."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If nc_or_hvo or phoneme_or_hvo is None.",
            "FP_ParameterError: If the natural class is feature-based (cannot add segments)."
          ],
          "example": "            >>> # Create voiceless stops class\n            >>> nc = project.NaturalClasses.Create(\"Voiceless Stops\", \"VLS\")\n            >>> p = project.Phonemes.Find(\"/p/\")\n            >>> t = project.Phonemes.Find(\"/t/\")\n            >>> k = project.Phonemes.Find(\"/k/\")\n            >>> if p:\n            ...     project.NaturalClasses.AddPhoneme(nc, p)\n            >>> if t:\n            ...     project.NaturalClasses.AddPhoneme(nc, t)\n            >>> if k:\n            ...     project.NaturalClasses.AddPhoneme(nc, k)\n\n            >>> # Create vowel class\n            >>> vowels = project.NaturalClasses.Create(\"Vowels\", \"V\")\n            >>> for repr in [\"/a/\", \"/e/\", \"/i/\", \"/o/\", \"/u/\"]:\n            ...     phoneme = project.Phonemes.Find(repr)\n            ...     if phoneme:\n            ...         project.NaturalClasses.AddPhoneme(vowels, phoneme)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two natural classes and return detailed differences.",
          "description": "Compare two natural classes and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First natural class to compare (from source project)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second natural class to compare (from target project)."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional NaturalClassOperations instance for item1's project. Defaults to self."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional NaturalClassOperations instance for item2's project. Defaults to self."
            }
          ],
          "returns": "tuple: (is_different, differences) where: - is_different (bool): True if items differ - differences (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> nc1 = project1_ncOps.Find(\"Voiceless Stops\")\n            >>> nc2 = project2_ncOps.Find(\"Voiceless Stops\")\n            >>> is_diff, diffs = project1_ncOps.CompareTo(\n            ...     nc1, nc2,\n            ...     ops1=project1_ncOps,\n            ...     ops2=project2_ncOps\n            ... )\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} -> {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, abbreviation=None)",
          "summary": "Create a new natural class.",
          "description": "Create a new natural class.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the natural class (e.g., \"Voiceless Stops\")."
            },
            {
              "name": "abbreviation",
              "type": "str, optional",
              "default": null,
              "description": "Short abbreviation (e.g., \"VLS\", \"V\", \"C\"). If None, defaults to empty string."
            }
          ],
          "returns": "IPhNCSegments: The newly created natural class object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> # Create basic consonant classes\n            >>> stops = project.NaturalClasses.Create(\"Stops\", \"P\")\n            >>> fricatives = project.NaturalClasses.Create(\"Fricatives\", \"F\")\n            >>> nasals = project.NaturalClasses.Create(\"Nasals\", \"N\")\n\n            >>> # Create vowel classes\n            >>> vowels = project.NaturalClasses.Create(\"Vowels\", \"V\")\n            >>> high_vowels = project.NaturalClasses.Create(\"High Vowels\", \"HV\")\n\n            >>> # Create without abbreviation\n            >>> custom_class = project.NaturalClasses.Create(\"Custom Class\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(nc_or_hvo)",
          "summary": "Delete a natural class.",
          "description": "Delete a natural class.\n",
          "parameters": [
            {
              "name": "nc_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhNaturalClass object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If nc_or_hvo is None."
          ],
          "example": "            >>> obsolete = project.NaturalClasses.Create(\"Obsolete\", \"OBS\")\n            >>> # ... realize it's not needed\n            >>> project.NaturalClasses.Delete(obsolete)\n\n        Warning:\n            - Deleting a natural class that is in use may cause errors\n            - This includes natural classes used in:\n              - Phonological rules\n              - Phonological environments\n              - Other natural class definitions\n            - Deletion is permanent and cannot be undone\n            - Does not delete the phonemes in the class, only the class itself\n\n        See Also:\n            Create, GetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a natural class, creating a new copy with a new GUID.",
          "description": "Duplicate a natural class, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhNaturalClass object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source natural class. If False, insert at end of natural classes list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (if any exist). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "IPhNCSegments: The newly created duplicate natural class with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> ncOps = NaturalClassOperations(project)\n            >>> stops = ncOps.Create(\"Voiceless Stops\", \"VLS\")\n            >>> # Add some phonemes...\n            >>> # Now duplicate it to create \"Voiced Stops\"\n            >>> voiced = ncOps.Duplicate(stops)\n            >>> ncOps.SetName(voiced, \"Voiced Stops\")\n            >>> ncOps.SetAbbreviation(voiced, \"VCD\")\n            >>> print(f\"Original: {ncOps.GetGuid(stops)}\")\n            >>> print(f\"Duplicate: {ncOps.GetGuid(voiced)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAbbreviation",
          "signature": "GetAbbreviation(nc_or_hvo, wsHandle=None)",
          "summary": "Get the abbreviation of a natural class.",
          "description": "Get the abbreviation of a natural class.\n",
          "parameters": [
            {
              "name": "nc_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhNaturalClass object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The natural class abbreviation, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If nc_or_hvo is None."
          ],
          "example": "            >>> nc = project.NaturalClasses.Create(\"Voiceless Stops\", \"VLS\")\n            >>> abbr = project.NaturalClasses.GetAbbreviation(nc)\n            >>> print(abbr)\n            VLS\n\n            >>> # Print rule using abbreviations\n            >>> # Rule: VLS  VCD / V_V (voicing between vowels)\n            >>> vls = project.NaturalClasses.Find(\"Voiceless Stops\")\n            >>> vcd = project.NaturalClasses.Find(\"Voiced Stops\")\n            >>> v = project.NaturalClasses.Find(\"Vowels\")\n            >>> if vls and vcd and v:\n            ...     vls_abbr = project.NaturalClasses.GetAbbreviation(vls)\n            ...     vcd_abbr = project.NaturalClasses.GetAbbreviation(vcd)\n            ...     v_abbr = project.NaturalClasses.GetAbbreviation(v)\n            ...     print(f\"{vls_abbr}  {vcd_abbr} / {v_abbr}_{v_abbr}\")\n            VLS  VCD / V_V\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all natural classes in the phonological inventory.",
          "description": "Get all natural classes in the phonological inventory.\n",
          "parameters": [],
          "returns": "IPhNaturalClass: Each natural class in the project. ",
          "raises": [],
          "example": "            >>> for nc in project.NaturalClasses.GetAll():\n            ...     name = project.NaturalClasses.GetName(nc)\n            ...     abbr = project.NaturalClasses.GetAbbreviation(nc)\n            ...     phonemes = project.NaturalClasses.GetPhonemes(nc)\n            ...     print(f\"{name} ({abbr}): {len(phonemes)} phonemes\")\n            Voiceless Stops (VLS): 3 phonemes\n            Voiced Stops (VCD): 3 phonemes\n            Nasals (N): 3 phonemes\n            Vowels (V): 5 phonemes\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(nc_or_hvo, wsHandle=None)",
          "summary": "Get the name of a natural class.",
          "description": "Get the name of a natural class.\n",
          "parameters": [
            {
              "name": "nc_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhNaturalClass object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The natural class name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If nc_or_hvo is None."
          ],
          "example": "            >>> for nc in project.NaturalClasses.GetAll():\n            ...     name = project.NaturalClasses.GetName(nc)\n            ...     print(name)\n            Voiceless Stops\n            Voiced Stops\n            Fricatives\n            Nasals\n            Vowels\n\n        See Also:\n            SetName, GetAbbreviation",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPhonemes",
          "signature": "GetPhonemes(nc_or_hvo)",
          "summary": "Get all phonemes in a natural class.",
          "description": "Get all phonemes in a natural class.\n",
          "parameters": [
            {
              "name": "nc_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhNaturalClass object or HVO."
            }
          ],
          "returns": "list: List of IPhPhoneme objects in the class (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If nc_or_hvo is None."
          ],
          "example": "            >>> # Get members of voiceless stops\n            >>> for nc in project.NaturalClasses.GetAll():\n            ...     name = project.NaturalClasses.GetName(nc)\n            ...     if name == \"Voiceless Stops\":\n            ...         phonemes = project.NaturalClasses.GetPhonemes(nc)\n            ...         for phoneme in phonemes:\n            ...             print(project.Phonemes.GetRepresentation(phoneme))\n            /p/\n            /t/\n            /k/\n\n            >>> # Print all natural classes with their members\n            >>> for nc in project.NaturalClasses.GetAll():\n            ...     name = project.NaturalClasses.GetName(nc)\n            ...     phonemes = project.NaturalClasses.GetPhonemes(nc)\n            ...     count = len(phonemes)\n            ...     print(f\"{name}: {count} phonemes\")\n            Voiceless Stops: 3 phonemes\n            Voiced Stops: 3 phonemes\n            Nasals: 3 phonemes\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get dictionary of syncable properties for cross-project synchronization.",
          "description": "Get dictionary of syncable properties for cross-project synchronization.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IPhNaturalClass object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values. Keys are property names, values are the property values. ",
          "raises": [],
          "example": "            >>> ncOps = NaturalClassOperations(project)\n            >>> nc = list(ncOps.GetAll())[0]\n            >>> props = ncOps.GetSyncableProperties(nc)\n            >>> print(props.keys())\n            dict_keys(['Name', 'Abbreviation', 'Description', 'PhonemeGuids'])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemovePhoneme",
          "signature": "RemovePhoneme(nc_or_hvo, phoneme_or_hvo)",
          "summary": "Remove a phoneme from a natural class.",
          "description": "Remove a phoneme from a natural class.\n",
          "parameters": [
            {
              "name": "nc_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhNaturalClass object or HVO."
            },
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If nc_or_hvo or phoneme_or_hvo is None.",
            "FP_ParameterError: If the natural class is feature-based or if",
            "the phoneme is not in the natural class."
          ],
          "example": "            >>> # Remove /q/ from uvular stops if reclassified\n            >>> for nc in project.NaturalClasses.GetAll():\n            ...     if project.NaturalClasses.GetName(nc) == \"Uvular Stops\":\n            ...         q_phoneme = project.Phonemes.Find(\"/q/\")\n            ...         if q_phoneme and q_phoneme in project.NaturalClasses.GetPhonemes(nc):\n            ...             project.NaturalClasses.RemovePhoneme(nc, q_phoneme)\n\n            >>> # Clean up natural class\n            >>> for nc in project.NaturalClasses.GetAll():\n            ...     if project.NaturalClasses.GetName(nc) == \"Obsolete Phonemes\":\n            ...         phonemes = project.NaturalClasses.GetPhonemes(nc)\n            ...         for phoneme in phonemes:\n            ...             project.NaturalClasses.RemovePhoneme(nc, phoneme)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(nc_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a natural class.",
          "description": "Set the name of a natural class.\n",
          "parameters": [
            {
              "name": "nc_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhNaturalClass object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If nc_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> nc = project.NaturalClasses.Create(\"Plosives\", \"P\")\n            >>> # Prefer linguistic standard terminology\n            >>> project.NaturalClasses.SetName(nc, \"Stops\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize NaturalClassOperations with a FLExProject instance.",
          "description": "Initialize NaturalClassOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "grammar",
        "operations"
      ]
    },
    "PhonemeOperations": {
      "name": "PhonemeOperations",
      "type": "class",
      "namespace": "FlexLibs2.Grammar.PhonemeOperations",
      "source_file": "Grammar/PhonemeOperations",
      "category": "grammar",
      "summary": "This class provides operations for managing Phonemes in a FieldWorks project.",
      "description": "This class provides operations for managing Phonemes in a FieldWorks project.\n\nPhonemes are the minimal distinctive units of sound in a language. For example,\nin English, /p/ and /b/ are distinct phonemes because they distinguish words\nlike \"pat\" and \"bat\".\n\nUsage::\n\nfrom flexlibs import FLExProject, PhonemeOperations\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\nphonemeOps = PhonemeOperations(project)\n\n# Get all phonemes\nfor phoneme in phonemeOps.GetAll():\nprint(phonemeOps.GetRepresentation(phoneme))\n\n# Create a new phoneme\np_phoneme = phonemeOps.Create(\"/p/\")\nphonemeOps.SetDescription(p_phoneme, \"voiceless bilabial stop\")\n\n# Find and update\nb_phoneme = phonemeOps.Find(\"/b/\")\nif b_phoneme:\nphonemeOps.SetDescription(b_phoneme, \"voiced bilabial stop\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddCode",
          "signature": "AddCode(phoneme_or_hvo, representation, wsHandle=None)",
          "summary": "Add a code (allophonic representation) to a phoneme.",
          "description": "Add a code (allophonic representation) to a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            },
            {
              "name": "representation",
              "type": "",
              "default": null,
              "description": "The code representation (e.g., \"[t]\", \"[]\")."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IPhCode: The newly created code object. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If phoneme_or_hvo or representation is None.",
            "FP_ParameterError: If representation is empty."
          ],
          "example": "            >>> # Add aspiration allophone\n            >>> phoneme = project.Phonemes.Find(\"/p/\")\n            >>> if phoneme:\n            ...     code = project.Phonemes.AddCode(phoneme, \"[p]\")\n\n            >>> # Add multiple allophones for /t/\n            >>> phoneme = project.Phonemes.Find(\"/t/\")\n            >>> if phoneme:\n            ...     project.Phonemes.AddCode(phoneme, \"[t]\")   # plain\n            ...     project.Phonemes.AddCode(phoneme, \"[t]\")  # aspirated\n            ...     project.Phonemes.AddCode(phoneme, \"[]\")   # flap\n\n            >>> # Add vowel allophones\n            >>> phoneme = project.Phonemes.Find(\"/a/\")\n            >>> if phoneme:\n            ...     project.Phonemes.AddCode(phoneme, \"[a]\")   # open front\n            ...     project.Phonemes.AddCode(phoneme, \"[]\")   # open back\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two phonemes and return detailed differences.",
          "description": "Compare two phonemes and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First phoneme to compare (from source project)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second phoneme to compare (from target project)."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional PhonemeOperations instance for item1's project. Defaults to self."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional PhonemeOperations instance for item2's project. Defaults to self."
            }
          ],
          "returns": "tuple: (is_different, differences) where: - is_different (bool): True if items differ - differences (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> phoneme1 = project1_phonemeOps.Find(\"/p/\")\n            >>> phoneme2 = project2_phonemeOps.Find(\"/p/\")\n            >>> is_diff, diffs = project1_phonemeOps.CompareTo(\n            ...     phoneme1, phoneme2,\n            ...     ops1=project1_phonemeOps,\n            ...     ops2=project2_phonemeOps\n            ... )\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} -> {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(representation, wsHandle=None)",
          "summary": "Create a new phoneme.",
          "description": "Create a new phoneme.\n",
          "parameters": [
            {
              "name": "representation",
              "type": "str",
              "default": null,
              "description": "The phonemic representation (e.g., \"/p/\", \"/a/\")."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IPhPhoneme: The newly created phoneme object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If representation is None.",
            "FP_ParameterError: If representation is empty, or if a phoneme",
            "with this representation already exists, or if no phoneme set exists."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> p_phoneme = phonemeOps.Create(\"/p/\")\n            >>> print(phonemeOps.GetRepresentation(p_phoneme))\n            /p/\n\n            >>> # Create with description\n            >>> ch_phoneme = phonemeOps.Create(\"/t/\")\n            >>> phonemeOps.SetDescription(ch_phoneme, \"voiceless postalveolar affricate\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(phoneme_or_hvo)",
          "summary": "Delete a phoneme.",
          "description": "Delete a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If phoneme_or_hvo is None.",
            "FP_ParameterError: If the phoneme is in use and cannot be deleted."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> obsolete = phonemeOps.Find(\"/x/\")\n            >>> if obsolete:\n            ...     phonemeOps.Delete(obsolete)\n\n        Warning:\n            - Deleting a phoneme that is in use may raise an error from FLEx\n            - This includes phonemes used in:\n              - Natural classes\n              - Phonological rules\n              - Allomorph environments\n            - Deletion is permanent and cannot be undone\n            - Consider updating references before deletion\n\n        See Also:\n            Create, Exists, Find",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a phoneme, creating a new copy with a new GUID.",
          "description": "Duplicate a phoneme, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source phoneme. If False, insert at end of phoneme set."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (codes/allophones). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "IPhPhoneme: The newly created duplicate phoneme with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If no phoneme set exists."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> p_phoneme = phonemeOps.Find(\"/p/\")\n            >>> if p_phoneme:\n            ...     # Duplicate phoneme (shallow - no codes)\n            ...     dup = phonemeOps.Duplicate(p_phoneme)\n            ...     print(f\"Original: {phonemeOps.GetGuid(dup)}\")\n            ...     print(f\"Representation: {phonemeOps.GetRepresentation(dup)}\")\n            ...\n            ...     # Deep duplicate (includes allophonic codes)\n            ...     deep_dup = phonemeOps.Duplicate(p_phoneme, deep=True)\n            ...     codes = phonemeOps.GetCodes(deep_dup)\n            ...     print(f\"Codes: {len(codes)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(representation, wsHandle=None)",
          "summary": "Check if a phoneme with the given representation exists.",
          "description": "Check if a phoneme with the given representation exists.\n",
          "parameters": [
            {
              "name": "representation",
              "type": "str",
              "default": null,
              "description": "The representation to search for (case-sensitive)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "bool: True if phoneme exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If representation is None."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> if not phonemeOps.Exists(\"//\"):\n            ...     phonemeOps.Create(\"//\")\n            ...     phonemeOps.SetDescription(phonemeOps.Find(\"//\"), \"velar nasal\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(representation, wsHandle=None)",
          "summary": "Find a phoneme by representation.",
          "description": "Find a phoneme by representation.\n",
          "parameters": [
            {
              "name": "representation",
              "type": "str",
              "default": null,
              "description": "The representation to search for (case-sensitive)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IPhPhoneme or None: The phoneme object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If representation is None."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> p_phoneme = phonemeOps.Find(\"/p/\")\n            >>> if p_phoneme:\n            ...     desc = phonemeOps.GetDescription(p_phoneme)\n            ...     print(f\"/p/: {desc}\")\n            /p/: voiceless bilabial stop\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all phonemes in the project.",
          "description": "Get all phonemes in the project.\n",
          "parameters": [],
          "returns": "IPhPhoneme: Each phoneme object in the project's phoneme inventory. ",
          "raises": [],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> for phoneme in phonemeOps.GetAll():\n            ...     representation = phonemeOps.GetRepresentation(phoneme)\n            ...     description = phonemeOps.GetDescription(phoneme)\n            ...     print(f\"{representation}: {description}\")\n            /p/: voiceless bilabial stop\n            /b/: voiced bilabial stop\n            /t/: voiceless alveolar stop\n            /d/: voiced alveolar stop\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBasicIPASymbol",
          "signature": "GetBasicIPASymbol(phoneme_or_hvo, wsHandle=None)",
          "summary": "Get the basic IPA symbol for a phoneme.",
          "description": "Get the basic IPA symbol for a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The basic IPA symbol, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If phoneme_or_hvo is None."
          ],
          "example": "            >>> phoneme = project.Phonemes.Find(\"/p/\")\n            >>> if phoneme:\n            ...     symbol = project.Phonemes.GetBasicIPASymbol(phoneme)\n            ...     print(symbol)\n            p\n\n            >>> # Compare representation with basic IPA\n            >>> phoneme = project.Phonemes.Find(\"/t/\")\n            >>> if phoneme:\n            ...     repr = project.Phonemes.GetRepresentation(phoneme)\n            ...     ipa = project.Phonemes.GetBasicIPASymbol(phoneme)\n            ...     print(f\"Representation: {repr}, IPA: {ipa}\")\n            Representation: /t/, IPA: t\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCodes",
          "signature": "GetCodes(phoneme_or_hvo)",
          "summary": "Get all codes (allophonic representations) for a phoneme.",
          "description": "Get all codes (allophonic representations) for a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            }
          ],
          "returns": "list: List of IPhCode objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If phoneme_or_hvo is None."
          ],
          "example": "            >>> # Get allophones of /t/\n            >>> phoneme = project.Phonemes.Find(\"/t/\")\n            >>> if phoneme:\n            ...     codes = project.Phonemes.GetCodes(phoneme)\n            ...     for code in codes:\n            ...         ws = project.project.DefaultVernWs\n            ...         repr = ITsString(code.Representation.get_String(ws)).Text\n            ...         print(repr)\n            [t]   # plain voiceless alveolar stop\n            [t]  # aspirated (word-initial)\n            []   # flap (intervocalic)\n\n            >>> # Get vowel allophones\n            >>> phoneme = project.Phonemes.Find(\"/i/\")\n            >>> if phoneme:\n            ...     codes = project.Phonemes.GetCodes(phoneme)\n            ...     print(f\"Phoneme /i/ has {len(codes)} allophonic codes\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(phoneme_or_hvo, wsHandle=None)",
          "summary": "Get the description of a phoneme.",
          "description": "Get the description of a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The phoneme description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If phoneme_or_hvo is None."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> p_phoneme = phonemeOps.Find(\"/p/\")\n            >>> desc = phonemeOps.GetDescription(p_phoneme)\n            >>> print(desc)\n            voiceless bilabial stop\n\n            >>> # Print phoneme inventory with descriptions\n            >>> for phoneme in phonemeOps.GetAll():\n            ...     repr = phonemeOps.GetRepresentation(phoneme)\n            ...     desc = phonemeOps.GetDescription(phoneme)\n            ...     print(f\"{repr}: {desc}\")\n            /p/: voiceless bilabial stop\n            /b/: voiced bilabial stop\n            /t/: voiceless alveolar stop\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFeatures",
          "signature": "GetFeatures(phoneme_or_hvo)",
          "summary": "Get the feature structure of a phoneme.",
          "description": "Get the feature structure of a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            }
          ],
          "returns": "IFsFeatStruc or None: The phoneme's feature structure, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If phoneme_or_hvo is None."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> p_phoneme = phonemeOps.Find(\"/p/\")\n            >>> features = phonemeOps.GetFeatures(p_phoneme)\n            >>> if features:\n            ...     print(f\"Feature structure: {features.Hvo}\")\n            ... else:\n            ...     print(\"No features defined\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRepresentation",
          "signature": "GetRepresentation(phoneme_or_hvo, wsHandle=None)",
          "summary": "Get the representation of a phoneme.",
          "description": "Get the representation of a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The phoneme representation, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If phoneme_or_hvo is None."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> p_phoneme = phonemeOps.Find(\"/p/\")\n            >>> representation = phonemeOps.GetRepresentation(p_phoneme)\n            >>> print(representation)\n            /p/\n\n            >>> # Iterate and print all phonemes\n            >>> for phoneme in phonemeOps.GetAll():\n            ...     print(phonemeOps.GetRepresentation(phoneme))\n\n        See Also:\n            SetRepresentation, GetDescription",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get dictionary of syncable properties for cross-project synchronization.",
          "description": "Get dictionary of syncable properties for cross-project synchronization.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values. Keys are property names, values are the property values. ",
          "raises": [],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> phoneme = list(phonemeOps.GetAll())[0]\n            >>> props = phonemeOps.GetSyncableProperties(phoneme)\n            >>> print(props.keys())\n            dict_keys(['Name', 'Description', 'BasicIPASymbol', 'FeaturesGuid'])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsConsonant",
          "signature": "IsConsonant(phoneme_or_hvo)",
          "summary": "Check if a phoneme is classified as a consonant.",
          "description": "Check if a phoneme is classified as a consonant.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            }
          ],
          "returns": "bool: True if the phoneme is a consonant, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If phoneme_or_hvo is None."
          ],
          "example": "            >>> # Filter consonants from phoneme inventory\n            >>> consonants = []\n            >>> for phoneme in project.Phonemes.GetAll():\n            ...     if project.Phonemes.IsConsonant(phoneme):\n            ...         consonants.append(project.Phonemes.GetRepresentation(phoneme))\n            >>> print(\"Consonants:\", \", \".join(consonants))\n            Consonants: /p/, /t/, /k/, /b/, /d/, /g/, /m/, /n/\n\n            >>> # Create consonant natural classes\n            >>> for phoneme in project.Phonemes.GetAll():\n            ...     if project.Phonemes.IsConsonant(phoneme):\n            ...         desc = project.Phonemes.GetDescription(phoneme)\n            ...         repr = project.Phonemes.GetRepresentation(phoneme)\n            ...         print(f\"{repr}: {desc}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsVowel",
          "signature": "IsVowel(phoneme_or_hvo)",
          "summary": "Check if a phoneme is classified as a vowel.",
          "description": "Check if a phoneme is classified as a vowel.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            }
          ],
          "returns": "bool: True if the phoneme is a vowel, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If phoneme_or_hvo is None."
          ],
          "example": "            >>> # Filter vowels from phoneme inventory\n            >>> vowels = []\n            >>> for phoneme in project.Phonemes.GetAll():\n            ...     if project.Phonemes.IsVowel(phoneme):\n            ...         vowels.append(project.Phonemes.GetRepresentation(phoneme))\n            >>> print(\"Vowels:\", \", \".join(vowels))\n            Vowels: /a/, /e/, /i/, /o/, /u/\n\n            >>> # Count vowels vs consonants\n            >>> vowel_count = 0\n            >>> for phoneme in project.Phonemes.GetAll():\n            ...     if project.Phonemes.IsVowel(phoneme):\n            ...         vowel_count += 1\n            >>> print(f\"Total vowels: {vowel_count}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveCode",
          "signature": "RemoveCode(phoneme_or_hvo, code_or_hvo)",
          "summary": "Remove a code from a phoneme.",
          "description": "Remove a code from a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            },
            {
              "name": "code_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhCode object or HVO to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If phoneme_or_hvo or code_or_hvo is None.",
            "FP_ParameterError: If the code is not in the phoneme's code list."
          ],
          "example": "            >>> phoneme = project.Phonemes.Find(\"/t/\")\n            >>> if phoneme:\n            ...     codes = project.Phonemes.GetCodes(phoneme)\n            ...     # Remove the flap allophone\n            ...     for code in codes:\n            ...         ws = project.project.DefaultVernWs\n            ...         repr = ITsString(code.Representation.get_String(ws)).Text\n            ...         if repr == \"[]\":\n            ...             project.Phonemes.RemoveCode(phoneme, code)\n            ...             break\n\n            >>> # Remove by HVO\n            >>> phoneme = project.Phonemes.Find(\"/p/\")\n            >>> if phoneme:\n            ...     codes = project.Phonemes.GetCodes(phoneme)\n            ...     if codes:\n            ...         project.Phonemes.RemoveCode(phoneme, codes[0].Hvo)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(phoneme_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of a phoneme.",
          "description": "Set the description of a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If phoneme_or_hvo or description is None."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> p_phoneme = phonemeOps.Create(\"/p/\")\n            >>> phonemeOps.SetDescription(p_phoneme, \"voiceless bilabial stop\")\n\n            >>> # Add detailed articulatory description\n            >>> tap = phonemeOps.Find(\"//\")\n            >>> phonemeOps.SetDescription(\n            ...     tap,\n            ...     \"voiced alveolar tap/flap - allophone of /r/ in intervocalic position\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetRepresentation",
          "signature": "SetRepresentation(phoneme_or_hvo, representation, wsHandle=None)",
          "summary": "Set the representation of a phoneme.",
          "description": "Set the representation of a phoneme.\n",
          "parameters": [
            {
              "name": "phoneme_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhoneme object or HVO."
            },
            {
              "name": "representation",
              "type": "str",
              "default": null,
              "description": "The new representation."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If phoneme_or_hvo or representation is None.",
            "FP_ParameterError: If representation is empty."
          ],
          "example": "            >>> phonemeOps = PhonemeOperations(project)\n            >>> phoneme = phonemeOps.Find(\"/ph/\")  # non-standard notation\n            >>> if phoneme:\n            ...     phonemeOps.SetRepresentation(phoneme, \"/p/\")  # fix to proper IPA\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize PhonemeOperations with a FLExProject instance.",
          "description": "Initialize PhonemeOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "grammar",
        "operations"
      ]
    },
    "PhonologicalRuleOperations": {
      "name": "PhonologicalRuleOperations",
      "type": "class",
      "namespace": "FlexLibs2.Grammar.PhonologicalRuleOperations",
      "source_file": "Grammar/PhonologicalRuleOperations",
      "category": "grammar",
      "summary": "This class provides operations for managing phonological rules in a\nFieldWorks project.",
      "description": "This class provides operations for managing phonological rules in a\nFieldWorks project.\n\nPhonological rules define systematic sound changes that apply in specific\nphonological environments. They consist of input specifications, output\nspecifications, and contextual conditions.\n\nUsage::\n\nfrom flexlibs import FLExProject, PhonologicalRuleOperations\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\nphonRuleOps = PhonologicalRuleOperations(project)\n\n# Get all phonological rules\nfor rule in phonRuleOps.GetAll():\nname = phonRuleOps.GetName(rule)\ndesc = phonRuleOps.GetDescription(rule)\nprint(f\"{name}: {desc}\")\n\n# Create a new phonological rule\nrule = phonRuleOps.Create(\"Voicing Assimilation\")\nphonRuleOps.SetDescription(rule, \"Obstruents become voiced before vowels\")\n\n# Add input/output components\nphonRuleOps.AddInputSegment(rule, phoneme_t)\nphonRuleOps.AddOutputSegment(rule, phoneme_d)\n\n# Set phonological context\nphonRuleOps.SetRightContext(rule, vowel_class)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddInputSegment",
          "signature": "AddInputSegment(rule_or_hvo, phoneme_or_class)",
          "summary": "Add an input segment or natural class to the rule.",
          "description": "Add an input segment or natural class to the rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "phoneme_or_class",
              "type": "",
              "default": null,
              "description": "A phoneme object, natural class object, or HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo or phoneme_or_class is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = phonRuleOps.Create(\"Voicing Rule\")\n            >>> # Add voiceless stop as input\n            >>> phoneme_t = project.Phonemes.Find(\"/t/\")\n            >>> phonRuleOps.AddInputSegment(rule, phoneme_t)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddOutputSegment",
          "signature": "AddOutputSegment(rule_or_hvo, phoneme_or_class)",
          "summary": "Add an output segment or natural class to the rule.",
          "description": "Add an output segment or natural class to the rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "phoneme_or_class",
              "type": "",
              "default": null,
              "description": "A phoneme object, natural class object, or HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo or phoneme_or_class is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = phonRuleOps.Create(\"Voicing Rule\")\n            >>> # Add voiced stop as output\n            >>> phoneme_d = project.Phonemes.Find(\"/d/\")\n            >>> phonRuleOps.AddOutputSegment(rule, phoneme_d)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two phonological rules and return detailed differences.",
          "description": "Compare two phonological rules and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First rule to compare (from source project)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second rule to compare (from target project)."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional PhonologicalRuleOperations instance for item1's project. Defaults to self."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional PhonologicalRuleOperations instance for item2's project. Defaults to self."
            }
          ],
          "returns": "tuple: (is_different, differences) where: - is_different (bool): True if items differ - differences (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> rule1 = project1_phonRuleOps.Find(\"Voicing Assimilation\")\n            >>> rule2 = project2_phonRuleOps.Find(\"Voicing Assimilation\")\n            >>> is_diff, diffs = project1_phonRuleOps.CompareTo(\n            ...     rule1, rule2,\n            ...     ops1=project1_phonRuleOps,\n            ...     ops2=project2_phonRuleOps\n            ... )\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} -> {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, description=None)",
          "summary": "Create a new phonological rule.",
          "description": "Create a new phonological rule.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the rule (e.g., \"Voicing Assimilation\")."
            },
            {
              "name": "description",
              "type": "str, optional",
              "default": null,
              "description": "Optional description of the rule. Defaults to None."
            }
          ],
          "returns": "IPhPhonRule: The newly created phonological rule object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = phonRuleOps.Create(\"Voicing Assimilation\",\n            ...     \"Voiceless stops become voiced between vowels\")\n            >>> print(phonRuleOps.GetName(rule))\n            Voicing Assimilation\n\n            >>> # Create and configure\n            >>> rule = phonRuleOps.Create(\"Final Devoicing\")\n            >>> phonRuleOps.SetDescription(rule, \"Obstruents devoice word-finally\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(rule_or_hvo)",
          "summary": "Delete a phonological rule.",
          "description": "Delete a phonological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> obsolete = phonRuleOps.Create(\"Obsolete Rule\")\n            >>> # ... realize it's not needed\n            >>> phonRuleOps.Delete(obsolete)\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - Any references to this rule will be broken\n            - Consider deactivating instead of deleting\n\n        See Also:\n            Create, GetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a phonological rule, creating a new copy with a new GUID.",
          "description": "Duplicate a phonological rule, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source rule. If False, insert at end of rules list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, deep copy owned objects (StrucDescOS, RightHandSidesOS). If False (default), owned objects are not copied."
            }
          ],
          "returns": "IPhPhonRule: The newly created duplicate rule with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> voicing = phonRuleOps.Create(\"Voicing Assimilation\")\n            >>> # Shallow copy (no owned objects)\n            >>> copy = phonRuleOps.Duplicate(voicing)\n            >>> print(phonRuleOps.GetName(copy))\n            Voicing Assimilation\n\n            >>> # Deep copy (includes StrucDescOS and RightHandSidesOS)\n            >>> rule = phonRuleOps.Create(\"Complex Rule\")\n            >>> copy = phonRuleOps.Duplicate(rule, deep=True)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name)",
          "summary": "Check if a phonological rule with the given name exists.",
          "description": "Check if a phonological rule with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for."
            }
          ],
          "returns": "bool: True if a rule with this name exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> if phonRuleOps.Exists(\"Voicing Assimilation\"):\n            ...     print(\"Rule already exists\")\n            >>> else:\n            ...     rule = phonRuleOps.Create(\"Voicing Assimilation\")\n\n        See Also:\n            Find, GetAll, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find a phonological rule by name.",
          "description": "Find a phonological rule by name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for (case-insensitive)."
            }
          ],
          "returns": "IPhPhonRule or None: The rule object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = phonRuleOps.Find(\"Voicing Assimilation\")\n            >>> if rule:\n            ...     desc = phonRuleOps.GetDescription(rule)\n            ...     print(f\"Found: {desc}\")\n\n            >>> # Case-insensitive search\n            >>> rule = phonRuleOps.Find(\"voicing assimilation\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all phonological rules in the project.",
          "description": "Get all phonological rules in the project.\n",
          "parameters": [],
          "returns": "IPhPhonRule: Each phonological rule object in the project. ",
          "raises": [],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> for rule in phonRuleOps.GetAll():\n            ...     name = phonRuleOps.GetName(rule)\n            ...     print(f\"Rule: {name}\")\n            Rule: Voicing Assimilation\n            Rule: Nasal Place Assimilation\n            Rule: Final Devoicing\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(rule_or_hvo, wsHandle=None)",
          "summary": "Get the description of a phonological rule.",
          "description": "Get the description of a phonological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The rule description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> for rule in phonRuleOps.GetAll():\n            ...     name = phonRuleOps.GetName(rule)\n            ...     desc = phonRuleOps.GetDescription(rule)\n            ...     print(f\"{name}: {desc}\")\n\n        See Also:\n            SetDescription, GetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDirection",
          "signature": "GetDirection(rule_or_hvo)",
          "summary": "Get the direction of rule application.",
          "description": "Get the direction of rule application.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            }
          ],
          "returns": "int: The direction value (0=left-to-right, 1=right-to-left, 2=simultaneous). ",
          "raises": [
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = list(phonRuleOps.GetAll())[0]\n            >>> direction = phonRuleOps.GetDirection(rule)\n            >>> if direction == 0:\n            ...     print(\"Left-to-right application\")\n\n        See Also:\n            SetDirection",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(rule_or_hvo, wsHandle=None)",
          "summary": "Get the name of a phonological rule.",
          "description": "Get the name of a phonological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The rule name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> for rule in phonRuleOps.GetAll():\n            ...     name = phonRuleOps.GetName(rule)\n            ...     print(name)\n            Voicing Assimilation\n            Final Devoicing\n\n        See Also:\n            SetName, GetDescription",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetStratum",
          "signature": "GetStratum(rule_or_hvo)",
          "summary": "Get the stratum of a phonological rule.",
          "description": "Get the stratum of a phonological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            }
          ],
          "returns": "IMoStratum or None: The stratum object if set, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = list(phonRuleOps.GetAll())[0]\n            >>> stratum = phonRuleOps.GetStratum(rule)\n            >>> if stratum:\n            ...     print(f\"Rule applies in stratum: {stratum.Name.BestAnalysisAlternative.Text}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get dictionary of syncable properties for cross-project synchronization.",
          "description": "Get dictionary of syncable properties for cross-project synchronization.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values. Keys are property names, values are the property values. ",
          "raises": [],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = list(phonRuleOps.GetAll())[0]\n            >>> props = phonRuleOps.GetSyncableProperties(rule)\n            >>> print(props.keys())\n            dict_keys(['Name', 'Description', 'Direction', 'StratumGuid'])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(rule_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of a phonological rule.",
          "description": "Set the description of a phonological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo or description is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = list(phonRuleOps.GetAll())[0]\n            >>> phonRuleOps.SetDescription(rule,\n            ...     \"Voiceless stops become voiced between vowels\")\n\n        See Also:\n            GetDescription, SetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDirection",
          "signature": "SetDirection(rule_or_hvo, direction)",
          "summary": "Set the direction of rule application.",
          "description": "Set the direction of rule application.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "direction",
              "type": "int",
              "default": null,
              "description": "0=left-to-right, 1=right-to-left, 2=simultaneous."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo is None.",
            "FP_ParameterError: If direction is not 0, 1, or 2."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = list(phonRuleOps.GetAll())[0]\n            >>> # Set to right-to-left\n            >>> phonRuleOps.SetDirection(rule, 1)\n\n        See Also:\n            GetDirection",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLeftContext",
          "signature": "SetLeftContext(rule_or_hvo, context_item)",
          "summary": "Set the left context (environment before the target) for the rule.",
          "description": "Set the left context (environment before the target) for the rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "context_item",
              "type": "",
              "default": null,
              "description": "A phoneme, natural class, or environment object/HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = phonRuleOps.Create(\"Final Devoicing\")\n            >>> # Set word boundary as left context\n            >>> phonRuleOps.SetLeftContext(rule, None)  # No left constraint\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(rule_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a phonological rule.",
          "description": "Set the name of a phonological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = list(phonRuleOps.GetAll())[0]\n            >>> phonRuleOps.SetName(rule, \"Intervocalic Voicing\")\n\n        See Also:\n            GetName, SetDescription",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetRightContext",
          "signature": "SetRightContext(rule_or_hvo, context_item)",
          "summary": "Set the right context (environment after the target) for the rule.",
          "description": "Set the right context (environment after the target) for the rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "context_item",
              "type": "",
              "default": null,
              "description": "A phoneme, natural class, or environment object/HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = phonRuleOps.Create(\"Intervocalic Voicing\")\n            >>> # Get vowel natural class\n            >>> vowels = project.NaturalClasses.Find(\"Vowels\")\n            >>> # Set vowel as right context\n            >>> phonRuleOps.SetRightContext(rule, vowels)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetStratum",
          "signature": "SetStratum(rule_or_hvo, stratum)",
          "summary": "Set the stratum of a phonological rule.",
          "description": "Set the stratum of a phonological rule.\n",
          "parameters": [
            {
              "name": "rule_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhPhonRule object or HVO."
            },
            {
              "name": "stratum",
              "type": "",
              "default": null,
              "description": "The IMoStratum object, HVO, or None to clear."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If rule_or_hvo is None."
          ],
          "example": "            >>> phonRuleOps = PhonologicalRuleOperations(project)\n            >>> rule = list(phonRuleOps.GetAll())[0]\n            >>> # Get first stratum\n            >>> morph_data = project.lp.MorphologicalDataOA\n            >>> if morph_data and morph_data.StrataOS.Count > 0:\n            ...     stratum = morph_data.StrataOS[0]\n            ...     phonRuleOps.SetStratum(rule, stratum)\n\n        See Also:\n            GetStratum",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize PhonologicalRuleOperations with a FLExProject instance.",
          "description": "Initialize PhonologicalRuleOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "grammar",
        "operations"
      ]
    },
    "POSOperations": {
      "name": "POSOperations",
      "type": "class",
      "namespace": "FlexLibs2.Grammar.POSOperations",
      "source_file": "Grammar/POSOperations",
      "category": "grammar",
      "summary": "This class provides operations for managing Parts of Speech in a\nFieldWorks project.",
      "description": "This class provides operations for managing Parts of Speech in a\nFieldWorks project.\n\nParts of Speech are fundamental grammatical categories used in linguistic\nanalysis (e.g., Noun, Verb, Adjective, etc.).\n\nUsage::\n\nfrom flexlibs import FLExProject, POSOperations\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\nposOps = POSOperations(project)\n\n# Get all parts of speech\nfor pos in posOps.GetAll():\nprint(posOps.GetName(pos), posOps.GetAbbreviation(pos))\n\n# Create a new POS\nnoun = posOps.Create(\"Noun\", \"N\")\n\n# Find and update\nverb = posOps.Find(\"Verb\")\nif verb:\nposOps.SetAbbreviation(verb, \"V\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddSubcategory",
          "signature": "AddSubcategory(pos_or_hvo, name, abbreviation)",
          "summary": "Add a subcategory to a part of speech.",
          "description": "Add a subcategory to a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO to add subcategory to."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the subcategory."
            },
            {
              "name": "abbreviation",
              "type": "str",
              "default": null,
              "description": "Short abbreviation for the subcategory."
            }
          ],
          "returns": "IPartOfSpeech: The newly created subcategory object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pos_or_hvo, name, or abbreviation is None.",
            "FP_ParameterError: If name or abbreviation is empty."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> proper_noun = posOps.AddSubcategory(noun, \"Proper Noun\", \"PN\")\n            >>> print(posOps.GetName(proper_noun))\n            Proper Noun\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two parts of speech and return detailed differences.",
          "description": "Compare two parts of speech and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First POS to compare (from source project)."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second POS to compare (from target project)."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional POSOperations instance for item1's project. Defaults to self."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional POSOperations instance for item2's project. Defaults to self."
            }
          ],
          "returns": "tuple: (is_different, differences) where: - is_different (bool): True if items differ - differences (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> pos1 = project1_posOps.Find(\"Noun\")\n            >>> pos2 = project2_posOps.Find(\"Noun\")\n            >>> is_diff, diffs = project1_posOps.CompareTo(\n            ...     pos1, pos2,\n            ...     ops1=project1_posOps,\n            ...     ops2=project2_posOps\n            ... )\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} -> {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, abbreviation, catalogSourceId=None)",
          "summary": "Create a new part of speech.",
          "description": "Create a new part of speech.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the POS (e.g., \"Noun\", \"Verb\")."
            },
            {
              "name": "abbreviation",
              "type": "str",
              "default": null,
              "description": "Short abbreviation (e.g., \"N\", \"V\")."
            },
            {
              "name": "catalogSourceId",
              "type": "str, optional",
              "default": null,
              "description": "Optional catalog identifier for linguistic databases (e.g., \"GOLD:Noun\"). Defaults to None."
            }
          ],
          "returns": "IPartOfSpeech: The newly created POS object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name or abbreviation is None.",
            "FP_ParameterError: If name or abbreviation is empty, or if a POS",
            "with this name already exists."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Create(\"Noun\", \"N\")\n            >>> print(posOps.GetName(noun))\n            Noun\n\n            >>> proper_noun = posOps.Create(\"Proper Noun\", \"PN\", \"GOLD:Noun\")\n            >>> print(posOps.GetAbbreviation(proper_noun))\n            PN\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(pos_or_hvo)",
          "summary": "Delete a part of speech.",
          "description": "Delete a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pos_or_hvo is None.",
            "FP_ParameterError: If the POS is in use and cannot be deleted."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> obsolete = posOps.Find(\"Obsolete\")\n            >>> if obsolete:\n            ...     posOps.Delete(obsolete)\n\n        Warning:\n            - Deleting a POS that is in use may raise an error from FLEx\n            - Will also delete all subcategories recursively\n            - Deletion is permanent and cannot be undone\n            - Lexical entries using this POS should be updated first\n\n        See Also:\n            Create, Exists, Find",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a part of speech, creating a new copy with a new GUID.",
          "description": "Duplicate a part of speech, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source POS. If False, insert at end of parent's possibilities list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, recursively duplicate all subcategories. If False (default), only duplicate the POS itself."
            }
          ],
          "returns": "IPartOfSpeech: The newly created duplicate POS with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> # Shallow copy (no subcategories)\n            >>> noun_copy = posOps.Duplicate(noun)\n            >>> print(posOps.GetName(noun_copy))\n            Noun\n\n            >>> # Deep copy (includes all subcategories)\n            >>> verb = posOps.Find(\"Verb\")\n            >>> verb_copy = posOps.Duplicate(verb, deep=True)\n            >>> orig_subs = posOps.GetSubcategories(verb)\n            >>> copy_subs = posOps.GetSubcategories(verb_copy)\n            >>> print(f\"Original has {len(orig_subs)} subcategories\")\n            >>> print(f\"Copy has {len(copy_subs)} subcategories\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name)",
          "summary": "Check if a part of speech with the given name exists.",
          "description": "Check if a part of speech with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for (case-insensitive)."
            }
          ],
          "returns": "bool: True if POS exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> if not posOps.Exists(\"Noun\"):\n            ...     posOps.Create(\"Noun\", \"N\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find a part of speech by name.",
          "description": "Find a part of speech by name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for (case-insensitive)."
            }
          ],
          "returns": "IPartOfSpeech or None: The POS object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> if noun:\n            ...     abbr = posOps.GetAbbreviation(noun)\n            ...     print(f\"Found: {abbr}\")\n            Found: N\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAbbreviation",
          "signature": "GetAbbreviation(pos_or_hvo, wsHandle=None)",
          "summary": "Get the abbreviation of a part of speech.",
          "description": "Get the abbreviation of a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The POS abbreviation, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If pos_or_hvo is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> abbr = posOps.GetAbbreviation(noun)\n            >>> print(abbr)\n            N\n\n        See Also:\n            SetAbbreviation, GetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAffixSlots",
          "signature": "GetAffixSlots(pos_or_hvo)",
          "summary": "Get all affix slots associated with a part of speech.",
          "description": "Get all affix slots associated with a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO."
            }
          ],
          "returns": "list: List of affix slot objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If pos_or_hvo is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> verb = posOps.Find(\"Verb\")\n            >>> slots = posOps.GetAffixSlots(verb)\n            >>> for slot in slots:\n            ...     print(slot.Name)\n            Tense\n            Aspect\n            Mood\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all parts of speech in the project.",
          "description": "Get all parts of speech in the project.\n",
          "parameters": [],
          "returns": "IPartOfSpeech: Each part of speech object in the project's POS list. ",
          "raises": [],
          "example": "            >>> posOps = POSOperations(project)\n            >>> for pos in posOps.GetAll():\n            ...     name = posOps.GetName(pos)\n            ...     abbr = posOps.GetAbbreviation(pos)\n            ...     print(f\"{name} ({abbr})\")\n            Noun (N)\n            Verb (V)\n            Adjective (Adj)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCatalogSourceId",
          "signature": "GetCatalogSourceId(pos_or_hvo)",
          "summary": "Get the catalog source ID of a part of speech.",
          "description": "Get the catalog source ID of a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO."
            }
          ],
          "returns": "str: The catalog source ID, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If pos_or_hvo is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> catalog_id = posOps.GetCatalogSourceId(noun)\n            >>> print(catalog_id)\n            GOLD:Noun\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEntryCount",
          "signature": "GetEntryCount(pos_or_hvo)",
          "summary": "Count the number of lexical entries using this part of speech.",
          "description": "Count the number of lexical entries using this part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO."
            }
          ],
          "returns": "int: The count of entries using this POS. ",
          "raises": [
            "FP_NullParameterError: If pos_or_hvo is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> count = posOps.GetEntryCount(noun)\n            >>> print(f\"There are {count} noun entries\")\n            There are 342 noun entries\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetInflectionClasses",
          "signature": "GetInflectionClasses(pos_or_hvo)",
          "summary": "Get all inflection classes associated with a part of speech.",
          "description": "Get all inflection classes associated with a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO."
            }
          ],
          "returns": "list: List of inflection class objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If pos_or_hvo is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> verb = posOps.Find(\"Verb\")\n            >>> classes = posOps.GetInflectionClasses(verb)\n            >>> for infl_class in classes:\n            ...     print(infl_class.Name)\n            Regular Verb\n            Irregular Verb\n            Modal Verb\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(pos_or_hvo, wsHandle=None)",
          "summary": "Get the name of a part of speech.",
          "description": "Get the name of a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The POS name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If pos_or_hvo is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> name = posOps.GetName(noun)\n            >>> print(name)\n            Noun\n\n            >>> # Get name in a specific writing system\n            >>> vern_name = posOps.GetName(noun, project.WSHandle('en'))\n\n        See Also:\n            SetName, GetAbbreviation",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubcategories",
          "signature": "GetSubcategories(pos_or_hvo)",
          "summary": "Get all subcategories of a part of speech.",
          "description": "Get all subcategories of a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO."
            }
          ],
          "returns": "list: List of IPartOfSpeech subcategory objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If pos_or_hvo is None."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> subcats = posOps.GetSubcategories(noun)\n            >>> for subcat in subcats:\n            ...     print(posOps.GetName(subcat))\n            Proper Noun\n            Common Noun\n            Count Noun\n            Mass Noun\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get dictionary of syncable properties for cross-project synchronization.",
          "description": "Get dictionary of syncable properties for cross-project synchronization.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values. Keys are property names, values are the property values. ",
          "raises": [],
          "example": "            >>> posOps = POSOperations(project)\n            >>> pos = list(posOps.GetAll())[0]\n            >>> props = posOps.GetSyncableProperties(pos)\n            >>> print(props.keys())\n            dict_keys(['Name', 'Abbreviation', 'Description', 'CatalogSourceId'])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveSubcategory",
          "signature": "RemoveSubcategory(pos_or_hvo, subcat_or_hvo)",
          "summary": "Remove a subcategory from a part of speech.",
          "description": "Remove a subcategory from a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO (parent)."
            },
            {
              "name": "subcat_or_hvo",
              "type": "",
              "default": null,
              "description": "The subcategory IPartOfSpeech object or HVO to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pos_or_hvo or subcat_or_hvo is None.",
            "FP_ParameterError: If the subcategory is in use and cannot be deleted."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> subcats = posOps.GetSubcategories(noun)\n            >>> for subcat in subcats:\n            ...     if posOps.GetName(subcat) == \"Obsolete Subcategory\":\n            ...         posOps.RemoveSubcategory(noun, subcat)\n\n        Warning:\n            - Removing a subcategory that is in use may raise an error from FLEx\n            - Will also delete all nested subcategories recursively\n            - Removal is permanent and cannot be undone\n            - Lexical entries using this subcategory should be updated first\n\n        See Also:\n            AddSubcategory, GetSubcategories, Delete",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAbbreviation",
          "signature": "SetAbbreviation(pos_or_hvo, abbr, wsHandle=None)",
          "summary": "Set the abbreviation of a part of speech.",
          "description": "Set the abbreviation of a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO."
            },
            {
              "name": "abbr",
              "type": "str",
              "default": null,
              "description": "The new abbreviation."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pos_or_hvo or abbr is None.",
            "FP_ParameterError: If abbr is empty."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> noun = posOps.Find(\"Noun\")\n            >>> posOps.SetAbbreviation(noun, \"N\")\n\n        See Also:\n            GetAbbreviation, SetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(pos_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a part of speech.",
          "description": "Set the name of a part of speech.\n",
          "parameters": [
            {
              "name": "pos_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pos_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> posOps = POSOperations(project)\n            >>> typo = posOps.Find(\"Nown\")  # typo\n            >>> if typo:\n            ...     posOps.SetName(typo, \"Noun\")  # fix it\n\n        See Also:\n            GetName, SetAbbreviation",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize POSOperations with a FLExProject instance.",
          "description": "Initialize POSOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "grammar",
        "operations"
      ]
    },
    "AllomorphOperations": {
      "name": "AllomorphOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.AllomorphOperations",
      "source_file": "Lexicon/AllomorphOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing allomorphs in a FieldWorks project.",
      "description": "This class provides operations for managing allomorphs in a FieldWorks project.\n\nAllomorphs are variant forms of morphemes that appear in different phonological\nor morphological contexts. For example, the English plural morpheme has\nallomorphs \"-s\", \"-es\", and \"-en\" (ox/oxen).\n\nUsage::\n\nfrom flexlibs import FLExProject, AllomorphOperations\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\nallomorphOps = AllomorphOperations(project)\n\n# Get entry\nentry = project.LexiconAllEntries()[0]\n\n# Get all allomorphs for an entry\nfor allomorph in allomorphOps.GetAll(entry):\nform = allomorphOps.GetForm(allomorph)\nprint(f\"Allomorph: {form}\")\n\n# Create a new allomorph\nmorphType = project.lp.MorphTypesOA.PossibilitiesOS[0]\nallomorph = allomorphOps.Create(entry, \"walk\", morphType)\n\n# Set phonological environment\nenv = project.lp.PhonologicalDataOA.EnvironmentsOS[0]\nallomorphOps.AddPhoneEnv(allomorph, env)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddPhoneEnv",
          "signature": "AddPhoneEnv(allomorph_or_hvo, env_or_hvo)",
          "summary": "Add a phonological environment to an allomorph.",
          "description": "Add a phonological environment to an allomorph.\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO."
            },
            {
              "name": "env_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO to add."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If allomorph_or_hvo or env_or_hvo is None."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorphs = list(allomorphOps.GetAll(entry))\n            >>> if allomorphs and project.lp.PhonologicalDataOA:\n            ...     envs = project.lp.PhonologicalDataOA.EnvironmentsOS\n            ...     if envs.Count > 0:\n            ...         allomorphOps.AddPhoneEnv(allomorphs[0], envs[0])\n\n            >>> # Define that \"-es\" appears after sibilants\n            >>> # (assuming you have created the environment)\n            >>> sibilant_env = project.lp.PhonologicalDataOA.EnvironmentsOS[0]\n            >>> allomorphOps.AddPhoneEnv(allomorphs[0], sibilant_env)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two allomorphs and return their differences.",
          "description": "Compare two allomorphs and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first IMoForm object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second IMoForm object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional AllomorphOperations instance for item1 (for cross-project comparison). If None, uses self."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional AllomorphOperations instance for item2 (for cross-project comparison). If None, uses self."
            }
          ],
          "returns": "tuple: (is_different, differences_dict) where: - is_different: True if items differ, False otherwise - differences_dict: Maps property names to (value1, value2) tuples for differing properties ",
          "raises": [],
          "example": "            >>> allo1 = list(project1.Allomorphs.GetAll(entry1))[0]\n            >>> allo2 = list(project2.Allomorphs.GetAll(entry2))[0]\n            >>> is_diff, diffs = project1.Allomorphs.CompareTo(allo1, allo2,\n            ...                                                  project1.Allomorphs,\n            ...                                                  project2.Allomorphs)\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} -> {val2}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(entry_or_hvo, form, morphType=None, wsHandle=None)",
          "summary": "Create a new allomorph for a lexical entry.",
          "description": "Create a new allomorph for a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO."
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The allomorph form (e.g., \"-ing\", \"walk\", \"pre-\")."
            },
            {
              "name": "morphType",
              "type": "IMoMorphType, optional",
              "default": null,
              "description": "The morpheme type object. If None (default), inherits from the entry's LexemeFormOA morph type, matching FLEx GUI behavior."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IMoForm: The newly created allomorph object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If entry_or_hvo or form is None.",
            "FP_ParameterError: If form is empty or entry has no LexemeFormOA when",
            "morphType is not provided."
          ],
          "example": "            >>> # Create allomorph with inherited morph type (default)\n            >>> entry = project.LexEntry.Create(\"run\")\n            >>> allomorph = project.Allomorphs.Create(entry, \"running\")\n            >>> print(project.Allomorphs.GetForm(allomorph))\n            running\n\n            >>> # Create with explicit morph type\n            >>> morphType = project.lexDB.MorphTypesOA.PossibilitiesOS[0]\n            >>> allomorph = project.Allomorphs.Create(entry, \"ran\", morphType)\n\n            >>> # Create with specific writing system\n            >>> allomorph = project.Allomorphs.Create(entry, \"rn\",\n            ...                                        wsHandle=project.WSHandle('en-fonipa'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(allomorph_or_hvo)",
          "summary": "Delete an allomorph.",
          "description": "Delete an allomorph.\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If allomorph_or_hvo is None.",
            "FP_ParameterError: If the allomorph is in use or cannot be deleted."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorphs = list(allomorphOps.GetAll(entry))\n            >>> if len(allomorphs) > 1:\n            ...     allomorphOps.Delete(allomorphs[-1])\n\n        Warning:\n            - Deleting an allomorph that is in use in analyses may cause issues\n            - If deleting the lexeme form and alternates exist, the first\n              alternate becomes the new lexeme form\n            - Deletion is permanent and cannot be undone\n            - Consider checking usage in texts before deletion\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate an allomorph, creating a new copy with a new GUID.",
          "description": "Duplicate an allomorph, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source allomorph. If False, insert at end of parent's alternate forms list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "Reserved for future use (allomorphs have no owned objects)."
            }
          ],
          "returns": "IMoForm: The newly created duplicate allomorph with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorphs = list(allomorphOps.GetAll(entry))\n            >>> if len(allomorphs) > 1:  # Don't duplicate lexeme form\n            ...     # Duplicate an alternate form\n            ...     dup = allomorphOps.Duplicate(allomorphs[1])\n            ...     print(f\"Original: {allomorphOps.GetGuid(allomorphs[1])}\")\n            ...     print(f\"Duplicate: {allomorphOps.GetGuid(dup)}\")\n            ...     print(f\"Form: {allomorphOps.GetForm(dup)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n            Form: walk\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(entry_or_hvo=None)",
          "summary": "Get all allomorphs for a lexical entry, or all allomorphs in the entire project.",
          "description": "Get all allomorphs for a lexical entry, or all allomorphs in the entire project.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO. If None, iterates all allomorphs in the entire project."
            }
          ],
          "returns": "IMoForm: Each allomorph of the entry (or project). ",
          "raises": [],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> # Get allomorphs for specific entry\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> for allomorph in allomorphOps.GetAll(entry):\n            ...     form = allomorphOps.GetForm(allomorph)\n            ...     print(f\"Allomorph: {form}\")\n            Allomorph: run\n            Allomorph: ran\n            Allomorph: runn-\n\n            >>> # Get ALL allomorphs in entire project\n            >>> for allomorph in allomorphOps.GetAll():\n            ...     form = allomorphOps.GetForm(allomorph)\n            ...     print(f\"Allomorph: {form}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(allomorph_or_hvo, wsHandle=None)",
          "summary": "Get the form (text) of an allomorph.",
          "description": "Get the form (text) of an allomorph.\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The allomorph form, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If allomorph_or_hvo is None."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorphs = list(allomorphOps.GetAll(entry))\n            >>> if allomorphs:\n            ...     form = allomorphOps.GetForm(allomorphs[0])\n            ...     print(form)\n            walk\n\n            >>> # Get form in specific writing system\n            >>> form_ipa = allomorphOps.GetForm(allomorphs[0],\n            ...                                  project.WSHandle('en-fonipa'))\n            >>> print(form_ipa)\n            wk\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFormAudio",
          "signature": "GetFormAudio(allomorph_or_hvo, wsHandle=None)",
          "summary": "Get the audio file path from an allomorph's Form field.",
          "description": "Get the audio file path from an allomorph's Form field.\n\nThis is a convenience method for extracting audio file references from\naudio writing system fields.\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional audio writing system handle. If None, uses the first audio writing system found in the project."
            }
          ],
          "returns": "str: Path to audio file (relative to project root), or None if no audio is set. ",
          "raises": [
            "FP_NullParameterError: If allomorph_or_hvo is None."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorph = list(allomorphOps.GetAll(entry))[0]\n            >>>\n            >>> # Get audio file path\n            >>> audio_path = allomorphOps.GetFormAudio(allomorph)\n            >>> if audio_path:\n            ...     print(f\"Audio file: {audio_path}\")\n            ...     # Construct full path if needed\n            ...     import os\n            ...     full_path = os.path.join(\n            ...         project.GetLinkedFilesDir(),\n            ...         audio_path.replace(\"LinkedFiles/\", \"\")\n            ...     )\n            ...     print(f\"Full path: {full_path}\")\n            ... else:\n            ...     print(\"No audio recording\")\n            Audio file: LinkedFiles/AudioVisual/pronunciation.wav\n\n            >>> # Get audio with specific writing system\n            >>> audio_ws = project.WSHandle('en-Zxxx-x-audio')\n            >>> audio_path = allomorphOps.GetFormAudio(allomorph, audio_ws)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMorphType",
          "signature": "GetMorphType(allomorph_or_hvo)",
          "summary": "Get the morpheme type of an allomorph.",
          "description": "Get the morpheme type of an allomorph.\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO."
            }
          ],
          "returns": "IMoMorphType: The morpheme type (stem, prefix, suffix, etc.). ",
          "raises": [
            "FP_NullParameterError: If allomorph_or_hvo is None."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorphs = list(allomorphOps.GetAll(entry))\n            >>> if allomorphs:\n            ...     morphType = allomorphOps.GetMorphType(allomorphs[0])\n            ...     # Get type name\n            ...     wsHandle = project.project.DefaultAnalWs\n            ...     type_name = ITsString(morphType.Name.get_String(wsHandle)).Text\n            ...     print(type_name)\n            stem\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPhoneEnv",
          "signature": "GetPhoneEnv(allomorph_or_hvo)",
          "summary": "Get the phonological environments for an allomorph.",
          "description": "Get the phonological environments for an allomorph.\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO."
            }
          ],
          "returns": "list: List of IPhEnvironment objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If allomorph_or_hvo is None."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorphs = list(allomorphOps.GetAll(entry))\n            >>> if allomorphs:\n            ...     envs = allomorphOps.GetPhoneEnv(allomorphs[0])\n            ...     for env in envs:\n            ...         wsHandle = project.project.DefaultAnalWs\n            ...         name = ITsString(env.Name.get_String(wsHandle)).Text\n            ...         print(f\"Environment: {name}\")\n            Environment: After voiceless consonant\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of an allomorph for comparison.",
          "description": "Get all syncable properties of an allomorph for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IMoForm object (allomorph)."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values: - MultiString properties as dicts {ws: text} - Atomic properties as simple values - Reference Atomic (RA) properties as GUID strings - Does NOT include Owning Sequence (OS) properties ",
          "raises": [],
          "example": "            >>> allo = list(project.Allomorphs.GetAll(entry))[0]\n            >>> props = project.Allomorphs.GetSyncableProperties(allo)\n            >>> print(props['Form'])  # MultiString\n            {'en': 'run', 'fr': 'courir'}\n            >>> print(props['IsAbstract'])  # Boolean\n            True",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemovePhoneEnv",
          "signature": "RemovePhoneEnv(allomorph_or_hvo, env_or_hvo)",
          "summary": "Remove a phonological environment from an allomorph.",
          "description": "Remove a phonological environment from an allomorph.\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO."
            },
            {
              "name": "env_or_hvo",
              "type": "",
              "default": null,
              "description": "The IPhEnvironment object or HVO to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If allomorph_or_hvo or env_or_hvo is None."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorphs = list(allomorphOps.GetAll(entry))\n            >>> if allomorphs:\n            ...     envs = allomorphOps.GetPhoneEnv(allomorphs[0])\n            ...     if envs:\n            ...         # Remove the first environment\n            ...         allomorphOps.RemovePhoneEnv(allomorphs[0], envs[0])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetForm",
          "signature": "SetForm(allomorph_or_hvo, form, wsHandle=None)",
          "summary": "Set the form (text) of an allomorph.",
          "description": "Set the form (text) of an allomorph.\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO."
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The new allomorph form."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If allomorph_or_hvo or form is None.",
            "FP_ParameterError: If form is empty."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorphs = list(allomorphOps.GetAll(entry))\n            >>> if allomorphs:\n            ...     allomorphOps.SetForm(allomorphs[0], \"walked\")\n            ...     print(allomorphOps.GetForm(allomorphs[0]))\n            walked\n\n            >>> # Set IPA pronunciation\n            >>> allomorphOps.SetForm(allomorphs[0], \"wkt\",\n            ...                      project.WSHandle('en-fonipa'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetFormAudio",
          "signature": "SetFormAudio(allomorph_or_hvo, file_path, wsHandle=None)",
          "summary": "Set an audio recording for an allomorph's Form field.",
          "description": "Set an audio recording for an allomorph's Form field.\n\nThis is a convenience method for working with audio writing systems.\nThe audio file is embedded as a file path reference in the Form field\nfor an audio writing system (e.g., en-Zxxx-x-audio).\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO."
            },
            {
              "name": "file_path",
              "type": "",
              "default": null,
              "description": "Path to audio file. This should be either: - A path within LinkedFiles (e.g., \"LinkedFiles/AudioVisual/audio.wav\") - An external path (will be copied to LinkedFiles automatically)"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional audio writing system handle. If None, uses the first audio writing system found in the project."
            }
          ],
          "returns": "str: The internal path where the audio file was stored (relative to project). ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If allomorph_or_hvo or file_path is None.",
            "FP_ParameterError: If no audio writing system is available, or if the",
            "wsHandle provided is not an audio writing system."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorph = list(allomorphOps.GetAll(entry))[0]\n            >>>\n            >>> # Set audio from external file (will be copied to LinkedFiles)\n            >>> audio_path = allomorphOps.SetFormAudio(\n            ...     allomorph,\n            ...     \"/path/to/recordings/pronunciation.wav\"\n            ... )\n            >>> print(f\"Audio stored at: {audio_path}\")\n            LinkedFiles/AudioVisual/pronunciation.wav\n\n            >>> # Set audio with specific audio writing system\n            >>> audio_ws = project.WSHandle('en-Zxxx-x-audio')\n            >>> allomorphOps.SetFormAudio(allomorph, \"/path/to/audio.wav\", audio_ws)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetMorphType",
          "signature": "SetMorphType(allomorph_or_hvo, morphType)",
          "summary": "Set the morpheme type of an allomorph.",
          "description": "Set the morpheme type of an allomorph.\n",
          "parameters": [
            {
              "name": "allomorph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IMoForm object or HVO."
            },
            {
              "name": "morphType",
              "type": "",
              "default": null,
              "description": "The new morpheme type (IMoMorphType object)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If allomorph_or_hvo or morphType is None."
          ],
          "example": "            >>> allomorphOps = AllomorphOperations(project)\n            >>> entry = project.LexiconAllEntries()[0]\n            >>> allomorphs = list(allomorphOps.GetAll(entry))\n            >>> if allomorphs:\n            ...     # Get a different morph type\n            ...     morphTypes = project.lp.MorphTypesOA.PossibilitiesOS\n            ...     prefix_type = [mt for mt in morphTypes\n            ...                    if \"prefix\" in str(mt).lower()][0]\n            ...     allomorphOps.SetMorphType(allomorphs[0], prefix_type)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize AllomorphOperations with a FLExProject instance.",
          "description": "Initialize AllomorphOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "EtymologyOperations": {
      "name": "EtymologyOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.EtymologyOperations",
      "source_file": "Lexicon/EtymologyOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing etymological information in a\nFieldWorks project.",
      "description": "This class provides operations for managing etymological information in a\nFieldWorks project.\n\nEtymology tracking records the historical origin and development of lexical\nentries. Each etymology can specify the source language, etymological form,\ngloss, linguistic commentary, and bibliographic references.\n\nThis class supports historical linguistics workflows including etymology\ndocumentation, loan word tracking, and diachronic analysis.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Access via FLExProject.Etymology property (if configured)\n# Or create directly:\nfrom flexlibs.code.EtymologyOperations import EtymologyOperations\netymOps = EtymologyOperations(project)\n\n# Get an entry\nentry = project.LexEntry.Find(\"computer\")\n\n# Create an etymology\netym = etymOps.Create(\nentry,\nsource=\"English\",\nform=\"compute\",\ngloss=\"to calculate\",\nws=\"en\"\n)\n\n# Set additional information\netymOps.SetComment(etym, \"Borrowed in the 1980s\", \"en\")\netymOps.SetBibliography(etym, \"Smith 2020:145\")\n\n# Get all etymologies\nfor etym in etymOps.GetAll(entry):\nsource = etymOps.GetSource(etym)\nform = etymOps.GetForm(etym)\nprint(f\"From {source}: {form}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two etymologies and return their differences.",
          "description": "Compare two etymologies and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first ILexEtymology object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second ILexEtymology object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional EtymologyOperations instance for item1."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional EtymologyOperations instance for item2."
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(entry_or_hvo, source=None, form=None, gloss=None, ws=None)",
          "summary": "Create a new etymology for a lexical entry.",
          "description": "Create a new etymology for a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO."
            },
            {
              "name": "source",
              "type": "str, optional",
              "default": null,
              "description": "The source language name."
            },
            {
              "name": "form",
              "type": "str, optional",
              "default": null,
              "description": "The etymological form in source language."
            },
            {
              "name": "gloss",
              "type": "str, optional",
              "default": null,
              "description": "The meaning in source language."
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ILexEtymology: The newly created etymology object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If entry_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etym = etymOps.Create(\n            ...     entry,\n            ...     source=\"Greek\",\n            ...     form=\"tele\",\n            ...     gloss=\"far\"\n            ... )\n            >>> print(etymOps.GetForm(etym))\n            tele\n\n            >>> # Create minimal etymology (add details later)\n            >>> etym2 = etymOps.Create(entry)\n            >>> etymOps.SetSource(etym2, \"Greek\")\n            >>> etymOps.SetForm(etym2, \"phone\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(etymology_or_hvo)",
          "summary": "Delete an etymology from its owning entry.",
          "description": "Delete an etymology from its owning entry.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If etymology_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if len(etymologies) > 0:\n            ...     # Delete the last etymology\n            ...     etymOps.Delete(etymologies[-1])\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - All etymology data (source, form, gloss, etc.) is lost\n            - Consider archiving data before deletion\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate an etymology, creating a new copy with a new GUID.",
          "description": "Duplicate an etymology, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source etymology. If False, insert at end of entry's etymology list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (if any exist). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "ILexEtymology: The newly created duplicate etymology with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if etymologies:\n            ...     # Duplicate etymology\n            ...     dup = etymOps.Duplicate(etymologies[0])\n            ...     print(f\"Original: {etymOps.GetGuid(etymologies[0])}\")\n            ...     print(f\"Duplicate: {etymOps.GetGuid(dup)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n            ...\n            ...     # Verify content was copied\n            ...     print(f\"Source: {etymOps.GetSource(dup)}\")\n            ...     print(f\"Form: {etymOps.GetForm(dup)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(entry_or_hvo=None)",
          "summary": "Get all etymologies for a lexical entry, or all etymologies in the entire project.",
          "description": "Get all etymologies for a lexical entry, or all etymologies in the entire project.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO. If None, iterates all etymologies in the entire project."
            }
          ],
          "returns": "ILexEtymology: Each etymology object for the entry (or project). ",
          "raises": [],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> # Get etymologies for specific entry\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> for etym in etymOps.GetAll(entry):\n            ...     source = etymOps.GetSource(etym)\n            ...     form = etymOps.GetForm(etym)\n            ...     gloss = etymOps.GetGloss(etym)\n            ...     print(f\"Etymology: {source} '{form}' ({gloss})\")\n            Etymology: Greek 'tele' (far)\n            Etymology: Greek 'phone' (sound)\n\n            >>> # Get ALL etymologies in entire project\n            >>> for etym in etymOps.GetAll():\n            ...     source = etymOps.GetSource(etym)\n            ...     print(f\"Etymology source: {source}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBibliography",
          "signature": "GetBibliography(etymology_or_hvo)",
          "summary": "Get the bibliographic reference for an etymology.",
          "description": "Get the bibliographic reference for an etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            }
          ],
          "returns": "str: The bibliographic reference, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If etymology_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if etymologies:\n            ...     bib = etymOps.GetBibliography(etymologies[0])\n            ...     print(f\"Source: {bib}\")\n            Source: Smith 2020:145; Jones 2018:234\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetComment",
          "signature": "GetComment(etymology_or_hvo, ws=None)",
          "summary": "Get the linguistic comment for an etymology.",
          "description": "Get the linguistic comment for an etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The comment text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If etymology_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if etymologies:\n            ...     comment = etymOps.GetComment(etymologies[0])\n            ...     print(f\"Note: {comment}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(etymology_or_hvo, ws=None)",
          "summary": "Get the etymological form (the form in the source language).",
          "description": "Get the etymological form (the form in the source language).\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The etymological form, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If etymology_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if etymologies:\n            ...     form = etymOps.GetForm(etymologies[0])\n            ...     source = etymOps.GetSource(etymologies[0])\n            ...     print(f\"{source}: {form}\")\n            Greek: \n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGloss",
          "signature": "GetGloss(etymology_or_hvo, ws=None)",
          "summary": "Get the gloss (meaning in the source language).",
          "description": "Get the gloss (meaning in the source language).\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The gloss text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If etymology_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if etymologies:\n            ...     form = etymOps.GetForm(etymologies[0])\n            ...     gloss = etymOps.GetGloss(etymologies[0])\n            ...     print(f\"'{form}' means '{gloss}'\")\n            'tele' means 'far, distant'\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(etymology_or_hvo)",
          "summary": "Get the GUID (Global Unique Identifier) of an etymology.",
          "description": "Get the GUID (Global Unique Identifier) of an etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            }
          ],
          "returns": "System.Guid: The GUID of the etymology. ",
          "raises": [
            "FP_NullParameterError: If etymology_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if etymologies:\n            ...     guid = etymOps.GetGuid(etymologies[0])\n            ...     print(f\"Etymology GUID: {guid}\")\n            Etymology GUID: 12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLanguage",
          "signature": "GetLanguage(etymology_or_hvo)",
          "summary": "Get the source language of an etymology.",
          "description": "Get the source language of an etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEtymology object or its HVO"
            }
          ],
          "returns": "ICmPossibility: The language possibility object, or None ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"loanword\")\n            >>> etymologies = project.Etymology.GetAll(entry)\n            >>> if etymologies:\n            ...     lang = project.Etymology.GetLanguage(etymologies[0])\n            ...     if lang:\n            ...         print(lang.Name.BestAnalysisAlternative.Text)",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwningEntry",
          "signature": "GetOwningEntry(etymology_or_hvo)",
          "summary": "Get the lexical entry that owns this etymology.",
          "description": "Get the lexical entry that owns this etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            }
          ],
          "returns": "ILexEntry: The owning entry object. ",
          "raises": [
            "FP_NullParameterError: If etymology_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if etymologies:\n            ...     owner = etymOps.GetOwningEntry(etymologies[0])\n            ...     headword = project.LexEntry.GetHeadword(owner)\n            ...     print(f\"Entry: {headword}\")\n            Entry: telephone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSource",
          "signature": "GetSource(etymology_or_hvo, ws=None)",
          "summary": "Get the source language name for an etymology.",
          "description": "Get the source language name for an etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The source language name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If etymology_or_hvo is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if etymologies:\n            ...     source = etymOps.GetSource(etymologies[0])\n            ...     print(f\"Source language: {source}\")\n            Source language: Greek\n\n            >>> # Get in specific writing system\n            >>> source_fr = etymOps.GetSource(etymologies[0], \"fr\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of an etymology for comparison.",
          "description": "Get all syncable properties of an etymology for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values.",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Reorder",
          "signature": "Reorder(entry_or_hvo, etymology_list)",
          "summary": "Reorder etymologies for a lexical entry.",
          "description": "Reorder etymologies for a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO."
            },
            {
              "name": "etymology_list",
              "type": "",
              "default": null,
              "description": "List of ILexEtymology objects or HVOs in desired order."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If entry_or_hvo or etymology_list is None.",
            "FP_ParameterError: If etymology_list doesn't match entry's etymologies."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if len(etymologies) > 1:\n            ...     # Reverse the order\n            ...     etymOps.Reorder(entry, reversed(etymologies))\n            ...     # Verify new order\n            ...     for etym in etymOps.GetAll(entry):\n            ...         print(etymOps.GetSource(etym))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetBibliography",
          "signature": "SetBibliography(etymology_or_hvo, bibliography_text)",
          "summary": "Set the bibliographic reference for an etymology.",
          "description": "Set the bibliographic reference for an etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            },
            {
              "name": "bibliography_text",
              "type": "str",
              "default": null,
              "description": "The bibliographic reference."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If etymology_or_hvo or bibliography_text is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etym = etymOps.Create(entry, source=\"Greek\")\n            >>> etymOps.SetBibliography(etym, \"Smith 2020:145\")\n            >>> print(etymOps.GetBibliography(etym))\n            Smith 2020:145\n\n            >>> # Multiple citations\n            >>> etymOps.SetBibliography(\n            ...     etym,\n            ...     \"Smith 2020:145; Jones 2018:234; Brown 2015:89\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetComment",
          "signature": "SetComment(etymology_or_hvo, text, ws=None)",
          "summary": "Set the linguistic comment for an etymology.",
          "description": "Set the linguistic comment for an etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The comment text."
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If etymology_or_hvo or text is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etym = etymOps.Create(entry, source=\"Greek\", form=\"tele\")\n            >>> etymOps.SetComment(\n            ...     etym,\n            ...     \"Calque from Greek; borrowed in 1830s with invention of technology\"\n            ... )\n\n            >>> # Add comment in multiple languages\n            >>> etymOps.SetComment(\n            ...     etym,\n            ...     \"Calque du grec; emprunt vers 1830\",\n            ...     \"fr\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetForm",
          "signature": "SetForm(etymology_or_hvo, text, ws=None)",
          "summary": "Set the etymological form (the form in the source language).",
          "description": "Set the etymological form (the form in the source language).\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The etymological form."
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If etymology_or_hvo or text is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etym = etymOps.Create(entry)\n            >>> etymOps.SetForm(etym, \"tele\")\n            >>> print(etymOps.GetForm(etym))\n            tele\n\n            >>> # Set reconstructed Proto-Indo-European form\n            >>> etymOps.SetForm(etym, \"*tele-\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetGloss",
          "signature": "SetGloss(etymology_or_hvo, text, ws=None)",
          "summary": "Set the gloss (meaning in the source language).",
          "description": "Set the gloss (meaning in the source language).\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The gloss text."
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If etymology_or_hvo or text is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etym = etymOps.Create(entry)\n            >>> etymOps.SetGloss(etym, \"far, distant\")\n            >>> print(etymOps.GetGloss(etym))\n            far, distant\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLanguage",
          "signature": "SetLanguage(etymology_or_hvo, language)",
          "summary": "Set the source language of an etymology.",
          "description": "Set the source language of an etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEtymology object or its HVO"
            },
            {
              "name": "language",
              "type": "",
              "default": null,
              "description": "ICmPossibility object (language) or None"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If etymology_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"loanword\")\n            >>> etymologies = project.Etymology.GetAll(entry)\n            >>> if etymologies:\n            ...     # Find language possibility (implementation depends on your project structure)\n            ...     # language_obj = ... (get from languages list)\n            ...     # project.Etymology.SetLanguage(etymologies[0], language_obj)\n            ...     pass",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetSource",
          "signature": "SetSource(etymology_or_hvo, text, ws=None)",
          "summary": "Set the source language name for an etymology.",
          "description": "Set the source language name for an etymology.\n",
          "parameters": [
            {
              "name": "etymology_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEtymology object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The source language name."
            },
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If etymology_or_hvo or text is None."
          ],
          "example": "            >>> etymOps = EtymologyOperations(project)\n            >>> entry = project.LexEntry.Find(\"telephone\")\n            >>> etymologies = list(etymOps.GetAll(entry))\n            >>> if etymologies:\n            ...     etymOps.SetSource(etymologies[0], \"Ancient Greek\")\n            ...     print(etymOps.GetSource(etymologies[0]))\n            Ancient Greek\n\n            >>> # Set in multiple writing systems\n            >>> etymOps.SetSource(etymologies[0], \"Grec ancien\", \"fr\")\n            >>> etymOps.SetSource(etymologies[0], \"Griego antiguo\", \"es\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize EtymologyOperations with a FLExProject instance.",
          "description": "Initialize EtymologyOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "ExampleOperations": {
      "name": "ExampleOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.ExampleOperations",
      "source_file": "Lexicon/ExampleOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing example sentences in a FieldWorks project.",
      "description": "This class provides operations for managing example sentences in a FieldWorks project.\n\nExample sentences illustrate the usage of lexical senses in context. Each example\ncan have vernacular text, translations in multiple analysis languages, references\nto source texts, and associated media files.\n\nUsage::\n\nfrom flexlibs import FLExProject, ExampleOperations\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\nexampleOps = ExampleOperations(project)\n\n# Get first entry and sense\nentry = project.LexiconAllEntries().__next__()\nsense = entry.SensesOS[0] if entry.SensesOS.Count > 0 else None\n\n# Get all examples for a sense\nfor example in exampleOps.GetAll(sense):\ntext = exampleOps.GetExample(example)\ntrans = exampleOps.GetTranslation(example)\nprint(f\"Example: {text}\")\nprint(f\"Translation: {trans}\")\n\n# Create a new example\nexample = exampleOps.Create(sense, \"The cat sat on the mat.\")\nexampleOps.SetTranslation(example, \"Le chat s'est assis sur le tapis.\")\nexampleOps.SetReference(example, \"Example Corpus 1.23\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddDoNotPublishIn",
          "signature": "AddDoNotPublishIn(example_or_hvo, publication)",
          "summary": "Add a publication to exclude this example from.",
          "description": "Add a publication to exclude this example from.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexExampleSentence object or its HVO"
            },
            {
              "name": "publication",
              "type": "",
              "default": null,
              "description": "Publication name (str) or ICmPossibility object"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If example_or_hvo or publication is None",
            "FP_ParameterError: If publication name not found"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddMediaFile",
          "signature": "AddMediaFile(example_or_hvo, file_path, label=None)",
          "summary": "Add a media file (typically audio) to an example sentence.",
          "description": "Add a media file (typically audio) to an example sentence.\n\nCopies the file to the project's LinkedFiles directory and creates\na media reference linked to the example.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            },
            {
              "name": "file_path",
              "type": "str",
              "default": null,
              "description": "Path to the external media file to import."
            },
            {
              "name": "label",
              "type": "str, optional",
              "default": null,
              "description": "Descriptive label for the media file."
            }
          ],
          "returns": "ICmFile: The created media file object with proper path. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If example_or_hvo or file_path is None.",
            "FP_ParameterError: If file_path is empty or file doesn't exist."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> example = exampleOps.Create(sense, \"The dog barked loudly.\")\n            >>> # Add audio recording\n            >>> media = exampleOps.AddMediaFile(\n            ...     example,\n            ...     \"/path/to/audio.wav\",\n            ...     label=\"Native speaker pronunciation\"\n            ... )\n            >>> print(f\"Added media file\")\n            Added media file\n\n            >>> # Verify the media was added\n            >>> count = exampleOps.GetMediaCount(example)\n            >>> print(f\"Example now has {count} media file(s)\")\n            Example now has 1 media file(s)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddTranslation",
          "signature": "AddTranslation(example_or_hvo, text, wsHandle=None)",
          "summary": "Add a new translation to an example sentence.",
          "description": "Add a new translation to an example sentence.\n\nThis is an alias for SetTranslation() - both create or update translations.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The translation text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If example_or_hvo or text is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> example = exampleOps.Create(sense, \"Le chien a couru.\")\n            >>> exampleOps.AddTranslation(example, \"The dog ran.\")\n            >>> exampleOps.AddTranslation(example, \"El perro corri.\",\n            ...                            project.WSHandle('es'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two example sentences and return their differences.",
          "description": "Compare two example sentences and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first ILexExampleSentence object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second ILexExampleSentence object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional ExampleOperations instance for item1."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional ExampleOperations instance for item2."
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(sense_or_hvo, example_text, wsHandle=None)",
          "summary": "Create a new example sentence for a lexical sense.",
          "description": "Create a new example sentence for a lexical sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "example_text",
              "type": "str",
              "default": null,
              "description": "The example sentence text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "ILexExampleSentence: The newly created example object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or example_text is None.",
            "FP_ParameterError: If example_text is empty."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> example = exampleOps.Create(sense, \"The cat slept.\")\n            >>> print(exampleOps.GetExample(example))\n            The cat slept.\n\n            >>> # Create with specific writing system\n            >>> example = exampleOps.Create(sense, \"Le chat dort.\",\n            ...                              project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(example_or_hvo)",
          "summary": "Delete an example sentence.",
          "description": "Delete an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if len(examples) > 0:\n            ...     exampleOps.Delete(examples[-1])\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - All translations and associated data are also deleted\n            - Media file links are removed (but files themselves remain)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate an example sentence, creating a new copy with a new GUID.",
          "description": "Duplicate an example sentence, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source example. If False, insert at end of parent's examples list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (translations). If False (default), only copy simple properties."
            }
          ],
          "returns": "ILexExampleSentence: The newly created duplicate example with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     # Shallow duplicate (no translations)\n            ...     dup = exampleOps.Duplicate(examples[0])\n            ...     print(f\"Original: {exampleOps.GetGuid(examples[0])}\")\n            ...     print(f\"Duplicate: {exampleOps.GetGuid(dup)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n            ...\n            ...     # Deep duplicate (includes translations)\n            ...     deep_dup = exampleOps.Duplicate(examples[0], deep=True)\n            ...     trans = exampleOps.GetTranslation(deep_dup)\n            ...     print(f\"Translation: {trans}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(sense_or_hvo=None)",
          "summary": "Get example sentences for a sense or all examples in the project.",
          "description": "Get example sentences for a sense or all examples in the project.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "Optional ILexSense object or HVO. If provided, returns examples for that sense only. If None, returns ALL examples in the entire project."
            }
          ],
          "returns": "ILexExampleSentence: Each example sentence. ",
          "raises": [],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>>\n            >>> # Get examples for a specific sense\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> for example in exampleOps.GetAll(sense):\n            ...     text = exampleOps.GetExample(example)\n            ...     print(f\"Example: {text}\")\n            >>>\n            >>> # Get ALL examples in entire project\n            >>> for example in exampleOps.GetAll():\n            ...     text = exampleOps.GetExample(example)\n            ...     print(f\"Example: {text}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDoNotPublishIn",
          "signature": "GetDoNotPublishIn(example_or_hvo)",
          "summary": "Get the publications this example should not be published in.",
          "description": "Get the publications this example should not be published in.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexExampleSentence object or its HVO"
            }
          ],
          "returns": "list: List of publication names ",
          "raises": [],
          "example": "            >>> sense = list(project.Senses.GetAll())[0]\n            >>> examples = project.Examples.GetAll(sense)\n            >>> if examples:\n            ...     pubs = project.Examples.GetDoNotPublishIn(examples[0])\n            ...     print(pubs)",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetExample",
          "signature": "GetExample(example_or_hvo, wsHandle=None)",
          "summary": "Get the example text of an example sentence.",
          "description": "Get the example text of an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The example text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     text = exampleOps.GetExample(examples[0])\n            ...     print(text)\n            The dog ran quickly.\n\n            >>> # Get in specific writing system\n            >>> text_fr = exampleOps.GetExample(examples[0],\n            ...                                   project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(example_or_hvo)",
          "summary": "Get the GUID of an example sentence.",
          "description": "Get the GUID of an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            }
          ],
          "returns": "System.Guid: The GUID of the example. ",
          "raises": [
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     guid = exampleOps.GetGuid(examples[0])\n            ...     print(f\"Example GUID: {guid}\")\n            Example GUID: 12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLiteralTranslation",
          "signature": "GetLiteralTranslation(example_or_hvo, wsHandle=None)",
          "summary": "Get the literal translation of an example sentence.",
          "description": "Get the literal translation of an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexExampleSentence object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The literal translation text ",
          "raises": [],
          "example": "            >>> sense = list(project.Senses.GetAll())[0]\n            >>> examples = project.Examples.GetAll(sense)\n            >>> if examples:\n            ...     lit_trans = project.Examples.GetLiteralTranslation(examples[0])\n            ...     print(lit_trans)",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMediaCount",
          "signature": "GetMediaCount(example_or_hvo)",
          "summary": "Get the count of media files associated with an example sentence.",
          "description": "Get the count of media files associated with an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            }
          ],
          "returns": "int: The number of media files. ",
          "raises": [
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     count = exampleOps.GetMediaCount(examples[0])\n            ...     print(f\"This example has {count} media files\")\n            This example has 2 media files\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMediaFiles",
          "signature": "GetMediaFiles(example_or_hvo)",
          "summary": "Get all media files associated with an example sentence.",
          "description": "Get all media files associated with an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            }
          ],
          "returns": "list: List of media file objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     media = exampleOps.GetMediaFiles(examples[0])\n            ...     print(f\"Media count: {len(media)}\")\n            Media count: 2\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwningSense",
          "signature": "GetOwningSense(example_or_hvo)",
          "summary": "Get the lexical sense that owns this example sentence.",
          "description": "Get the lexical sense that owns this example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            }
          ],
          "returns": "ILexSense: The owning sense object. ",
          "raises": [
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     owner = exampleOps.GetOwningSense(examples[0])\n            ...     gloss = project.LexiconGetSenseGloss(owner)\n            ...     print(f\"Example belongs to sense: {gloss}\")\n            Example belongs to sense: run (verb)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetReference",
          "signature": "GetReference(example_or_hvo)",
          "summary": "Get the reference (source citation) for an example sentence.",
          "description": "Get the reference (source citation) for an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            }
          ],
          "returns": "str: The reference text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     ref = exampleOps.GetReference(examples[0])\n            ...     print(f\"Reference: {ref}\")\n            Reference: Genesis 1:1\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of an example sentence for comparison.",
          "description": "Get all syncable properties of an example sentence for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values: - MultiString properties as dicts {ws: text} - Atomic properties as simple values - Does NOT include Owning Sequence (OS) properties (translations)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTranslation",
          "signature": "GetTranslation(example_or_hvo, wsHandle=None)",
          "summary": "Get the translation text for a specific writing system.",
          "description": "Get the translation text for a specific writing system.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The translation text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     trans = exampleOps.GetTranslation(examples[0])\n            ...     print(trans)\n            The dog ran quickly.\n\n            >>> # Get Spanish translation\n            >>> trans_es = exampleOps.GetTranslation(examples[0],\n            ...                                       project.WSHandle('es'))\n            >>> print(trans_es)\n            El perro corri rpidamente.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTranslations",
          "signature": "GetTranslations(example_or_hvo)",
          "summary": "Get all translation objects for an example sentence.",
          "description": "Get all translation objects for an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            }
          ],
          "returns": "list: List of ICmTranslation objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     translations = exampleOps.GetTranslations(examples[0])\n            ...     for trans in translations:\n            ...         wsHandle = project.project.DefaultAnalWs\n            ...         text = ITsString(trans.Translation.get_String(wsHandle)).Text\n            ...         print(f\"Translation: {text}\")\n            Translation: The dog ran quickly.\n            Translation: El perro corri rpidamente.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveMediaFile",
          "signature": "MoveMediaFile(media, from_example_or_hvo, to_example_or_hvo)",
          "summary": "Move a media file from one example sentence to another example sentence.",
          "description": "Move a media file from one example sentence to another example sentence.\n\nThis is useful when reorganizing examples or moving audio recordings to the\ncorrect example sentence.\n",
          "parameters": [
            {
              "name": "media",
              "type": "",
              "default": null,
              "description": "ICmFile object to move."
            },
            {
              "name": "from_example_or_hvo",
              "type": "",
              "default": null,
              "description": "Source ILexExampleSentence object or HVO."
            },
            {
              "name": "to_example_or_hvo",
              "type": "",
              "default": null,
              "description": "Destination ILexExampleSentence object or HVO."
            }
          ],
          "returns": "bool: True if media was moved, False if source and destination are same. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If any parameter is None.",
            "FP_ParameterError: If media not in source example's collection."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> # Get two examples from the sense\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if len(examples) >= 2:\n            ...     example1 = examples[0]\n            ...     example2 = examples[1]\n            ...\n            ...     # Get media from first example\n            ...     media_files = exampleOps.GetMediaFiles(example1)\n            ...     if media_files:\n            ...         # Move the first audio file\n            ...         moved = exampleOps.MoveMediaFile(media_files[0], example1, example2)\n            ...         if moved:\n            ...             print(\"Media file moved successfully\")\n            ...\n            ...         # Verify the move\n            ...         count1 = exampleOps.GetMediaCount(example1)\n            ...         count2 = exampleOps.GetMediaCount(example2)\n            ...         print(f\"Example 1 media: {count1}\")\n            ...         print(f\"Example 2 media: {count2}\")\n            Media file moved successfully\n            Example 1 media: 0\n            Example 2 media: 1\n\n            >>> # Can also move between different senses\n            >>> other_sense = entry.SensesOS[1] if entry.SensesOS.Count > 1 else None\n            >>> if other_sense:\n            ...     other_examples = list(exampleOps.GetAll(other_sense))\n            ...     if other_examples:\n            ...         other_example = other_examples[0]\n            ...         media_files = exampleOps.GetMediaFiles(example2)\n            ...         if media_files:\n            ...             exampleOps.MoveMediaFile(media_files[0], example2, other_example)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveDoNotPublishIn",
          "signature": "RemoveDoNotPublishIn(example_or_hvo, publication)",
          "summary": "Remove a publication from the exclude list for this example.",
          "description": "Remove a publication from the exclude list for this example.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexExampleSentence object or its HVO"
            },
            {
              "name": "publication",
              "type": "",
              "default": null,
              "description": "Publication name (str) or ICmPossibility object"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If example_or_hvo or publication is None",
            "FP_ParameterError: If publication name not found"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveMediaFile",
          "signature": "RemoveMediaFile(example_or_hvo, media_or_hvo)",
          "summary": "Remove a media file from an example sentence.",
          "description": "Remove a media file from an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            },
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmFile object or HVO to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If example_or_hvo or media_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     media_files = exampleOps.GetMediaFiles(examples[0])\n            ...     if media_files:\n            ...         exampleOps.RemoveMediaFile(examples[0], media_files[0])\n            ...         print(\"Media file removed\")\n            Media file removed\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveTranslation",
          "signature": "RemoveTranslation(example_or_hvo, wsHandle=None)",
          "summary": "Remove the translation for a specific writing system.",
          "description": "Remove the translation for a specific writing system.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If example_or_hvo is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     # Remove English translation\n            ...     exampleOps.RemoveTranslation(examples[0])\n            ...     # Remove Spanish translation\n            ...     exampleOps.RemoveTranslation(examples[0],\n            ...                                   project.WSHandle('es'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Reorder",
          "signature": "Reorder(sense_or_hvo, example_list)",
          "summary": "Reorder the examples for a sense.",
          "description": "Reorder the examples for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "example_list",
              "type": "",
              "default": null,
              "description": "List of ILexExampleSentence objects or HVOs in desired order."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or example_list is None.",
            "FP_ParameterError: If example_list doesn't contain all examples or",
            "contains examples not belonging to this sense."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> # Reverse the order\n            >>> exampleOps.Reorder(sense, reversed(examples))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetExample",
          "signature": "SetExample(example_or_hvo, text, wsHandle=None)",
          "summary": "Set the example text of an example sentence.",
          "description": "Set the example text of an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new example text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If example_or_hvo or text is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> examples = list(exampleOps.GetAll(sense))\n            >>> if examples:\n            ...     exampleOps.SetExample(examples[0], \"The cat ran quickly.\")\n            ...     print(exampleOps.GetExample(examples[0]))\n            The cat ran quickly.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLiteralTranslation",
          "signature": "SetLiteralTranslation(example_or_hvo, text, wsHandle=None)",
          "summary": "Set the literal translation of an example sentence.",
          "description": "Set the literal translation of an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexExampleSentence object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The literal translation text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If example_or_hvo or text is None"
          ],
          "example": "            >>> sense = list(project.Senses.GetAll())[0]\n            >>> examples = project.Examples.GetAll(sense)\n            >>> if examples:\n            ...     project.Examples.SetLiteralTranslation(examples[0], \"word-for-word translation\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetReference",
          "signature": "SetReference(example_or_hvo, reference_text)",
          "summary": "Set the reference (source citation) for an example sentence.",
          "description": "Set the reference (source citation) for an example sentence.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            },
            {
              "name": "reference_text",
              "type": "str",
              "default": null,
              "description": "The reference text (e.g., \"Genesis 1:1\")."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If example_or_hvo or reference_text is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> example = exampleOps.Create(sense, \"In the beginning...\")\n            >>> exampleOps.SetReference(example, \"Genesis 1:1\")\n            >>> print(exampleOps.GetReference(example))\n            Genesis 1:1\n\n            >>> # Corpus reference\n            >>> exampleOps.SetReference(example, \"Corpus A, Text 3, Line 12\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetTranslation",
          "signature": "SetTranslation(example_or_hvo, text, wsHandle=None)",
          "summary": "Set the translation text for a specific writing system.",
          "description": "Set the translation text for a specific writing system.\n\nCreates a translation object if one doesn't exist for the writing system.\n",
          "parameters": [
            {
              "name": "example_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexExampleSentence object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The translation text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If example_or_hvo or text is None."
          ],
          "example": "            >>> exampleOps = ExampleOperations(project)\n            >>> entry = project.LexiconAllEntries().__next__()\n            >>> sense = entry.SensesOS[0]\n            >>> example = exampleOps.Create(sense, \"El gato durmi.\")\n            >>> exampleOps.SetTranslation(example, \"The cat slept.\")\n            >>> print(exampleOps.GetTranslation(example))\n            The cat slept.\n\n            >>> # Set French translation\n            >>> exampleOps.SetTranslation(example, \"Le chat a dormi.\",\n            ...                            project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ExampleOperations with a FLExProject instance.",
          "description": "Initialize ExampleOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "LexEntryOperations": {
      "name": "LexEntryOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.LexEntryOperations",
      "source_file": "Lexicon/LexEntryOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing lexical entries in a\nFieldWorks project.",
      "description": "This class provides operations for managing lexical entries in a\nFieldWorks project.\n\nLexical entries are the fundamental units of the lexicon, representing\nwords, morphemes, or other lexical items. Each entry has forms (lexeme,\ncitation, alternate), senses (meanings), and various properties.\n\nThis class should be accessed via FLExProject.LexEntry property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all entries\nfor entry in project.LexEntry.GetAll():\nheadword = project.LexEntry.GetHeadword(entry)\nprint(headword)\n\n# Create a new entry\nentry = project.LexEntry.Create(\"run\", \"stem\")\n\n# Add a sense\nproject.LexEntry.AddSense(entry, \"to move rapidly on foot\", \"en\")\n\n# Set citation form\nproject.LexEntry.SetCitationForm(entry, \"run\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddComplexFormComponent",
          "signature": "AddComplexFormComponent(complex_entry_or_hvo, component_or_hvo)",
          "summary": "Add a component to a complex form (compound, idiom, phrasal verb).",
          "description": "Add a component to a complex form (compound, idiom, phrasal verb).\n\nThis is a convenience method that wraps FLEx's AddComponent logic.\nIf the complex entry doesn't have an EntryRef yet, one is created.\n",
          "parameters": [
            {
              "name": "complex_entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The complex form entry (or HVO)"
            },
            {
              "name": "component_or_hvo",
              "type": "",
              "default": null,
              "description": "The component entry or sense (or HVO)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project not opened with write enabled",
            "FP_NullParameterError: If either parameter is None",
            "FP_ParameterError: If component is not an entry or sense"
          ],
          "example": "            >>> # Create \"kick the bucket\" idiom\n            >>> kick = project.LexEntry.Find(\"kick\")\n            >>> bucket = project.LexEntry.Find(\"bucket\")\n            >>> idiom = project.LexEntry.Create(\"kick the bucket\")\n            >>> project.LexEntry.AddComplexFormComponent(idiom, kick)\n            >>> project.LexEntry.AddComplexFormComponent(idiom, bucket)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddDoNotPublishIn",
          "signature": "AddDoNotPublishIn(entry_or_hvo, publication)",
          "summary": "Add a publication to exclude this entry from.",
          "description": "Add a publication to exclude this entry from.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "publication",
              "type": "",
              "default": null,
              "description": "Publication name (str) or ICmPossibility object"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddDoNotShowMainEntryIn",
          "signature": "AddDoNotShowMainEntryIn(entry_or_hvo, publication)",
          "summary": "Add a publication to not show this entry as main entry.",
          "description": "Add a publication to not show this entry as main entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "publication",
              "type": "",
              "default": null,
              "description": "Publication name (str) or ICmPossibility object"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddSense",
          "signature": "AddSense(entry_or_hvo, gloss, wsHandle=None)",
          "summary": "Add a new sense to a lexical entry.",
          "description": "Add a new sense to a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "gloss",
              "type": "str",
              "default": null,
              "description": "The gloss text for the new sense"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ILexSense: The newly created sense object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or gloss is None",
            "FP_ParameterError: If gloss is empty"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> sense = project.LexEntry.AddSense(entry, \"to move rapidly on foot\")\n            >>> gloss = project.LexiconGetSenseGloss(sense)\n            >>> print(gloss)\n            to move rapidly on foot\n\n            >>> # Add sense in specific writing system\n            >>> sense_fr = project.LexEntry.AddSense(entry, \"courir\",\n            ...                                       project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two lexical entries and return their differences.",
          "description": "Compare two lexical entries and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first ILexEntry object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second ILexEntry object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional LexEntryOperations instance for item1."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional LexEntryOperations instance for item2."
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(lexeme_form, morph_type_name=None, wsHandle=None, create_blank_sense=True)",
          "summary": "Create a new lexical entry in the FLEx project.",
          "description": "Create a new lexical entry in the FLEx project.\n",
          "parameters": [
            {
              "name": "lexeme_form",
              "type": "str",
              "default": null,
              "description": "The lexeme form (headword) of the entry"
            },
            {
              "name": "morph_type_name",
              "type": "str, optional",
              "default": null,
              "description": "Name of the morph type (\"stem\", \"root\", \"prefix\", \"suffix\", etc.). If None (default), uses \"stem\". Use \"prefix\", \"suffix\", \"infix\" for affixes (creates MoAffixAllomorph). Use \"stem\", \"root\", \"clitic\", etc. for stems (creates MoStemAllomorph)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            },
            {
              "name": "create_blank_sense",
              "type": "bool",
              "default": true,
              "description": "If True (default), creates a blank sense automatically, matching FLEx GUI behavior. Set to False to create entry without senses."
            }
          ],
          "returns": "ILexEntry: The newly created lexical entry object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If lexeme_form is None",
            "FP_ParameterError: If lexeme_form is empty or morph type not found"
          ],
          "example": "            >>> # Create a basic stem entry with blank sense (default - no type needed!)\n            >>> entry = project.LexEntry.Create(\"run\")\n            >>> print(project.LexEntry.GetHeadword(entry))\n            run\n            >>> print(project.LexEntry.GetSenseCount(entry))\n            1\n\n            >>> # Create entry without sense\n            >>> entry = project.LexEntry.Create(\"run\", create_blank_sense=False)\n            >>> print(project.LexEntry.GetSenseCount(entry))\n            0\n\n            >>> # Create an affix entry (auto-creates MoAffixAllomorph)\n            >>> suffix = project.LexEntry.Create(\"-ing\", \"suffix\")\n            >>> print(suffix.LexemeFormOA.ClassName)\n            MoAffixAllomorph\n\n            >>> # Create with specific writing system\n            >>> entry = project.LexEntry.Create(\"maison\", \"stem\",\n            ...                                  project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(entry_or_hvo)",
          "summary": "Delete a lexical entry from the FLEx project.",
          "description": "Delete a lexical entry from the FLEx project.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO (database ID)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo is None",
            "FP_ParameterError: If entry doesn't exist"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"obsolete\")\n            >>> if entry:\n            ...     project.LexEntry.Delete(entry)\n\n            >>> # Delete by HVO\n            >>> project.LexEntry.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - All senses, forms, and relations will be deleted\n            - References from other entries may become invalid\n            - Cannot be undone\n            - Entry will be removed from all texts and analyses\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a lexical entry, creating a new entry with the same properties.",
          "description": "Duplicate a lexical entry, creating a new entry with the same properties.\n\nThis method creates a copy of an existing entry. With deep=False, only\nthe entry shell (lexeme form, citation form, morph type) is duplicated.\nWith deep=True, all owned objects (senses, allomorphs, pronunciations,\netymologies, variants) are recursively duplicated.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO (database ID)"
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True, insert the new entry after the original in the lexicon. If False, append to the end. Note: FLEx lexicon is typically sorted alphabetically, so this may have limited effect."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If False, only duplicate the entry shell (lexeme form, citation form, morph type). If True, recursively duplicate all owned objects (senses, allomorphs, pronunciations, etymologies)."
            }
          ],
          "returns": "ILexEntry: The newly created duplicate entry ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If item_or_hvo is None",
            "FP_ParameterError: If entry doesn't exist"
          ],
          "example": "            >>> # Shallow duplicate (entry shell only)\n            >>> entry = project.LexEntry.Find(\"run\")\n            >>> duplicate = project.LexEntry.Duplicate(entry, deep=False)\n            >>> print(project.LexEntry.GetLexemeForm(duplicate))\n            run\n            >>> print(project.LexEntry.GetSenseCount(duplicate))\n            0\n\n            >>> # Deep duplicate (with all content)\n            >>> entry = project.LexEntry.Find(\"walk\")\n            >>> duplicate = project.LexEntry.Duplicate(entry, deep=True)\n            >>> print(project.LexEntry.GetSenseCount(duplicate))\n            3\n\n        Warning:\n            - deep=True for LexEntry can be slow for complex entries with many\n              senses, subsenses, and examples\n            - The duplicate will have identical content but a new GUID\n            - Homograph numbers are not automatically assigned - you may need\n              to call SetHomographNumber() to distinguish duplicates\n            - Cross-references to other entries are NOT duplicated (to avoid\n              creating invalid references)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(lexeme_form, wsHandle=None)",
          "summary": "Check if a lexical entry with the given lexeme form exists.",
          "description": "Check if a lexical entry with the given lexeme form exists.\n",
          "parameters": [
            {
              "name": "lexeme_form",
              "type": "str",
              "default": null,
              "description": "The lexeme form to search for"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "bool: True if an entry exists with this lexeme form, False otherwise ",
          "raises": [
            "FP_NullParameterError: If lexeme_form is None"
          ],
          "example": "            >>> if not project.LexEntry.Exists(\"run\"):\n            ...     entry = project.LexEntry.Create(\"run\")\n            >>>\n            >>> # Check in specific writing system\n            >>> if project.LexEntry.Exists(\"maison\", project.WSHandle('fr')):\n            ...     print(\"French entry exists\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(lexeme_form, wsHandle=None)",
          "summary": "Find a lexical entry by its lexeme form.",
          "description": "Find a lexical entry by its lexeme form.\n",
          "parameters": [
            {
              "name": "lexeme_form",
              "type": "str",
              "default": null,
              "description": "The lexeme form to search for"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "ILexEntry or None: The entry object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If lexeme_form is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> if entry:\n            ...     headword = project.LexEntry.GetHeadword(entry)\n            ...     print(f\"Found: {headword}\")\n            Found: run\n\n            >>> # Search in specific writing system\n            >>> entry = project.LexEntry.Find(\"maison\", project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all lexical entries in the project.",
          "description": "Get all lexical entries in the project.\n\nThis method returns an iterator over all ILexEntry objects in the\nproject database, allowing iteration over the complete lexicon.\n",
          "parameters": [],
          "returns": "ILexEntry: Each lexical entry object in the project ",
          "raises": [],
          "example": "            >>> for entry in project.LexEntry.GetAll():\n            ...     headword = project.LexEntry.GetHeadword(entry)\n            ...     senses = project.LexEntry.GetSenseCount(entry)\n            ...     print(f\"{headword} ({senses} senses)\")\n            run (3 senses)\n            walk (2 senses)\n            house (4 senses)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllSenses",
          "signature": "GetAllSenses(entry_or_hvo)",
          "summary": "Get all senses owned by this entry, including subsenses recursively.",
          "description": "Get all senses owned by this entry, including subsenses recursively.\n\nReturns all senses in a flattened list, recursively including all\nsubsenses at any depth.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "list: List of ILexSense objects (all senses and subsenses) ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> all_senses = project.LexEntry.GetAllSenses(entry)\n            >>> print(f\"Total senses (including subsenses): {len(all_senses)}\")\n            >>> for sense in all_senses:\n            ...     gloss = project.Senses.GetGloss(sense)\n            ...     depth = len(list(sense.PathToRoot)) - 2  # Approximate depth\n            ...     indent = \"  \" * depth\n            ...     print(f\"{indent}{gloss}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAvailableMorphTypes",
          "signature": "GetAvailableMorphTypes(include_subcategories=True)",
          "summary": "Get a list of all available morph types in the project.",
          "description": "Get a list of all available morph types in the project.\n",
          "parameters": [
            {
              "name": "include_subcategories",
              "type": "bool",
              "default": true,
              "description": "If True (default), includes subcategories. If False, only returns top-level morph types."
            }
          ],
          "returns": "list: List of tuples (name, IMoMorphType, is_stem_type) where: - name (str): The morph type name - IMoMorphType: The morph type object - is_stem_type (bool): True if stem type, False if affix type ",
          "raises": [],
          "example": "            >>> morph_types = project.LexEntry.GetAvailableMorphTypes()\n            >>> for name, mt, is_stem in morph_types:\n            ...     type_str = \"stem\" if is_stem else \"affix\"\n            ...     print(f\"{name}: {type_str}\")\n            stem: stem\n            root: stem\n            prefix: affix\n            suffix: affix\n            infix: affix\n\n            >>> # Get only top-level types\n            >>> top_level = project.LexEntry.GetAvailableMorphTypes(include_subcategories=False)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBestVernacularAlternative",
          "signature": "GetBestVernacularAlternative(entry_or_hvo)",
          "summary": "Get best available vernacular form (Pattern 5 - fallback logic).",
          "description": "Get best available vernacular form (Pattern 5 - fallback logic).\n\nReturns the \"best\" vernacular form for the entry using FLEx's standard\nfallback logic: Citation Form  Lexeme Form  Headword.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "str: The best available vernacular form ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> best_form = project.LexEntry.GetBestVernacularAlternative(entry)\n            >>> print(best_form)\n            run\n\n            >>> # Useful for display when you want the \"best\" form\n            >>> for entry in project.LexiconAllEntries():\n            ...     form = project.LexEntry.GetBestVernacularAlternative(entry)\n            ...     print(form)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBibliography",
          "signature": "GetBibliography(entry_or_hvo, wsHandle=None)",
          "summary": "Get the bibliography of a lexical entry.",
          "description": "Get the bibliography of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The bibliography text ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"anthropology\")\n            >>> bib = project.LexEntry.GetBibliography(entry)\n            >>> print(bib)\n            Smith 2015: 42-43",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCitationForm",
          "signature": "GetCitationForm(entry_or_hvo, wsHandle=None)",
          "summary": "Get the citation form of a lexical entry.",
          "description": "Get the citation form of a lexical entry.\n\nThe citation form is used for dictionary ordering and citations.\nIt may differ from the lexeme form (e.g., infinitive vs. stem).\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The citation form text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> citation = project.LexEntry.GetCitationForm(entry)\n            >>> print(citation)\n            run\n\n            >>> # For verbs, citation might be infinitive\n            >>> verb = project.LexEntry.Find(\"am\")\n            >>> print(project.LexEntry.GetCitationForm(verb))\n            be\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetComment",
          "signature": "GetComment(entry_or_hvo, wsHandle=None)",
          "summary": "Get the comment of a lexical entry.",
          "description": "Get the comment of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The comment text",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetComplexFormComponents",
          "signature": "GetComplexFormComponents(complex_entry_or_hvo)",
          "summary": "Get all components of a complex form.",
          "description": "Get all components of a complex form.\n",
          "parameters": [
            {
              "name": "complex_entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The complex form entry (or HVO)"
            }
          ],
          "returns": "list: List of ILexEntry or ILexSense objects (components) ",
          "raises": [],
          "example": "            >>> idiom = project.LexEntry.Find(\"kick the bucket\")\n            >>> components = project.LexEntry.GetComplexFormComponents(idiom)\n            >>> for comp in components:\n            ...     if isinstance(comp, ILexEntry):\n            ...         print(project.LexEntry.GetHeadword(comp))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetComplexFormsNotSubentries",
          "signature": "GetComplexFormsNotSubentries(entry_or_hvo)",
          "summary": "Get complex forms that reference this entry, excluding subentries.",
          "description": "Get complex forms that reference this entry, excluding subentries.\n\nReturns complex forms (compounds, idioms, etc.) but excludes any\nwhere this entry appears as a subentry (in PrimaryLexemesRS).\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "list: List of ILexEntryRef objects (complex forms, excluding subentries) ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> complex_forms = project.LexEntry.GetComplexFormsNotSubentries(entry)\n            >>> for lex_ref in complex_forms:\n            ...     cf_entry = lex_ref.OwningEntry\n            ...     print(f\"Complex form: {project.LexEntry.GetHeadword(cf_entry)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(entry_or_hvo)",
          "summary": "Get the creation date of a lexical entry.",
          "description": "Get the creation date of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "System.DateTime: The date and time the entry was created ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> created = project.LexEntry.GetDateCreated(entry)\n            >>> print(f\"Created: {created}\")\n            Created: 2025-01-15 14:30:22\n\n            >>> # Format the date\n            >>> from datetime import datetime\n            >>> dt = datetime(created.Year, created.Month, created.Day)\n            >>> print(dt.strftime(\"%Y-%m-%d\"))\n            2025-01-15\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified(entry_or_hvo)",
          "summary": "Get the last modification date of a lexical entry.",
          "description": "Get the last modification date of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "System.DateTime: The date and time the entry was last modified ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> modified = project.LexEntry.GetDateModified(entry)\n            >>> print(f\"Last modified: {modified}\")\n            Last modified: 2025-01-20 09:15:43\n\n            >>> # Check if recently modified\n            >>> from datetime import datetime, timedelta\n            >>> mod_dt = datetime(modified.Year, modified.Month, modified.Day)\n            >>> if datetime.now() - mod_dt < timedelta(days=7):\n            ...     print(\"Modified in the last week\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDoNotPublishIn",
          "signature": "GetDoNotPublishIn(entry_or_hvo)",
          "summary": "Get the publications this entry should not be published in.",
          "description": "Get the publications this entry should not be published in.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "list: List of publication names ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"obscure\")\n            >>> pubs = project.LexEntry.GetDoNotPublishIn(entry)\n            >>> print(pubs)\n            ['Main Dictionary', 'Student Edition']",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDoNotShowMainEntryIn",
          "signature": "GetDoNotShowMainEntryIn(entry_or_hvo)",
          "summary": "Get the publications where this entry should not be shown as main entry.",
          "description": "Get the publications where this entry should not be shown as main entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "list: List of publication names",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDoNotUseForParsing",
          "signature": "GetDoNotUseForParsing(entry_or_hvo)",
          "summary": "Check if an entry is excluded from parsing.",
          "description": "Check if an entry is excluded from parsing.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "bool: True if excluded from parsing, False otherwise",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetExcludeAsHeadword",
          "signature": "GetExcludeAsHeadword(entry_or_hvo)",
          "summary": "Check if an entry is excluded as a headword.",
          "description": "Check if an entry is excluded as a headword.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "bool: True if excluded as headword, False otherwise",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(entry_or_hvo)",
          "summary": "Get the GUID (Globally Unique Identifier) of a lexical entry.",
          "description": "Get the GUID (Globally Unique Identifier) of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "System.Guid: The entry's GUID ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> guid = project.LexEntry.GetGuid(entry)\n            >>> print(guid)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\n            >>> # Get as string\n            >>> guid_str = str(guid)\n            >>> print(guid_str)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\n            >>> # Use GUID to retrieve entry later\n            >>> entry2 = project.Object(guid)\n            >>> print(project.LexEntry.GetHeadword(entry2))\n            run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetHeadword",
          "signature": "GetHeadword(entry_or_hvo)",
          "summary": "Get the headword (display form) of a lexical entry.",
          "description": "Get the headword (display form) of a lexical entry.\n\nThe headword is the primary display form shown in lexicon views,\ncombining the lexeme form with homograph numbers if applicable.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "str: The headword string (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> headword = project.LexEntry.GetHeadword(entry)\n            >>> print(headword)\n            run\n\n            >>> # Entry with homograph number\n            >>> bank1 = project.LexEntry.Find(\"bank\")  # financial institution\n            >>> print(project.LexEntry.GetHeadword(bank1))\n            bank\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetHomographNumber",
          "signature": "GetHomographNumber(entry_or_hvo)",
          "summary": "Get the homograph number of a lexical entry.",
          "description": "Get the homograph number of a lexical entry.\n\nHomograph numbers distinguish entries with identical forms\n(e.g., \"bank\" for river bank vs. \"bank\" for financial institution).\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "int: The homograph number (0 if not set) ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> bank1 = project.LexEntry.Find(\"bank\")  # first entry\n            >>> num = project.LexEntry.GetHomographNumber(bank1)\n            >>> print(num)\n            1\n\n            >>> # Entries without homographs have number 0\n            >>> unique = project.LexEntry.Find(\"unique\")\n            >>> print(project.LexEntry.GetHomographNumber(unique))\n            0\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetImportResidue",
          "signature": "GetImportResidue(entry_or_hvo)",
          "summary": "Get the import residue of a lexical entry.",
          "description": "Get the import residue of a lexical entry.\n\nImport residue stores unparsed data from imports (e.g., LIFT, SFM)\nthat couldn't be mapped to FLEx fields.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "str: The import residue text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> residue = project.LexEntry.GetImportResidue(entry)\n            >>> if residue:\n            ...     print(f\"Import residue: {residue}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLIFTid",
          "signature": "GetLIFTid(entry_or_hvo)",
          "summary": "Get LIFT XML identifier for entry (Pattern 2 - computed property).",
          "description": "Get LIFT XML identifier for entry (Pattern 2 - computed property).\n\nReturns the identifier used in LIFT (Lexicon Interchange FormaT) export.\nThis is typically based on the entry's GUID.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "str: LIFT identifier (GUID as string) ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> lift_id = project.LexEntry.GetLIFTid(entry)\n            >>> print(lift_id)\n            12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLexemeForm",
          "signature": "GetLexemeForm(entry_or_hvo, wsHandle=None)",
          "summary": "Get the lexeme form of a lexical entry.",
          "description": "Get the lexeme form of a lexical entry.\n\nThe lexeme form is the primary underlying form of the entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The lexeme form text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> lexeme = project.LexEntry.GetLexemeForm(entry)\n            >>> print(lexeme)\n            run\n\n            >>> # Get in specific writing system\n            >>> lexeme_fr = project.LexEntry.GetLexemeForm(entry,\n            ...                                             project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLiteralMeaning",
          "signature": "GetLiteralMeaning(entry_or_hvo, wsHandle=None)",
          "summary": "Get the literal meaning of a lexical entry.",
          "description": "Get the literal meaning of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The literal meaning text",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLongName",
          "signature": "GetLongName(entry_or_hvo, wsHandle=None)",
          "summary": "Get long display name for entry (Pattern 2 - computed property).",
          "description": "Get long display name for entry (Pattern 2 - computed property).\n\nReturns a more descriptive form including additional context,\ntypically headword + gloss or definition.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: Long name for display ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> long_name = project.LexEntry.GetLongName(entry)\n            >>> print(long_name)\n            run (to move swiftly)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMinimalLexReferences",
          "signature": "GetMinimalLexReferences(entry_or_hvo)",
          "summary": "Get essential lexical references for this entry.",
          "description": "Get essential lexical references for this entry.\n\nReturns only \"minimal\" lexical references - those that are multi-target\nor have specific mapping types (sequence types).\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "list: List of ILexReference objects (minimal references) ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"big\")\n            >>> lex_refs = project.LexEntry.GetMinimalLexReferences(entry)\n            >>> for lex_ref in lex_refs:\n            ...     ref_type = lex_ref.Owner  # ILexRefType\n            ...     print(f\"Reference type: {ref_type.Name.BestAnalysisAlternative.Text}\")\n            ...     for target in lex_ref.TargetsRS:\n            ...         if target.Hvo != entry.Hvo:\n            ...             print(f\"  -> {project.LexEntry.GetHeadword(target)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMorphType",
          "signature": "GetMorphType(entry_or_hvo)",
          "summary": "Get the morph type of a lexical entry's lexeme form.",
          "description": "Get the morph type of a lexical entry's lexeme form.\n\nThe morph type indicates the morphological category (stem, root,\nprefix, suffix, etc.).\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "IMoMorphType or None: The morph type object, or None if not set ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> morph_type = project.LexEntry.GetMorphType(entry)\n            >>> if morph_type:\n            ...     print(ITsString(morph_type.Name.BestAnalysisAlternative).Text)\n            stem\n\n            >>> # Check if entry is an affix\n            >>> suffix = project.LexEntry.Find(\"-ing\")\n            >>> mt = project.LexEntry.GetMorphType(suffix)\n            >>> if mt:\n            ...     name = ITsString(mt.Name.BestAnalysisAlternative).Text\n            ...     if name in (\"prefix\", \"suffix\", \"infix\"):\n            ...         print(\"This is an affix\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRestrictions",
          "signature": "GetRestrictions(entry_or_hvo, wsHandle=None)",
          "summary": "Get the restrictions of a lexical entry.",
          "description": "Get the restrictions of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The restrictions text",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSenseCount",
          "signature": "GetSenseCount(entry_or_hvo)",
          "summary": "Get the count of senses for a lexical entry.",
          "description": "Get the count of senses for a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "int: The number of senses (0 if none) ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> count = project.LexEntry.GetSenseCount(entry)\n            >>> print(f\"Entry has {count} senses\")\n            Entry has 3 senses\n\n            >>> # Check if entry has senses\n            >>> if project.LexEntry.GetSenseCount(entry) == 0:\n            ...     print(\"Entry has no senses - add one!\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSenses",
          "signature": "GetSenses(entry_or_hvo)",
          "summary": "Get all senses of a lexical entry.",
          "description": "Get all senses of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "list: List of ILexSense objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> senses = project.LexEntry.GetSenses(entry)\n            >>> for sense in senses:\n            ...     gloss = project.LexiconGetSenseGloss(sense)\n            ...     print(f\"Sense: {gloss}\")\n            Sense: to move rapidly on foot\n            Sense: to operate or function\n            Sense: a point scored in baseball\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetShortName",
          "signature": "GetShortName(entry_or_hvo, wsHandle=None)",
          "summary": "Get short display name for entry (Pattern 2 - computed property).",
          "description": "Get short display name for entry (Pattern 2 - computed property).\n\nReturns an abbreviated form suitable for UI display, typically\nthe headword without additional formatting.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: Short name for display ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> short_name = project.LexEntry.GetShortName(entry)\n            >>> print(short_name)\n            run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSummaryDefinition",
          "signature": "GetSummaryDefinition(entry_or_hvo, wsHandle=None)",
          "summary": "Get the summary definition of a lexical entry.",
          "description": "Get the summary definition of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The summary definition text",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a lexical entry for comparison.",
          "description": "Get all syncable properties of a lexical entry for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ILexEntry object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values.",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetVisibleComplexFormBackRefs",
          "signature": "GetVisibleComplexFormBackRefs(entry_or_hvo)",
          "summary": "Get all complex forms that reference this entry.",
          "description": "Get all complex forms that reference this entry.\n\nReturns all LexEntryRef objects where this entry appears in\nShowComplexFormsIn and RefType is ComplexForm.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            }
          ],
          "returns": "list: List of ILexEntryRef objects (complex forms referencing this entry) ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> complex_forms = project.LexEntry.GetVisibleComplexFormBackRefs(entry)\n            >>> for lex_ref in complex_forms:\n            ...     complex_entry = lex_ref.OwningEntry\n            ...     print(f\"Complex form: {project.LexEntry.GetHeadword(complex_entry)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MergeObject",
          "signature": "MergeObject(survivor_or_hvo, victim_or_hvo, fLoseNoStringData=True)",
          "summary": "Merge one entry into another (IRREVERSIBLE operation).",
          "description": "Merge one entry into another (IRREVERSIBLE operation).\n\nThis method merges all data from the victim entry into the survivor entry,\nthen deletes the victim. This is a complex operation that handles:\n- Lexeme form differences (creates alternates if needed)\n- Homograph renumbering\n- Circular reference prevention\n- Component replacement in complex forms\n- Back-reference updating\n- Data preservation based on fLoseNoStringData flag\n",
          "parameters": [
            {
              "name": "survivor_or_hvo",
              "type": "",
              "default": null,
              "description": "Entry that will receive merged data (HVO or ILexEntry)"
            },
            {
              "name": "victim_or_hvo",
              "type": "",
              "default": null,
              "description": "Entry that will be deleted after merge (HVO or ILexEntry)"
            },
            {
              "name": "fLoseNoStringData",
              "type": "bool",
              "default": true,
              "description": "If True, concatenate strings (preserve both values); If False, overwrite strings (victim overwrites survivor)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project not write-enabled",
            "FP_NullParameterError: If either parameter is None",
            "FP_ParameterError: If entries are not compatible for merging"
          ],
          "example": "            >>> # Merge duplicate entry into main entry\n            >>> main = project.LexEntry.Find(\"run\")\n            >>> duplicate = project.LexEntry.Find(\"run\")  # Duplicate with same form\n            >>> project.LexEntry.MergeObject(main, duplicate)\n            >>> # 'duplicate' is now deleted, all data merged into 'main'\n\n            >>> # Merge with different lexeme forms (creates alternate)\n            >>> entry1 = project.LexEntry.Find(\"color\")\n            >>> entry2 = project.LexEntry.Find(\"colour\")\n            >>> project.LexEntry.MergeObject(entry1, entry2)\n            >>> # 'colour' becomes alternate form of 'color'\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveComplexFormComponent",
          "signature": "RemoveComplexFormComponent(complex_entry_or_hvo, component_or_hvo)",
          "summary": "Remove a component from a complex form.",
          "description": "Remove a component from a complex form.\n",
          "parameters": [
            {
              "name": "complex_entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The complex form entry (or HVO)"
            },
            {
              "name": "component_or_hvo",
              "type": "",
              "default": null,
              "description": "The component entry or sense to remove (or HVO)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project not opened with write enabled",
            "FP_NullParameterError: If either parameter is None"
          ],
          "example": "            >>> idiom = project.LexEntry.Find(\"kick the bucket\")\n            >>> bucket = project.LexEntry.Find(\"bucket\")\n            >>> project.LexEntry.RemoveComplexFormComponent(idiom, bucket)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveDoNotPublishIn",
          "signature": "RemoveDoNotPublishIn(entry_or_hvo, publication)",
          "summary": "Remove a publication from the exclude list.",
          "description": "Remove a publication from the exclude list.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "publication",
              "type": "",
              "default": null,
              "description": "Publication name (str) or ICmPossibility object"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveDoNotShowMainEntryIn",
          "signature": "RemoveDoNotShowMainEntryIn(entry_or_hvo, publication)",
          "summary": "Remove a publication from the no-main-entry list.",
          "description": "Remove a publication from the no-main-entry list.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "publication",
              "type": "",
              "default": null,
              "description": "Publication name (str) or ICmPossibility object"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetBibliography",
          "signature": "SetBibliography(entry_or_hvo, text, wsHandle=None)",
          "summary": "Set the bibliography of a lexical entry.",
          "description": "Set the bibliography of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The bibliography text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetCitationForm",
          "signature": "SetCitationForm(entry_or_hvo, text, wsHandle=None)",
          "summary": "Set the citation form of a lexical entry.",
          "description": "Set the citation form of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new citation form text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or text is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"am\")\n            >>> project.LexEntry.SetCitationForm(entry, \"be\")\n            >>> print(project.LexEntry.GetCitationForm(entry))\n            be\n\n            >>> # Set in specific writing system\n            >>> project.LexEntry.SetCitationForm(entry, \"tre\",\n            ...                                   project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetComment",
          "signature": "SetComment(entry_or_hvo, text, wsHandle=None)",
          "summary": "Set the comment of a lexical entry.",
          "description": "Set the comment of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The comment text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDoNotUseForParsing",
          "signature": "SetDoNotUseForParsing(entry_or_hvo, value)",
          "summary": "Set whether an entry is excluded from parsing.",
          "description": "Set whether an entry is excluded from parsing.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "value",
              "type": "bool",
              "default": null,
              "description": "True to exclude from parsing, False to include"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetExcludeAsHeadword",
          "signature": "SetExcludeAsHeadword(entry_or_hvo, value)",
          "summary": "Set whether an entry is excluded as a headword.",
          "description": "Set whether an entry is excluded as a headword.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "value",
              "type": "bool",
              "default": null,
              "description": "True to exclude as headword, False to include"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetHeadword",
          "signature": "SetHeadword(entry_or_hvo, text, wsHandle=None)",
          "summary": "Set the headword by setting the lexeme form.",
          "description": "Set the headword by setting the lexeme form.\n\nThis is a convenience method equivalent to SetLexemeForm().\nThe headword display includes homograph numbers automatically.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new headword text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or text is None",
            "FP_ParameterError: If text is empty or entry has no lexeme form"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> project.LexEntry.SetHeadword(entry, \"ran\")\n            >>> print(project.LexEntry.GetHeadword(entry))\n            ran\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetHomographNumber",
          "signature": "SetHomographNumber(entry_or_hvo, number)",
          "summary": "Set the homograph number of a lexical entry.",
          "description": "Set the homograph number of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "number",
              "type": "int",
              "default": null,
              "description": "The homograph number (0 to clear, 1+ for homographs)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or number is None",
            "FP_ParameterError: If number is negative"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"bank\")\n            >>> project.LexEntry.SetHomographNumber(entry, 1)\n            >>> print(project.LexEntry.GetHeadword(entry))\n            bank\n\n            >>> # Clear homograph number\n            >>> project.LexEntry.SetHomographNumber(entry, 0)\n\n        Warning:\n            - Manually setting homograph numbers may cause conflicts\n            - FLEx normally manages homograph numbers automatically\n            - Use with caution - prefer letting FLEx auto-assign\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetImportResidue",
          "signature": "SetImportResidue(entry_or_hvo, residue)",
          "summary": "Set the import residue of a lexical entry.",
          "description": "Set the import residue of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "residue",
              "type": "str",
              "default": null,
              "description": "The import residue text to set"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or residue is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> project.LexEntry.SetImportResidue(entry,\n            ...     \"<custom><field1>value1</field1></custom>\")\n\n            >>> # Clear import residue\n            >>> project.LexEntry.SetImportResidue(entry, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLexemeForm",
          "signature": "SetLexemeForm(entry_or_hvo, text, wsHandle=None)",
          "summary": "Set the lexeme form of a lexical entry.",
          "description": "Set the lexeme form of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new lexeme form text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or text is None",
            "FP_ParameterError: If text is empty or entry has no lexeme form object"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> project.LexEntry.SetLexemeForm(entry, \"ran\")\n            >>> print(project.LexEntry.GetLexemeForm(entry))\n            ran\n\n            >>> # Set in specific writing system\n            >>> project.LexEntry.SetLexemeForm(entry, \"courir\",\n            ...                                 project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLiteralMeaning",
          "signature": "SetLiteralMeaning(entry_or_hvo, text, wsHandle=None)",
          "summary": "Set the literal meaning of a lexical entry.",
          "description": "Set the literal meaning of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The literal meaning text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetMorphType",
          "signature": "SetMorphType(entry_or_hvo, morph_type_or_name)",
          "summary": "Set the morph type of a lexical entry's lexeme form.",
          "description": "Set the morph type of a lexical entry's lexeme form.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "morph_type_or_name",
              "type": "",
              "default": null,
              "description": "Either an IMoMorphType object or a morph type name (str) such as \"stem\", \"root\", \"prefix\", \"suffix\", etc."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or morph_type_or_name is None",
            "FP_ParameterError: If entry has no lexeme form, or morph type",
            "name not found"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"-ing\")\n            >>> project.LexEntry.SetMorphType(entry, \"suffix\")\n            >>> mt = project.LexEntry.GetMorphType(entry)\n            >>> print(ITsString(mt.Name.BestAnalysisAlternative).Text)\n            suffix\n\n            >>> # Set using morph type object\n            >>> morph_types = project.lp.MorphTypesOA.PossibilitiesOS\n            >>> stem_type = morph_types[0]  # assuming first is stem\n            >>> project.LexEntry.SetMorphType(entry, stem_type)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetRestrictions",
          "signature": "SetRestrictions(entry_or_hvo, text, wsHandle=None)",
          "summary": "Set the restrictions of a lexical entry.",
          "description": "Set the restrictions of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The restrictions text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetSummaryDefinition",
          "signature": "SetSummaryDefinition(entry_or_hvo, text, wsHandle=None)",
          "summary": "Set the summary definition of a lexical entry.",
          "description": "Set the summary definition of a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexEntry object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The summary definition text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ValidateMorphType",
          "signature": "ValidateMorphType(morph_type_name)",
          "summary": "Check if a morph type name exists in the project.",
          "description": "Check if a morph type name exists in the project.\n",
          "parameters": [
            {
              "name": "morph_type_name",
              "type": "str",
              "default": null,
              "description": "The morph type name to validate (case-insensitive)"
            }
          ],
          "returns": "tuple: (is_valid, morph_type_obj, is_stem_type) where: - is_valid (bool): True if morph type exists - morph_type_obj (IMoMorphType or None): The morph type object if found - is_stem_type (bool or None): True if stem type, False if affix, None if not found ",
          "raises": [],
          "example": "            >>> is_valid, mt, is_stem = project.LexEntry.ValidateMorphType(\"suffix\")\n            >>> if is_valid:\n            ...     print(f\"Valid morph type: {mt.Name.BestAnalysisAlternative.Text}\")\n            ...     print(f\"Is stem type: {is_stem}\")\n            Valid morph type: suffix\n            Is stem type: False\n\n            >>> is_valid, mt, is_stem = project.LexEntry.ValidateMorphType(\"invalid\")\n            >>> print(f\"Valid: {is_valid}\")\n            Valid: False\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize LexEntryOperations with a FLExProject instance.",
          "description": "Initialize LexEntryOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "LexRefMappingTypes": {
      "name": "LexRefMappingTypes",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.LexReferenceOperations",
      "source_file": "Lexicon/LexReferenceOperations",
      "category": "lexicon",
      "summary": "Lexical reference mapping type constants.",
      "description": "Lexical reference mapping type constants.\n\nThese correspond to the LexRefTypeTags.MappingTypes enum in FLEx.\nThe mapping type determines how the lexical relation behaves:\n\n- SYMMETRIC: Bidirectional equal relations (A  B)",
      "example": "    - ASYMMETRIC: Directional relations with forward and reverse (A  B, B  A)\n\n    - TREE: Tree/hierarchical relations with parent-child structure\n\n    - SEQUENCE: Ordered sequence relations (A  B  C)",
      "base_classes": [],
      "methods": [],
      "properties": [],
      "lcm_dependencies": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ],
      "tags": [
        "lexicon"
      ]
    },
    "LexReferenceOperations": {
      "name": "LexReferenceOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.LexReferenceOperations",
      "source_file": "Lexicon/LexReferenceOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing lexical references and\ncross-references in a FieldWorks project.",
      "description": "This class provides operations for managing lexical references and\ncross-references in a FieldWorks project.\n\nLexical references connect entries or senses through various types of\nrelations such as synonyms, antonyms, hypernyms, part-whole relationships,\nand complex form relationships. These relations help organize the lexicon\nsemantically and structurally.\n\nThe class handles different mapping types:\n- Symmetric (e.g., synonym, antonym)\n- Asymmetric (e.g., hypernym/hyponym)\n- Tree (e.g., part-whole hierarchies)\n- Sequence (ordered relationships)\n\nThis class should be accessed via FLExProject.LexReferences property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all relation types\nfor ref_type in project.LexReferences.GetAllTypes():\nname = project.LexReferences.GetTypeName(ref_type)\nmapping = project.LexReferences.GetMappingType(ref_type)\nprint(f\"{name}: {mapping}\")\n\n# Create a new relation type\nsynonym_type = project.LexReferences.CreateType(\n\"Synonym\",\n\"Symmetric\",\nreverse_name=None\n)\n\n# Create a reference between two senses\nentry1 = project.LexEntry.Find(\"run\")\nentry2 = project.LexEntry.Find(\"jog\")\nif entry1 and entry2:\nsense1 = list(project.Senses.GetAll(entry1))[0]\nsense2 = list(project.Senses.GetAll(entry2))[0]\nref = project.LexReferences.Create(synonym_type, [sense1, sense2])\n\n# Get all references for a sense\nfor ref in project.LexReferences.GetAll(sense1):\ntargets = project.LexReferences.GetTargets(ref)\nfor target in targets:\nif target.ClassName == \"LexSense\":\ngloss = project.Senses.GetGloss(target)\nprint(f\"Related sense: {gloss}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddTarget",
          "signature": "AddTarget(lex_ref_or_hvo, sense_or_entry)",
          "summary": "Add a target sense or entry to an existing lexical reference.",
          "description": "Add a target sense or entry to an existing lexical reference.\n",
          "parameters": [
            {
              "name": "lex_ref_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexReference object or its HVO"
            },
            {
              "name": "sense_or_entry",
              "type": "",
              "default": null,
              "description": "The ILexSense or ILexEntry to add (or HVO)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If lex_ref_or_hvo or sense_or_entry is None",
            "FP_ParameterError: If target type doesn't match existing targets"
          ],
          "example": "            >>> # Find synonym reference\n            >>> entry1 = project.LexEntry.Find(\"run\")\n            >>> sense1 = list(project.Senses.GetAll(entry1))[0]\n            >>> refs = list(project.LexReferences.GetAll(sense1))\n            >>>\n            >>> # Find synonym type reference\n            >>> syn_ref = None\n            >>> for ref in refs:\n            ...     ref_type = project.LexReferences.GetType(ref)\n            ...     if project.LexReferences.GetTypeName(ref_type) == \"Synonym\":\n            ...         syn_ref = ref\n            ...         break\n            >>>\n            >>> if syn_ref:\n            ...     # Add another synonym\n            ...     entry2 = project.LexEntry.Find(\"sprint\")\n            ...     sense2 = list(project.Senses.GetAll(entry2))[0]\n            ...     project.LexReferences.AddTarget(syn_ref, sense2)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two lexical references and return their differences.",
          "description": "Compare two lexical references and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first ILexReference object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second ILexReference object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional LexReferenceOperations instance for item1."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional LexReferenceOperations instance for item2."
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(ref_type_or_name, targets)",
          "summary": "Create a new lexical reference linking senses or entries.",
          "description": "Create a new lexical reference linking senses or entries.\n",
          "parameters": [
            {
              "name": "ref_type_or_name",
              "type": "",
              "default": null,
              "description": "Either an ILexRefType object, its HVO, or the name of the reference type (str)"
            },
            {
              "name": "targets",
              "type": "",
              "default": null,
              "description": "List of ILexSense or ILexEntry objects (or HVOs) to link. Must contain at least 2 targets."
            }
          ],
          "returns": "ILexReference: The newly created reference object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ref_type_or_name or targets is None",
            "FP_ParameterError: If targets has fewer than 2 items, if reference",
            "type not found, or if targets are invalid"
          ],
          "example": "            >>> # Create synonym relation between two senses\n            >>> entry1 = project.LexEntry.Find(\"run\")\n            >>> entry2 = project.LexEntry.Find(\"jog\")\n            >>> if entry1 and entry2:\n            ...     sense1 = list(project.Senses.GetAll(entry1))[0]\n            ...     sense2 = list(project.Senses.GetAll(entry2))[0]\n            ...\n            ...     # Find or create synonym type\n            ...     syn_type = project.LexReferences.FindType(\"Synonym\")\n            ...     if not syn_type:\n            ...         syn_type = project.LexReferences.CreateType(\"Synonym\", \"Symmetric\")\n            ...\n            ...     # Create the reference\n            ...     ref = project.LexReferences.Create(syn_type, [sense1, sense2])\n\n            >>> # Create using type name\n            >>> ref2 = project.LexReferences.Create(\"Antonym\", [sense1, sense3])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateType",
          "signature": "CreateType(name, mapping_type, reverse_name=None, wsHandle=None)",
          "summary": "Create a new lexical relation type.",
          "description": "Create a new lexical relation type.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the relation type (e.g., \"Synonym\")"
            },
            {
              "name": "mapping_type",
              "type": "str",
              "default": null,
              "description": "The mapping type - one of: - \"Symmetric\" - bidirectional equal relations (synonym, antonym) - \"Asymmetric\" - directional relations (hypernym/hyponym) - \"Tree\" - hierarchical part-whole relations - \"Sequence\" - ordered sequence relations"
            },
            {
              "name": "reverse_name",
              "type": "str, optional",
              "default": null,
              "description": "The reverse name for asymmetric relations (e.g., \"Hyponym\" when name is \"Hypernym\")"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ILexRefType: The newly created reference type object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If name or mapping_type is None",
            "FP_ParameterError: If mapping_type is invalid or name is empty"
          ],
          "example": "            >>> # Create symmetric relation (synonym)\n            >>> syn_type = project.LexReferences.CreateType(\"Synonym\", \"Symmetric\")\n            >>> print(project.LexReferences.GetTypeName(syn_type))\n            Synonym\n\n            >>> # Create asymmetric relation (hypernym/hyponym)\n            >>> hyper_type = project.LexReferences.CreateType(\n            ...     \"Hypernym\",\n            ...     \"Asymmetric\",\n            ...     reverse_name=\"Hyponym\"\n            ... )\n\n            >>> # Create tree relation (part-whole)\n            >>> part_type = project.LexReferences.CreateType(\n            ...     \"Part-Whole\",\n            ...     \"Tree\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(lex_ref_or_hvo)",
          "summary": "Delete a lexical reference.",
          "description": "Delete a lexical reference.\n",
          "parameters": [
            {
              "name": "lex_ref_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexReference object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If lex_ref_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> if entry:\n            ...     sense = list(project.Senses.GetAll(entry))[0]\n            ...     refs = list(project.LexReferences.GetAll(sense))\n            ...     if refs:\n            ...         # Delete first reference\n            ...         project.LexReferences.Delete(refs[0])\n\n        Warning:\n            - This is a destructive operation\n            - Cannot be undone\n            - The related entries/senses are not affected\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "DeleteType",
          "signature": "DeleteType(ref_type_or_hvo)",
          "summary": "Delete a lexical relation type.",
          "description": "Delete a lexical relation type.\n",
          "parameters": [
            {
              "name": "ref_type_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexRefType object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ref_type_or_hvo is None",
            "FP_ParameterError: If type doesn't exist"
          ],
          "example": "            >>> ref_type = project.LexReferences.FindType(\"Obsolete Relation\")\n            >>> if ref_type:\n            ...     project.LexReferences.DeleteType(ref_type)\n\n        Warning:\n            - This is a destructive operation\n            - All references of this type will be deleted\n            - Cannot be undone\n            - Use with caution\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindType",
          "signature": "FindType(name, wsHandle=None)",
          "summary": "Find a lexical relation type by name.",
          "description": "Find a lexical relation type by name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the relation type to search for"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ILexRefType or None: The reference type object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> syn_type = project.LexReferences.FindType(\"Synonym\")\n            >>> if syn_type:\n            ...     mapping = project.LexReferences.GetMappingType(syn_type)\n            ...     print(f\"Found: {mapping}\")\n            Found: Symmetric\n\n            >>> # Search with specific writing system\n            >>> type_fr = project.LexReferences.FindType(\n            ...     \"Synonyme\",\n            ...     project.WSHandle('fr')\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(sense_or_entry=None)",
          "summary": "Get all lexical references for a sense or entry, or all references in the entire project.",
          "description": "Get all lexical references for a sense or entry, or all references in the entire project.\n\nThis returns all LexReference objects that include the specified\nsense or entry as one of their targets.\n",
          "parameters": [
            {
              "name": "sense_or_entry",
              "type": "",
              "default": null,
              "description": "Either an ILexSense or ILexEntry object (or HVO). If None, iterates all lexical references in the entire project."
            }
          ],
          "returns": "ILexReference: Each reference that includes this sense/entry (or project) ",
          "raises": [],
          "example": "            >>> # Get references for specific sense\n            >>> entry = project.LexEntry.Find(\"run\")\n            >>> if entry:\n            ...     senses = list(project.Senses.GetAll(entry))\n            ...     if senses:\n            ...         for ref in project.LexReferences.GetAll(senses[0]):\n            ...             ref_type = project.LexReferences.GetType(ref)\n            ...             type_name = project.LexReferences.GetTypeName(ref_type)\n            ...             targets = project.LexReferences.GetTargets(ref)\n            ...             print(f\"{type_name}: {len(targets)} targets\")\n            Synonym: 3 targets\n            Hypernym: 2 targets\n\n            >>> # Get ALL lexical references in entire project\n            >>> for ref in project.LexReferences.GetAll():\n            ...     ref_type = project.LexReferences.GetType(ref)\n            ...     type_name = project.LexReferences.GetTypeName(ref_type)\n            ...     print(f\"Reference type: {type_name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllTypes",
          "signature": "GetAllTypes()",
          "summary": "Get all lexical relation types in the project.",
          "description": "Get all lexical relation types in the project.\n\nThis method returns an iterator over all ILexRefType objects that\ndefine the types of lexical relations available in the project, such\nas Synonym, Antonym, Part-Whole, etc.\n",
          "parameters": [],
          "returns": "ILexRefType: Each lexical reference type object in the project ",
          "raises": [],
          "example": "            >>> for ref_type in project.LexReferences.GetAllTypes():\n            ...     name = project.LexReferences.GetTypeName(ref_type)\n            ...     mapping = project.LexReferences.GetMappingType(ref_type)\n            ...     count = len(list(ref_type.MembersOC))\n            ...     print(f\"{name} ({mapping}): {count} references\")\n            Synonym (Symmetric): 15 references\n            Antonym (Symmetric): 8 references\n            Part-Whole (Tree): 22 references\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetComplexFormEntries",
          "signature": "GetComplexFormEntries(entry)",
          "summary": "Get all complex form entries that show this entry as a component.",
          "description": "Get all complex form entries that show this entry as a component.\n\nReturns all complex forms (compounds, derivatives, etc.) that list\nthe given entry as one of their components.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "The component entry (ILexEntry or HVO)"
            }
          ],
          "returns": "list: List of ILexEntry objects that are complex forms containing this entry as a component ",
          "raises": [
            "FP_NullParameterError: If entry is None"
          ],
          "example": "            >>> # Find all complex forms containing \"run\"\n            >>> run_entry = project.LexEntry.Find(\"run\")\n            >>> if run_entry:\n            ...     complex_forms = project.LexReferences.GetComplexFormEntries(run_entry)\n            ...     for cf in complex_forms:\n            ...         headword = project.LexEntry.GetHeadword(cf)\n            ...         print(f\"Complex form: {headword}\")\n            Complex form: running shoe\n            Complex form: run away\n            Complex form: run-up\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetComponentEntries",
          "signature": "GetComponentEntries(complex_entry)",
          "summary": "Get all component entries that make up a complex form entry.",
          "description": "Get all component entries that make up a complex form entry.\n\nReturns all component entries (roots, stems) that are shown as\nsubentries under the given complex form.\n",
          "parameters": [
            {
              "name": "complex_entry",
              "type": "",
              "default": null,
              "description": "The complex form entry (ILexEntry or HVO)"
            }
          ],
          "returns": "list: List of ILexEntry objects that are components of this complex form ",
          "raises": [
            "FP_NullParameterError: If complex_entry is None"
          ],
          "example": "            >>> # Find components of \"running shoe\"\n            >>> shoe_entry = project.LexEntry.Find(\"running shoe\")\n            >>> if shoe_entry:\n            ...     components = project.LexReferences.GetComponentEntries(shoe_entry)\n            ...     for comp in components:\n            ...         headword = project.LexEntry.GetHeadword(comp)\n            ...         print(f\"Component: {headword}\")\n            Component: run\n            Component: shoe\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMappingType",
          "signature": "GetMappingType(ref_type_or_hvo)",
          "summary": "Get the mapping type of a lexical relation type.",
          "description": "Get the mapping type of a lexical relation type.\n\nThe mapping type determines how the relation behaves:\n- Symmetric: Bidirectional equal relations (e.g., synonym)\n- Asymmetric: Directional relations with reverse (e.g., hypernym/hyponym)\n- Tree: Hierarchical parent-child relations (e.g., part-whole)\n- Sequence: Ordered sequence relations\n",
          "parameters": [
            {
              "name": "ref_type_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexRefType object or its HVO"
            }
          ],
          "returns": "str: The mapping type as a string - one of: \"Symmetric\", \"Asymmetric\", \"Tree\", \"Sequence\", or \"Unknown\" ",
          "raises": [
            "FP_NullParameterError: If ref_type_or_hvo is None"
          ],
          "example": "            >>> for ref_type in project.LexReferences.GetAllTypes():\n            ...     name = project.LexReferences.GetTypeName(ref_type)\n            ...     mapping = project.LexReferences.GetMappingType(ref_type)\n            ...     print(f\"{name}: {mapping}\")\n            Synonym: Symmetric\n            Antonym: Symmetric\n            Hypernym: Asymmetric\n            Part-Whole: Tree\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetReferencesOfType",
          "signature": "GetReferencesOfType(ref_type_or_name)",
          "summary": "Get all lexical references of a specific type.",
          "description": "Get all lexical references of a specific type.\n",
          "parameters": [
            {
              "name": "ref_type_or_name",
              "type": "",
              "default": null,
              "description": "Either an ILexRefType object, its HVO, or the name of the reference type (str)"
            }
          ],
          "returns": "ILexReference: Each reference of the specified type ",
          "raises": [
            "FP_NullParameterError: If ref_type_or_name is None",
            "FP_ParameterError: If reference type name not found"
          ],
          "example": "            >>> # Get all synonym references\n            >>> for ref in project.LexReferences.GetReferencesOfType(\"Synonym\"):\n            ...     targets = project.LexReferences.GetTargets(ref)\n            ...     glosses = []\n            ...     for target in targets:\n            ...         if target.ClassName == \"LexSense\":\n            ...             glosses.append(project.Senses.GetGloss(target))\n            ...     print(f\"Synonyms: {', '.join(glosses)}\")\n            Synonyms: run, jog, sprint\n            Synonyms: walk, stroll, amble\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a lexical reference for comparison.",
          "description": "Get all syncable properties of a lexical reference for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ILexReference object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values.",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTargets",
          "signature": "GetTargets(lex_ref_or_hvo)",
          "summary": "Get all target senses or entries in a lexical reference.",
          "description": "Get all target senses or entries in a lexical reference.\n",
          "parameters": [
            {
              "name": "lex_ref_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexReference object or its HVO"
            }
          ],
          "returns": "list: List of ILexSense or ILexEntry objects that are targets ",
          "raises": [
            "FP_NullParameterError: If lex_ref_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> if entry:\n            ...     sense = list(project.Senses.GetAll(entry))[0]\n            ...     for ref in project.LexReferences.GetAll(sense):\n            ...         targets = project.LexReferences.GetTargets(ref)\n            ...         for target in targets:\n            ...             if target.ClassName == \"LexSense\":\n            ...                 gloss = project.Senses.GetGloss(target)\n            ...                 print(f\"  -> {gloss}\")\n            ...             elif target.ClassName == \"LexEntry\":\n            ...                 headword = project.LexEntry.GetHeadword(target)\n            ...                 print(f\"  -> {headword}\")\n              -> jog\n              -> sprint\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetType",
          "signature": "GetType(lex_ref_or_hvo)",
          "summary": "Get the reference type of a lexical reference.",
          "description": "Get the reference type of a lexical reference.\n",
          "parameters": [
            {
              "name": "lex_ref_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexReference object or its HVO"
            }
          ],
          "returns": "ILexRefType: The reference type object ",
          "raises": [
            "FP_NullParameterError: If lex_ref_or_hvo is None"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> if entry:\n            ...     sense = list(project.Senses.GetAll(entry))[0]\n            ...     for ref in project.LexReferences.GetAll(sense):\n            ...         ref_type = project.LexReferences.GetType(ref)\n            ...         name = project.LexReferences.GetTypeName(ref_type)\n            ...         mapping = project.LexReferences.GetMappingType(ref_type)\n            ...         print(f\"{name} ({mapping})\")\n            Synonym (Symmetric)\n            Hypernym (Asymmetric)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTypeName",
          "signature": "GetTypeName(ref_type_or_hvo, wsHandle=None)",
          "summary": "Get the name of a lexical relation type.",
          "description": "Get the name of a lexical relation type.\n",
          "parameters": [
            {
              "name": "ref_type_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexRefType object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The name of the reference type (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If ref_type_or_hvo is None"
          ],
          "example": "            >>> for ref_type in project.LexReferences.GetAllTypes():\n            ...     name = project.LexReferences.GetTypeName(ref_type)\n            ...     print(f\"Relation type: {name}\")\n            Relation type: Synonym\n            Relation type: Antonym\n            Relation type: Part-Whole\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTypeReverseName",
          "signature": "GetTypeReverseName(ref_type_or_hvo, wsHandle=None)",
          "summary": "Get the reverse name for an asymmetric relation type.",
          "description": "Get the reverse name for an asymmetric relation type.\n\nFor asymmetric relations, the reverse name is used for the opposite\ndirection. For example, if the name is \"Hypernym\", the reverse name\nwould be \"Hyponym\".\n",
          "parameters": [
            {
              "name": "ref_type_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexRefType object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The reverse name (empty string if not set or not asymmetric) ",
          "raises": [
            "FP_NullParameterError: If ref_type_or_hvo is None"
          ],
          "example": "            >>> hyper_type = project.LexReferences.FindType(\"Hypernym\")\n            >>> if hyper_type:\n            ...     name = project.LexReferences.GetTypeName(hyper_type)\n            ...     reverse = project.LexReferences.GetTypeReverseName(hyper_type)\n            ...     print(f\"{name} <-> {reverse}\")\n            Hypernym <-> Hyponym\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveTarget",
          "signature": "RemoveTarget(lex_ref_or_hvo, sense_or_entry)",
          "summary": "Remove a target sense or entry from a lexical reference.",
          "description": "Remove a target sense or entry from a lexical reference.\n",
          "parameters": [
            {
              "name": "lex_ref_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexReference object or its HVO"
            },
            {
              "name": "sense_or_entry",
              "type": "",
              "default": null,
              "description": "The ILexSense or ILexEntry to remove (or HVO)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If lex_ref_or_hvo or sense_or_entry is None",
            "FP_ParameterError: If removing would leave fewer than 2 targets"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> sense = list(project.Senses.GetAll(entry))[0]\n            >>> refs = list(project.LexReferences.GetAll(sense))\n            >>> if refs:\n            ...     targets = project.LexReferences.GetTargets(refs[0])\n            ...     if len(targets) > 2:\n            ...         # Safe to remove one\n            ...         project.LexReferences.RemoveTarget(refs[0], targets[-1])\n\n        Warning:\n            - Will raise error if removal would leave < 2 targets\n            - Consider using Delete() instead if removing all but one target\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetTypeName",
          "signature": "SetTypeName(ref_type_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a lexical relation type.",
          "description": "Set the name of a lexical relation type.\n",
          "parameters": [
            {
              "name": "ref_type_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexRefType object or its HVO"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name for the reference type"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ref_type_or_hvo or name is None"
          ],
          "example": "            >>> ref_type = project.LexReferences.FindType(\"Synonm\")  # typo\n            >>> if ref_type:\n            ...     project.LexReferences.SetTypeName(ref_type, \"Synonym\")\n            ...     print(project.LexReferences.GetTypeName(ref_type))\n            Synonym\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetTypeReverseName",
          "signature": "SetTypeReverseName(ref_type_or_hvo, name, wsHandle=None)",
          "summary": "Set the reverse name for an asymmetric relation type.",
          "description": "Set the reverse name for an asymmetric relation type.\n",
          "parameters": [
            {
              "name": "ref_type_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexRefType object or its HVO"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new reverse name"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ref_type_or_hvo or name is None",
            "FP_ParameterError: If the relation type is not asymmetric"
          ],
          "example": "            >>> hyper_type = project.LexReferences.FindType(\"Hypernym\")\n            >>> if hyper_type:\n            ...     project.LexReferences.SetTypeReverseName(hyper_type, \"Hyponym\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ShowComplexFormsIn",
          "signature": "ShowComplexFormsIn(entry, complex_entry)",
          "summary": "Show a component entry as a subentry under a complex form entry.",
          "description": "Show a component entry as a subentry under a complex form entry.\n\nThis creates a \"Show Complex Forms In\" relationship, making the\ncomponent entry appear as a subentry in dictionary views of the\ncomplex form.\n",
          "parameters": [
            {
              "name": "entry",
              "type": "",
              "default": null,
              "description": "The component entry (ILexEntry or HVO) to show as subentry"
            },
            {
              "name": "complex_entry",
              "type": "",
              "default": null,
              "description": "The complex form entry (ILexEntry or HVO) to show it under"
            }
          ],
          "returns": "ILexReference: The created reference object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry or complex_entry is None",
            "FP_ParameterError: If entries are invalid"
          ],
          "example": "            >>> # Show \"run\" as a component under \"running shoe\"\n            >>> run_entry = project.LexEntry.Find(\"run\")\n            >>> shoe_entry = project.LexEntry.Find(\"running shoe\")\n            >>> if run_entry and shoe_entry:\n            ...     ref = project.LexReferences.ShowComplexFormsIn(\n            ...         run_entry,\n            ...         shoe_entry\n            ...     )\n\n            >>> # Show multiple components under one complex form\n            >>> run_entry = project.LexEntry.Find(\"run\")\n            >>> away_entry = project.LexEntry.Find(\"away\")\n            >>> runaway_entry = project.LexEntry.Find(\"runaway\")\n            >>> if run_entry and away_entry and runaway_entry:\n            ...     # This would typically be done differently, creating one\n            ...     # reference with multiple targets\n            ...     pass\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize LexReferenceOperations with a FLExProject instance.",
          "description": "Initialize LexReferenceOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "LexSenseOperations": {
      "name": "LexSenseOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.LexSenseOperations",
      "source_file": "Lexicon/LexSenseOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing lexical senses in a FieldWorks project.",
      "description": "This class provides operations for managing lexical senses in a FieldWorks project.\n\nLexical senses represent the different meanings or uses of a lexical entry.\nEach sense can have glosses, definitions, grammatical information, semantic\ndomains, example sentences, pictures, and more.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Access via FLExProject.Senses property (recommended)\nentry = list(project.LexiconAllEntries())[0]\n\n# Get all senses\nfor sense in project.Senses.GetAll(entry):\ngloss = project.Senses.GetGloss(sense)\nprint(f\"Sense: {gloss}\")\n\n# Create a new sense\nsense = project.Senses.Create(entry, \"to run\", \"en\")\n\n# Set definition\nproject.Senses.SetDefinition(sense, \"To move swiftly on foot\", \"en\")\n\n# Add semantic domain\ndomains = project.GetAllSemanticDomains(flat=True)\nif domains:\nproject.Senses.AddSemanticDomain(sense, domains[0])\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddAnthroCode",
          "signature": "AddAnthroCode(sense_or_hvo, anthro_code)",
          "summary": "Add an anthropology code to a sense.",
          "description": "Add an anthropology code to a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "anthro_code",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddDomainType",
          "signature": "AddDomainType(sense_or_hvo, domain_type)",
          "summary": "Add a domain type to a sense.",
          "description": "Add a domain type to a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "domain_type",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddExample",
          "signature": "AddExample(sense_or_hvo, text, wsHandle=None)",
          "summary": "Add a new example sentence to a sense.",
          "description": "Add a new example sentence to a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The example sentence text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "ILexExampleSentence: The newly created example object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or text is None.",
            "FP_ParameterError: If text is empty."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     ex = project.Senses.AddExample(senses[0], \"She runs every morning.\")\n            ...     # Add translation (would need additional code)\n            ...     print(f\"Added example: {ex.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddPicture",
          "signature": "AddPicture(sense_or_hvo, image_path, caption=None, wsHandle=None)",
          "summary": "Add a picture (image) to a lexical sense.",
          "description": "Add a picture (image) to a lexical sense.\n\nPictures illustrate the meaning of a sense. The image file is copied into\nthe project's LinkedFiles/Pictures directory and a reference is created.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "image_path",
              "type": "str",
              "default": null,
              "description": "Path to the image file (will be copied to project)."
            },
            {
              "name": "caption",
              "type": "str",
              "default": null,
              "description": "Optional caption text for the picture."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle for caption. Defaults to vernacular WS."
            }
          ],
          "returns": "ICmPicture: The newly created picture object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or image_path is None.",
            "FP_ParameterError: If image file doesn't exist."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     # Add picture to sense\n            ...     picture = project.Senses.AddPicture(\n            ...         senses[0],\n            ...         \"/path/to/dog.jpg\",\n            ...         caption=\"A friendly dog\"\n            ...     )\n            ...     print(f\"Added picture with caption: {project.Senses.GetCaption(picture)}\")\n            Added picture with caption: A friendly dog\n\n            >>> # Add picture without caption\n            >>> picture = project.Senses.AddPicture(senses[0], \"/path/to/cat.jpg\")\n\n            >>> # Get all pictures\n            >>> pictures = project.Senses.GetPictures(senses[0])\n            >>> print(f\"Sense has {len(pictures)} pictures\")\n            Sense has 2 pictures\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddSemanticDomain",
          "signature": "AddSemanticDomain(sense_or_hvo, domain_or_hvo)",
          "summary": "Add a semantic domain to a sense.",
          "description": "Add a semantic domain to a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO to add."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or domain_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     # Get semantic domains\n            ...     all_domains = project.GetAllSemanticDomains(flat=True)\n            ...     if all_domains:\n            ...         # Add first domain\n            ...         project.Senses.AddSemanticDomain(senses[0], all_domains[0])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddUsageType",
          "signature": "AddUsageType(sense_or_hvo, usage_type)",
          "summary": "Add a usage type to a sense.",
          "description": "Add a usage type to a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "usage_type",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two lexical senses and return their differences.",
          "description": "Compare two lexical senses and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first ILexSense object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second ILexSense object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional LexSenseOperations instance for item1."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional LexSenseOperations instance for item2."
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(entry_or_hvo, gloss, wsHandle=None)",
          "summary": "Create a new sense for a lexical entry.",
          "description": "Create a new sense for a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO."
            },
            {
              "name": "gloss",
              "type": "str",
              "default": null,
              "description": "The gloss text for the sense."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ILexSense: The newly created sense object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If entry_or_hvo or gloss is None.",
            "FP_ParameterError: If gloss is empty."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> sense = project.Senses.Create(entry, \"to run\")\n            >>> print(project.Senses.GetGloss(sense))\n            to run\n\n            >>> # Create with specific writing system\n            >>> sense_fr = project.Senses.Create(entry, \"courir\",\n            ...                                   project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateSubsense",
          "signature": "CreateSubsense(parent_sense_or_hvo, gloss, wsHandle=None)",
          "summary": "Create a new subsense under a parent sense.",
          "description": "Create a new subsense under a parent sense.\n",
          "parameters": [
            {
              "name": "parent_sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The parent ILexSense object or HVO."
            },
            {
              "name": "gloss",
              "type": "str",
              "default": null,
              "description": "The gloss text for the subsense."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ILexSense: The newly created subsense object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If parent_sense_or_hvo or gloss is None.",
            "FP_ParameterError: If gloss is empty."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     subsense = project.Senses.CreateSubsense(senses[0], \"to run (of water)\")\n            ...     print(project.Senses.GetGloss(subsense))\n            to run (of water)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(sense_or_hvo)",
          "summary": "Delete a sense from its owning entry.",
          "description": "Delete a sense from its owning entry.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if len(senses) > 1:\n            ...     # Delete the last sense\n            ...     project.Senses.Delete(senses[-1])\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - All subsenses, examples, and other related data are also deleted\n            - Consider backing up data before deletion\n            - Analyses in texts that reference this sense will be affected\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a sense, creating a new copy with a new GUID.",
          "description": "Duplicate a sense, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source sense. If False, insert at end of parent's sense list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (subsenses, examples, pictures). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "ILexSense: The newly created duplicate sense with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     # Shallow duplicate (no examples/subsenses)\n            ...     dup = project.Senses.Duplicate(senses[0])\n            ...     print(f\"Original: {project.Senses.GetGuid(senses[0])}\")\n            ...     print(f\"Duplicate: {project.Senses.GetGuid(dup)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n            ...\n            ...     # Deep duplicate (includes all owned objects)\n            ...     deep_dup = project.Senses.Duplicate(senses[0], deep=True)\n            ...     print(f\"Examples: {project.Senses.GetExampleCount(deep_dup)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(entry_or_hvo=None)",
          "summary": "Get senses for an entry or all senses in the project.",
          "description": "Get senses for an entry or all senses in the project.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Optional ILexEntry object or HVO. If provided, returns senses for that entry only. If None, returns ALL senses in the entire project."
            }
          ],
          "returns": "ILexSense: Each sense. ",
          "raises": [],
          "example": "            >>> # Get senses for a specific entry\n            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> for sense in project.Senses.GetAll(entry):\n            ...     gloss = project.Senses.GetGloss(sense)\n            ...     defn = project.Senses.GetDefinition(sense)\n            ...     print(f\"{gloss}: {defn}\")\n            run: to move swiftly on foot\n            run: to flow or extend\n            >>>\n            >>> # Get ALL senses in entire project\n            >>> for sense in project.Senses.GetAll():\n            ...     gloss = project.Senses.GetGloss(sense)\n            ...     print(f\"Sense: {gloss}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllSenses",
          "signature": "GetAllSenses(sense_or_hvo)",
          "summary": "Get this sense and all its subsenses recursively.",
          "description": "Get this sense and all its subsenses recursively.\n\nReturns all senses in a flattened list, including the sense itself\nand recursively including all subsenses at any depth.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexSense object or its HVO"
            }
          ],
          "returns": "list: List of ILexSense objects (this sense + all subsenses) ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> sense = entry.SensesOS[0]\n            >>> all_senses = project.Senses.GetAllSenses(sense)\n            >>> print(f\"Total (including subsenses): {len(all_senses)}\")\n            >>> for s in all_senses:\n            ...     gloss = project.Senses.GetGloss(s)\n            ...     depth = len(list(s.PathToRoot)) - 2\n            ...     indent = \"  \" * depth\n            ...     print(f\"{indent}{gloss}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnalysesCount",
          "signature": "GetAnalysesCount(sense_or_hvo)",
          "summary": "Get the count of analyses in texts that reference this sense.",
          "description": "Get the count of analyses in texts that reference this sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "int: Number of analyses referencing this sense. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     count = project.Senses.GetAnalysesCount(senses[0])\n            ...     print(f\"This sense is used {count} times in texts\")\n            This sense is used 15 times in texts\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnthroCodes",
          "signature": "GetAnthroCodes(sense_or_hvo)",
          "summary": "Get the anthropology codes of a sense.",
          "description": "Get the anthropology codes of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnthroNote",
          "signature": "GetAnthroNote(sense_or_hvo, wsHandle=None)",
          "summary": "Get the anthropology note of a sense.",
          "description": "Get the anthropology note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBibliography",
          "signature": "GetBibliography(sense_or_hvo, wsHandle=None)",
          "summary": "Get the bibliography of a sense.",
          "description": "Get the bibliography of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCaption",
          "signature": "GetCaption(picture, wsHandle=None)",
          "summary": "Get the caption for a picture.",
          "description": "Get the caption for a picture.\n",
          "parameters": [
            {
              "name": "picture",
              "type": "",
              "default": null,
              "description": "The ICmPicture object."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The caption text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If picture is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     pictures = project.Senses.GetPictures(senses[0])\n            ...     if pictures:\n            ...         caption = project.Senses.GetCaption(pictures[0])\n            ...         print(f\"Picture caption: {caption}\")\n            Picture caption: A friendly dog\n            ...\n            ...         # Get caption in specific writing system\n            ...         caption_fr = project.Senses.GetCaption(pictures[0],\n            ...                                                project.WSHandle('fr'))\n            ...         print(f\"French caption: {caption_fr}\")\n            French caption: Un chien amical\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetComplexFormsNotSubentries",
          "signature": "GetComplexFormsNotSubentries(sense_or_hvo)",
          "summary": "Get complex forms that reference this sense, excluding subentries.",
          "description": "Get complex forms that reference this sense, excluding subentries.\n\nReturns complex forms (compounds, idioms, etc.) but excludes any\nwhere the owner entry appears as a subentry (in PrimaryLexemesRS).\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexSense object or its HVO"
            }
          ],
          "returns": "list: List of ILexEntryRef objects (complex forms, excluding subentries) ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> sense = entry.SensesOS[0]\n            >>> complex_forms = project.Senses.GetComplexFormsNotSubentries(sense)\n            >>> for lex_ref in complex_forms:\n            ...     cf_entry = lex_ref.OwningEntry\n            ...     print(f\"Complex form: {project.LexEntry.GetHeadword(cf_entry)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDefinition",
          "signature": "GetDefinition(sense_or_hvo, wsHandle=None)",
          "summary": "Get the definition for a sense.",
          "description": "Get the definition for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The definition text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     defn = project.Senses.GetDefinition(senses[0])\n            ...     print(defn)\n            To move swiftly on foot by alternately setting each foot forward\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDefinitionOrGloss",
          "signature": "GetDefinitionOrGloss(sense_or_hvo, wsHandle=None)",
          "summary": "Get definition if available, otherwise fallback to gloss (Pattern 5).",
          "description": "Get definition if available, otherwise fallback to gloss (Pattern 5).\n\nThis is a common FLEx pattern that returns the definition if it exists,\notherwise returns the gloss. Useful for display where either is acceptable.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The definition if available, otherwise the gloss, or empty string ",
          "raises": [],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> sense = entry.SensesOS[0]\n            >>> # Returns definition if set, otherwise gloss\n            >>> text = project.Senses.GetDefinitionOrGloss(sense)\n            >>> print(text)\n            to run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDiscourseNote",
          "signature": "GetDiscourseNote(sense_or_hvo, wsHandle=None)",
          "summary": "Get the discourse note of a sense.",
          "description": "Get the discourse note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDomainTypes",
          "signature": "GetDomainTypes(sense_or_hvo)",
          "summary": "Get the domain types of a sense.",
          "description": "Get the domain types of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEncyclopedicInfo",
          "signature": "GetEncyclopedicInfo(sense_or_hvo, wsHandle=None)",
          "summary": "Get the encyclopedic info of a sense.",
          "description": "Get the encyclopedic info of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetExampleCount",
          "signature": "GetExampleCount(sense_or_hvo)",
          "summary": "Get the count of example sentences for a sense.",
          "description": "Get the count of example sentences for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "int: Number of examples. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     count = project.Senses.GetExampleCount(senses[0])\n            ...     print(f\"This sense has {count} examples\")\n            This sense has 3 examples\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetExamples",
          "signature": "GetExamples(sense_or_hvo)",
          "summary": "Get all example sentences for a sense.",
          "description": "Get all example sentences for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "list: List of ILexExampleSentence objects. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     examples = project.Senses.GetExamples(senses[0])\n            ...     for ex in examples:\n            ...         ws = project.project.DefaultVernWs\n            ...         text = ITsString(ex.Example.get_String(ws)).Text\n            ...         print(f\"Example: {text}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGeneralNote",
          "signature": "GetGeneralNote(sense_or_hvo, wsHandle=None)",
          "summary": "Get the general note of a sense.",
          "description": "Get the general note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGloss",
          "signature": "GetGloss(sense_or_hvo, wsHandle=None)",
          "summary": "Get the gloss for a sense.",
          "description": "Get the gloss for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The gloss text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     gloss = project.Senses.GetGloss(senses[0])\n            ...     print(gloss)\n            to run\n\n            >>> # Get gloss in specific writing system\n            >>> gloss_fr = project.Senses.GetGloss(senses[0],\n            ...                                     project.WSHandle('fr'))\n            >>> print(gloss_fr)\n            courir\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGrammarNote",
          "signature": "GetGrammarNote(sense_or_hvo, wsHandle=None)",
          "summary": "Get the grammar note of a sense.",
          "description": "Get the grammar note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGrammaticalInfo",
          "signature": "GetGrammaticalInfo(sense_or_hvo)",
          "summary": "Get the full grammatical information (MSA) for a sense.",
          "description": "Get the full grammatical information (MSA) for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "IMoMorphSynAnalysis or None: The MSA object, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     msa = project.Senses.GetGrammaticalInfo(senses[0])\n            ...     if msa:\n            ...         print(f\"MSA: {msa.InterlinearAbbr}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(sense_or_hvo)",
          "summary": "Get the GUID (Global Unique Identifier) for a sense.",
          "description": "Get the GUID (Global Unique Identifier) for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "System.Guid: The GUID of the sense. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     guid = project.Senses.GetGuid(senses[0])\n            ...     print(f\"Sense GUID: {guid}\")\n            Sense GUID: 12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetImportResidue",
          "signature": "GetImportResidue(sense_or_hvo)",
          "summary": "Get the import residue of a sense.",
          "description": "Get the import residue of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMinimalLexReferences",
          "signature": "GetMinimalLexReferences(sense_or_hvo)",
          "summary": "Get essential lexical references for this sense.",
          "description": "Get essential lexical references for this sense.\n\nReturns only \"minimal\" lexical references - those that are multi-target\nor have specific mapping types (sequence types).\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexSense object or its HVO"
            }
          ],
          "returns": "list: List of ILexReference objects (minimal references) ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"big\")\n            >>> sense = entry.SensesOS[0]\n            >>> lex_refs = project.Senses.GetMinimalLexReferences(sense)\n            >>> for lex_ref in lex_refs:\n            ...     ref_type = lex_ref.Owner  # ILexRefType\n            ...     print(f\"Reference type: {ref_type.Name.BestAnalysisAlternative.Text}\")\n            ...     for target in lex_ref.TargetsRS:\n            ...         if target.Hvo != sense.Hvo:\n            ...             gloss = project.Senses.GetGloss(target)\n            ...             print(f\"  -> {gloss}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwningEntry",
          "signature": "GetOwningEntry(sense_or_hvo)",
          "summary": "Get the lexical entry that owns this sense.",
          "description": "Get the lexical entry that owns this sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "ILexEntry: The owning entry. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     owner = project.Senses.GetOwningEntry(senses[0])\n            ...     headword = project.LexiconGetHeadword(owner)\n            ...     print(f\"Entry: {headword}\")\n            Entry: run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParentSense",
          "signature": "GetParentSense(sense_or_hvo)",
          "summary": "Get the parent sense if this is a subsense.",
          "description": "Get the parent sense if this is a subsense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "ILexSense or None: The parent sense, or None if top-level sense. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     subsenses = project.Senses.GetSubsenses(senses[0])\n            ...     if subsenses:\n            ...         parent = project.Senses.GetParentSense(subsenses[0])\n            ...         if parent:\n            ...             parent_gloss = project.Senses.GetGloss(parent)\n            ...             print(f\"Parent: {parent_gloss}\")\n            Parent: to run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPartOfSpeech",
          "signature": "GetPartOfSpeech(sense_or_hvo)",
          "summary": "Get the part of speech abbreviation for a sense.",
          "description": "Get the part of speech abbreviation for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "str: The POS abbreviation, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     pos = project.Senses.GetPartOfSpeech(senses[0])\n            ...     print(f\"Part of Speech: {pos}\")\n            Part of Speech: v\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPhonologyNote",
          "signature": "GetPhonologyNote(sense_or_hvo, wsHandle=None)",
          "summary": "Get the phonology note of a sense.",
          "description": "Get the phonology note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPictureCount",
          "signature": "GetPictureCount(sense_or_hvo)",
          "summary": "Get the count of pictures for a sense.",
          "description": "Get the count of pictures for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "int: Number of pictures. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     count = project.Senses.GetPictureCount(senses[0])\n            ...     print(f\"This sense has {count} pictures\")\n            This sense has 1 pictures\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPictures",
          "signature": "GetPictures(sense_or_hvo)",
          "summary": "Get all pictures associated with a sense.",
          "description": "Get all pictures associated with a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "list: List of ICmPicture objects. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     pictures = project.Senses.GetPictures(senses[0])\n            ...     for pic in pictures:\n            ...         caption = ITsString(pic.Caption.BestAnalysisAlternative).Text\n            ...         print(f\"Picture: {caption}\")\n            Picture: A person running\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRestrictions",
          "signature": "GetRestrictions(sense_or_hvo, wsHandle=None)",
          "summary": "Get the restrictions of a sense.",
          "description": "Get the restrictions of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetReversalCount",
          "signature": "GetReversalCount(sense_or_hvo)",
          "summary": "Get the count of reversal entries for a sense.",
          "description": "Get the count of reversal entries for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "int: Number of reversal entries. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     count = project.Senses.GetReversalCount(senses[0])\n            ...     print(f\"This sense has {count} reversal entries\")\n            This sense has 2 reversal entries\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetReversalEntries",
          "signature": "GetReversalEntries(sense_or_hvo, reversal_index_ws=None)",
          "summary": "Get reversal entries for a sense in a specific reversal index.",
          "description": "Get reversal entries for a sense in a specific reversal index.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "reversal_index_ws",
              "type": "",
              "default": null,
              "description": "Optional writing system for reversal index. If None, returns entries from all reversal indexes."
            }
          ],
          "returns": "list: List of IReversalIndexEntry objects. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     # Get English reversal entries\n            ...     rev_entries = project.Senses.GetReversalEntries(senses[0], \"en\")\n            ...     for rev in rev_entries:\n            ...         ws = project.WSHandle(\"en\")\n            ...         form = ITsString(rev.ReversalForm.get_String(ws)).Text\n            ...         print(f\"Reversal: {form}\")\n            Reversal: run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetScientificName",
          "signature": "GetScientificName(sense_or_hvo)",
          "summary": "Get the scientific name of a sense.",
          "description": "Get the scientific name of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSemanticDomains",
          "signature": "GetSemanticDomains(sense_or_hvo)",
          "summary": "Get all semantic domains for a sense.",
          "description": "Get all semantic domains for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "list: List of ICmSemanticDomain objects. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     domains = project.Senses.GetSemanticDomains(senses[0])\n            ...     for domain in domains:\n            ...         ws = project.project.DefaultAnalWs\n            ...         name = ITsString(domain.Name.get_String(ws)).Text\n            ...         print(f\"Domain: {name}\")\n            Domain: 7.2.1 Walk\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSemanticsNote",
          "signature": "GetSemanticsNote(sense_or_hvo, wsHandle=None)",
          "summary": "Get the semantics note of a sense.",
          "description": "Get the semantics note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSenseNumber",
          "signature": "GetSenseNumber(sense_or_hvo)",
          "summary": "Get the sense number string for a sense.",
          "description": "Get the sense number string for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "str: The sense number (e.g., \"1\", \"2.1\", \"2.1.1\"). ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     num = project.Senses.GetSenseNumber(senses[0])\n            ...     gloss = project.Senses.GetGloss(senses[0])\n            ...     print(f\"{num}. {gloss}\")\n            1. to run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSenseType",
          "signature": "GetSenseType(sense_or_hvo)",
          "summary": "Get the sense type (e.",
          "description": "Get the sense type (e.g., literal, figurative, idiom).\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "ICmPossibility or None: The sense type object, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     sense_type = project.Senses.GetSenseType(senses[0])\n            ...     if sense_type:\n            ...         ws = project.project.DefaultAnalWs\n            ...         name = ITsString(sense_type.Name.get_String(ws)).Text\n            ...         print(f\"Type: {name}\")\n            Type: Figurative\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSocioLinguisticsNote",
          "signature": "GetSocioLinguisticsNote(sense_or_hvo, wsHandle=None)",
          "summary": "Get the socio-linguistics note of a sense.",
          "description": "Get the socio-linguistics note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSource",
          "signature": "GetSource(sense_or_hvo)",
          "summary": "Get the source of a sense.",
          "description": "Get the source of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetStatus",
          "signature": "GetStatus(sense_or_hvo)",
          "summary": "Get the status of a sense (e.",
          "description": "Get the status of a sense (e.g., approved, tentative).\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "ICmPossibility or None: The status object, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     status = project.Senses.GetStatus(senses[0])\n            ...     if status:\n            ...         ws = project.project.DefaultAnalWs\n            ...         name = ITsString(status.Name.get_String(ws)).Text\n            ...         print(f\"Status: {name}\")\n            Status: Approved\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubsenses",
          "signature": "GetSubsenses(sense_or_hvo)",
          "summary": "Get all subsenses (child senses) of a sense.",
          "description": "Get all subsenses (child senses) of a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            }
          ],
          "returns": "list: List of ILexSense objects that are subsenses. ",
          "raises": [
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     subsenses = project.Senses.GetSubsenses(senses[0])\n            ...     for subsense in subsenses:\n            ...         gloss = project.Senses.GetGloss(subsense)\n            ...         print(f\"  Subsense: {gloss}\")\n              Subsense: to run (of water)\n              Subsense: to run (a program)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a lexical sense for comparison.",
          "description": "Get all syncable properties of a lexical sense for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ILexSense object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values.",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetUsageTypes",
          "signature": "GetUsageTypes(sense_or_hvo)",
          "summary": "Get the usage types of a sense.",
          "description": "Get the usage types of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetVisibleComplexFormBackRefs",
          "signature": "GetVisibleComplexFormBackRefs(sense_or_hvo)",
          "summary": "Get all complex forms that reference this sense.",
          "description": "Get all complex forms that reference this sense.\n\nReturns all LexEntryRef objects where this sense appears in\nShowComplexFormsIn and RefType is ComplexForm.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ILexSense object or its HVO"
            }
          ],
          "returns": "list: List of ILexEntryRef objects (complex forms referencing this sense) ",
          "raises": [],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> sense = entry.SensesOS[0]\n            >>> complex_forms = project.Senses.GetVisibleComplexFormBackRefs(sense)\n            >>> for lex_ref in complex_forms:\n            ...     complex_entry = lex_ref.OwningEntry\n            ...     print(f\"Complex form: {project.LexEntry.GetHeadword(complex_entry)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MergeObject",
          "signature": "MergeObject(survivor_or_hvo, victim_or_hvo, fLoseNoStringData=True)",
          "summary": "Merge one sense into another (IRREVERSIBLE operation).",
          "description": "Merge one sense into another (IRREVERSIBLE operation).\n\nThis method merges all data from the victim sense into the survivor sense,\nthen deletes the victim. This is simpler than entry merging but still handles:\n- MultiString merging (Definition, Gloss, etc.)\n- Collection merging (examples, subsenses, etc.)\n- Back-reference updating\n- Special semicolon separator for Definition and Gloss\n",
          "parameters": [
            {
              "name": "survivor_or_hvo",
              "type": "",
              "default": null,
              "description": "Sense that will receive merged data (HVO or ILexSense)"
            },
            {
              "name": "victim_or_hvo",
              "type": "",
              "default": null,
              "description": "Sense that will be deleted after merge (HVO or ILexSense)"
            },
            {
              "name": "fLoseNoStringData",
              "type": "bool",
              "default": true,
              "description": "If True, concatenate strings (preserve both values); If False, overwrite strings (victim overwrites survivor)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project not write-enabled",
            "FP_NullParameterError: If either parameter is None",
            "FP_ParameterError: If senses are not compatible for merging"
          ],
          "example": "            >>> # Merge duplicate sense into main sense\n            >>> keep = project.Senses.Find(...)\n            >>> remove = project.Senses.Find(...)\n            >>> project.Senses.MergeObject(keep, remove, fLoseNoStringData=True)\n            >>> # 'remove' is now deleted, data merged into 'keep'\n\n            >>> # Result with fLoseNoStringData=True:\n            >>> # Definition: \"defn 1; defn 2\" (SEMICOLON separator!)\n            >>> # Gloss: \"gloss 1; gloss 2\" (SEMICOLON separator!)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MovePicture",
          "signature": "MovePicture(picture, from_sense_or_hvo, to_sense_or_hvo)",
          "summary": "Move a picture from one sense to another sense.",
          "description": "Move a picture from one sense to another sense.\n\nThis is useful when reorganizing sense structure or correcting misplaced pictures.\nThe picture object itself is moved (not copied), preserving its caption and file reference.\n",
          "parameters": [
            {
              "name": "picture",
              "type": "",
              "default": null,
              "description": "The ICmPicture object to move."
            },
            {
              "name": "from_sense_or_hvo",
              "type": "",
              "default": null,
              "description": "Source ILexSense object or HVO."
            },
            {
              "name": "to_sense_or_hvo",
              "type": "",
              "default": null,
              "description": "Destination ILexSense object or HVO."
            }
          ],
          "returns": "bool: True if move was successful, False if source and destination are the same. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If any parameter is None.",
            "FP_ParameterError: If picture not in source sense's collection."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if len(senses) >= 2:\n            ...     # Move picture from one sense to another\n            ...     sense1 = senses[0]  # \"to run (move fast)\"\n            ...     sense2 = senses[1]  # \"to run (operate a machine)\"\n            ...     pictures = project.Senses.GetPictures(sense1)\n            ...\n            ...     if pictures:\n            ...         # Move the picture of a person running to the correct sense\n            ...         success = project.Senses.MovePicture(pictures[0], sense1, sense2)\n            ...\n            ...         # Verify the move\n            ...         print(f\"Move successful: {success}\")\n            ...         print(f\"Sense 1 pictures: {project.Senses.GetPictureCount(sense1)}\")\n            ...         print(f\"Sense 2 pictures: {project.Senses.GetPictureCount(sense2)}\")\n            Move successful: True\n            Sense 1 pictures: 0\n            Sense 2 pictures: 1\n\n            >>> # Can also move between entries\n            >>> entry2 = list(project.LexiconAllEntries())[1]\n            >>> other_sense = entry2.SensesOS[0]\n            >>> project.Senses.MovePicture(pictures[1], sense1, other_sense)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveAnthroCode",
          "signature": "RemoveAnthroCode(sense_or_hvo, anthro_code)",
          "summary": "Remove an anthropology code from a sense.",
          "description": "Remove an anthropology code from a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "anthro_code",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveDomainType",
          "signature": "RemoveDomainType(sense_or_hvo, domain_type)",
          "summary": "Remove a domain type from a sense.",
          "description": "Remove a domain type from a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "domain_type",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemovePicture",
          "signature": "RemovePicture(sense_or_hvo, picture, delete_file=False)",
          "summary": "Remove a picture from a lexical sense.",
          "description": "Remove a picture from a lexical sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "picture",
              "type": "",
              "default": null,
              "description": "The ICmPicture object to remove."
            },
            {
              "name": "delete_file",
              "type": "bool",
              "default": false,
              "description": "If True, also delete the physical image file (default: False)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or picture is None.",
            "FP_ParameterError: If picture not in sense's collection."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     pictures = project.Senses.GetPictures(senses[0])\n            ...     if pictures:\n            ...         # Remove picture but keep file\n            ...         project.Senses.RemovePicture(senses[0], pictures[0])\n            ...\n            ...         # Remove picture AND delete file\n            ...         project.Senses.RemovePicture(senses[0], pictures[1], delete_file=True)\n\n        Warning:\n            - With delete_file=True, the image is permanently deleted from disk\n            - Other senses or objects referencing the same file will lose access\n            - Deletion cannot be undone\n            - Use delete_file=True with caution\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveSemanticDomain",
          "signature": "RemoveSemanticDomain(sense_or_hvo, domain_or_hvo)",
          "summary": "Remove a semantic domain from a sense.",
          "description": "Remove a semantic domain from a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or domain_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     domains = project.Senses.GetSemanticDomains(senses[0])\n            ...     if domains:\n            ...         # Remove first domain\n            ...         project.Senses.RemoveSemanticDomain(senses[0], domains[0])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveUsageType",
          "signature": "RemoveUsageType(sense_or_hvo, usage_type)",
          "summary": "Remove a usage type from a sense.",
          "description": "Remove a usage type from a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "usage_type",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RenamePicture",
          "signature": "RenamePicture(picture, new_filename)",
          "summary": "Rename the image file for a picture and update the reference.",
          "description": "Rename the image file for a picture and update the reference.\n\nThis renames the physical file in the LinkedFiles/Pictures directory\nand updates the ICmFile reference to point to the new filename.\n",
          "parameters": [
            {
              "name": "picture",
              "type": "",
              "default": null,
              "description": "The ICmPicture object."
            },
            {
              "name": "new_filename",
              "type": "str",
              "default": null,
              "description": "The new filename for the image (e.g., \"dog_brown.jpg\")."
            }
          ],
          "returns": "str: The new internal path to the renamed file. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If picture or new_filename is None.",
            "FP_ParameterError: If picture has no associated file, or rename fails."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     pictures = project.Senses.GetPictures(senses[0])\n            ...     if pictures:\n            ...         # Rename the picture file\n            ...         new_path = project.Senses.RenamePicture(pictures[0], \"dog_brown.jpg\")\n            ...         print(f\"Renamed to: {new_path}\")\n            Renamed to: Pictures/dog_brown.jpg\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Reorder",
          "signature": "Reorder(entry_or_hvo, sense_list)",
          "summary": "Reorder senses for a lexical entry.",
          "description": "Reorder senses for a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO."
            },
            {
              "name": "sense_list",
              "type": "",
              "default": null,
              "description": "List of ILexSense objects or HVOs in desired order."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If entry_or_hvo or sense_list is None.",
            "FP_ParameterError: If sense_list is empty or contains invalid senses."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if len(senses) > 1:\n            ...     # Reverse the order\n            ...     project.Senses.Reorder(entry, reversed(senses))\n            ...     # Verify new order\n            ...     for sense in project.Senses.GetAll(entry):\n            ...         print(project.Senses.GetGloss(sense))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAnthroNote",
          "signature": "SetAnthroNote(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the anthropology note of a sense.",
          "description": "Set the anthropology note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetBibliography",
          "signature": "SetBibliography(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the bibliography of a sense.",
          "description": "Set the bibliography of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetCaption",
          "signature": "SetCaption(picture, caption, wsHandle=None)",
          "summary": "Set or update the caption for a picture.",
          "description": "Set or update the caption for a picture.\n",
          "parameters": [
            {
              "name": "picture",
              "type": "",
              "default": null,
              "description": "The ICmPicture object."
            },
            {
              "name": "caption",
              "type": "str",
              "default": null,
              "description": "The caption text to set."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If picture or caption is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     pictures = project.Senses.GetPictures(senses[0])\n            ...     if pictures:\n            ...         # Set caption in default vernacular\n            ...         project.Senses.SetCaption(pictures[0], \"A brown dog\")\n            ...\n            ...         # Set caption in specific writing system\n            ...         project.Senses.SetCaption(pictures[0], \"Un chien brun\",\n            ...                                   project.WSHandle('fr'))\n            ...\n            ...         # Verify\n            ...         caption = project.Senses.GetCaption(pictures[0])\n            ...         print(f\"Caption: {caption}\")\n            Caption: A brown dog\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDefinition",
          "signature": "SetDefinition(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the definition for a sense.",
          "description": "Set the definition for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new definition text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or text is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     defn = \"To move swiftly on foot by alternately setting each foot forward\"\n            ...     project.Senses.SetDefinition(senses[0], defn)\n            ...     print(project.Senses.GetDefinition(senses[0]))\n            To move swiftly on foot by alternately setting each foot forward\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDiscourseNote",
          "signature": "SetDiscourseNote(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the discourse note of a sense.",
          "description": "Set the discourse note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetEncyclopedicInfo",
          "signature": "SetEncyclopedicInfo(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the encyclopedic info of a sense.",
          "description": "Set the encyclopedic info of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetGeneralNote",
          "signature": "SetGeneralNote(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the general note of a sense.",
          "description": "Set the general note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetGloss",
          "signature": "SetGloss(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the gloss for a sense.",
          "description": "Set the gloss for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new gloss text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or text is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     project.Senses.SetGloss(senses[0], \"to run quickly\")\n            ...     print(project.Senses.GetGloss(senses[0]))\n            to run quickly\n\n            >>> # Set gloss in multiple writing systems\n            >>> project.Senses.SetGloss(senses[0], \"courir\",\n            ...                         project.WSHandle('fr'))\n            >>> project.Senses.SetGloss(senses[0], \"correr\",\n            ...                         project.WSHandle('es'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetGrammarNote",
          "signature": "SetGrammarNote(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the grammar note of a sense.",
          "description": "Set the grammar note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetGrammaticalInfo",
          "signature": "SetGrammaticalInfo(sense_or_hvo, msa)",
          "summary": "Set the full grammatical information (MSA) for a sense.",
          "description": "Set the full grammatical information (MSA) for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "msa",
              "type": "",
              "default": null,
              "description": "The IMoMorphSynAnalysis object to set."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses and len(senses) > 1:\n            ...     # Copy MSA from another sense\n            ...     msa = project.Senses.GetGrammaticalInfo(senses[0])\n            ...     if msa:\n            ...         project.Senses.SetGrammaticalInfo(senses[1], msa)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetImportResidue",
          "signature": "SetImportResidue(sense_or_hvo, text)",
          "summary": "Set the import residue of a sense.",
          "description": "Set the import residue of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetPartOfSpeech",
          "signature": "SetPartOfSpeech(sense_or_hvo, pos)",
          "summary": "Set the part of speech for a sense.",
          "description": "Set the part of speech for a sense.\n\nCreates or updates the MSA (Morphosyntactic Analysis) for the sense\nwith the specified part of speech category.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "pos",
              "type": "",
              "default": null,
              "description": "The IPartOfSpeech object or HVO to set."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo or pos is None.",
            "FP_ParameterError: If pos is invalid."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     # Get verb POS\n            ...     verb_pos = project.POS.Find(\"Verb\")\n            ...     if verb_pos:\n            ...         project.Senses.SetPartOfSpeech(senses[0], verb_pos)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetPhonologyNote",
          "signature": "SetPhonologyNote(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the phonology note of a sense.",
          "description": "Set the phonology note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetRestrictions",
          "signature": "SetRestrictions(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the restrictions of a sense.",
          "description": "Set the restrictions of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetScientificName",
          "signature": "SetScientificName(sense_or_hvo, text)",
          "summary": "Set the scientific name of a sense.",
          "description": "Set the scientific name of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetSemanticsNote",
          "signature": "SetSemanticsNote(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the semantics note of a sense.",
          "description": "Set the semantics note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetSenseType",
          "signature": "SetSenseType(sense_or_hvo, sense_type)",
          "summary": "Set the sense type for a sense.",
          "description": "Set the sense type for a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "sense_type",
              "type": "",
              "default": null,
              "description": "The ICmPossibility sense type object to set."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     # Get sense type possibilities\n            ...     flid = project.GetFieldID(\"LexSense\", \"SenseType\")\n            ...     types = project.ListFieldPossibilities(senses[0], flid)\n            ...     if types:\n            ...         # Set to a specific type (e.g., Figurative)\n            ...         project.Senses.SetSenseType(senses[0], types[1])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetSocioLinguisticsNote",
          "signature": "SetSocioLinguisticsNote(sense_or_hvo, text, wsHandle=None)",
          "summary": "Set the socio-linguistics note of a sense.",
          "description": "Set the socio-linguistics note of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetSource",
          "signature": "SetSource(sense_or_hvo, text)",
          "summary": "Set the source of a sense.",
          "description": "Set the source of a sense.",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "text",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetStatus",
          "signature": "SetStatus(sense_or_hvo, status)",
          "summary": "Set the status of a sense.",
          "description": "Set the status of a sense.\n",
          "parameters": [
            {
              "name": "sense_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexSense object or HVO."
            },
            {
              "name": "status",
              "type": "",
              "default": null,
              "description": "The ICmPossibility status object to set."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If sense_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> senses = list(project.Senses.GetAll(entry))\n            >>> if senses:\n            ...     # Get status possibilities\n            ...     flid = project.GetFieldID(\"LexSense\", \"Status\")\n            ...     statuses = project.ListFieldPossibilities(senses[0], flid)\n            ...     if statuses:\n            ...         # Set to first status (e.g., Approved)\n            ...         project.Senses.SetStatus(senses[0], statuses[0])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize LexSenseOperations with a FLExProject instance.",
          "description": "Initialize LexSenseOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "PronunciationOperations": {
      "name": "PronunciationOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.PronunciationOperations",
      "source_file": "Lexicon/PronunciationOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing pronunciations in a FieldWorks project.",
      "description": "This class provides operations for managing pronunciations in a FieldWorks project.\n\nPronunciations represent the phonetic representation of lexical entries, typically\nusing IPA (International Phonetic Alphabet) notation. Each pronunciation can have\nforms in multiple writing systems (e.g., en-fonipa for IPA), associated audio files,\nand optional CV (consonant-vowel) pattern location information.\n\nThis class should be accessed via FLExProject.Pronunciations property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all pronunciations for an entry\nentry = list(project.LexiconAllEntries())[0]\nfor pron in project.Pronunciations.GetAll(entry):\nipa = project.Pronunciations.GetForm(pron, \"en-fonipa\")\nprint(f\"IPA: {ipa}\")\n\n# Create a new pronunciation\npron = project.Pronunciations.Create(entry, \"rn\", \"en-fonipa\")\n\n# Add audio file\nproject.Pronunciations.AddMediaFile(pron, \"/path/to/audio.wav\")\n\n# Get media files\nmedia = project.Pronunciations.GetMediaFiles(pron)\nprint(f\"Audio files: {len(media)}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddMediaFile",
          "signature": "AddMediaFile(pronunciation_or_hvo, file_path, label=None)",
          "summary": "Add a media file (typically audio) to a pronunciation.",
          "description": "Add a media file (typically audio) to a pronunciation.\n\nCopies the file to the project's LinkedFiles directory and creates\na media reference linked to the pronunciation.\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            },
            {
              "name": "file_path",
              "type": "str",
              "default": null,
              "description": "Path to the external media file to import."
            },
            {
              "name": "label",
              "type": "str, optional",
              "default": null,
              "description": "Descriptive label for the media file."
            }
          ],
          "returns": "ICmFile: The created media file object with proper path. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pronunciation_or_hvo or file_path is None.",
            "FP_ParameterError: If file_path is empty or file doesn't exist."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> # Add audio recording\n            >>> media = project.Pronunciations.AddMediaFile(\n            ...     pron,\n            ...     \"/path/to/audio.wav\",\n            ...     label=\"Speaker pronunciation\"\n            ... )\n            >>> print(f\"Added media file\")\n            Added media file\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two pronunciations and return their differences.",
          "description": "Compare two pronunciations and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first ILexPronunciation object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second ILexPronunciation object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional PronunciationOperations instance for item1."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional PronunciationOperations instance for item2."
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(entry_or_hvo, form, wsHandle=None)",
          "summary": "Create a new pronunciation for a lexical entry.",
          "description": "Create a new pronunciation for a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO."
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The pronunciation form (typically IPA notation)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Use \"en-fonipa\" for IPA, or defaults to vernacular WS."
            }
          ],
          "returns": "ILexPronunciation: The newly created pronunciation object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If entry_or_hvo or form is None.",
            "FP_ParameterError: If form is empty."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> # Create IPA pronunciation\n            >>> pron = project.Pronunciations.Create(entry, \"rn\", \"en-fonipa\")\n            >>> print(project.Pronunciations.GetForm(pron, \"en-fonipa\"))\n            rn\n\n            >>> # Create with default WS\n            >>> pron = project.Pronunciations.Create(entry, \"run\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(pronunciation_or_hvo)",
          "summary": "Delete a pronunciation.",
          "description": "Delete a pronunciation.\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pronunciation_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> pronunciations = list(project.Pronunciations.GetAll(entry))\n            >>> if pronunciations:\n            ...     project.Pronunciations.Delete(pronunciations[0])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a pronunciation, creating a new copy with a new GUID.",
          "description": "Duplicate a pronunciation, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source pronunciation. If False, insert at end of parent's pronunciations list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (media files). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "ILexPronunciation: The newly created duplicate pronunciation with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> pronunciations = list(project.Pronunciations.GetAll(entry))\n            >>> if pronunciations:\n            ...     # Shallow duplicate (no media files)\n            ...     dup = project.Pronunciations.Duplicate(pronunciations[0])\n            ...     print(f\"Original: {project.Pronunciations.GetGuid(pronunciations[0])}\")\n            ...     print(f\"Duplicate: {project.Pronunciations.GetGuid(dup)}\")\n            ...     ipa = project.Pronunciations.GetForm(dup, \"en-fonipa\")\n            ...     print(f\"IPA: {ipa}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n            IPA: rn\n            ...\n            ...     # Deep duplicate (includes media files)\n            ...     deep_dup = project.Pronunciations.Duplicate(pronunciations[0], deep=True)\n            ...     count = project.Pronunciations.GetMediaCount(deep_dup)\n            ...     print(f\"Media files: {count}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(entry_or_hvo=None)",
          "summary": "Get all pronunciations for a lexical entry, or all pronunciations in the entire project.",
          "description": "Get all pronunciations for a lexical entry, or all pronunciations in the entire project.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO. If None, iterates all pronunciations in the entire project."
            }
          ],
          "returns": "ILexPronunciation: Each pronunciation for the entry (or project). ",
          "raises": [],
          "example": "            >>> # Get pronunciations for specific entry\n            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> for pron in project.Pronunciations.GetAll(entry):\n            ...     ipa = project.Pronunciations.GetForm(pron, \"en-fonipa\")\n            ...     print(f\"IPA: {ipa}\")\n            IPA: rn\n            IPA: n\n\n            >>> # Get ALL pronunciations in entire project\n            >>> for pron in project.Pronunciations.GetAll():\n            ...     ipa = project.Pronunciations.GetForm(pron, \"en-fonipa\")\n            ...     print(f\"IPA: {ipa}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(pronunciation_or_hvo, wsHandle=None)",
          "summary": "Get the pronunciation form (e.",
          "description": "Get the pronunciation form (e.g., IPA transcription).\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle or tag (e.g., \"en-fonipa\" for IPA). Defaults to vernacular WS."
            }
          ],
          "returns": "str: The pronunciation form text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If pronunciation_or_hvo is None."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> # Get IPA form\n            >>> ipa = project.Pronunciations.GetForm(pron, \"en-fonipa\")\n            >>> print(f\"IPA: {ipa}\")\n            IPA: rn\n\n            >>> # Get default WS form\n            >>> form = project.Pronunciations.GetForm(pron)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(pronunciation_or_hvo)",
          "summary": "Get the GUID of a pronunciation.",
          "description": "Get the GUID of a pronunciation.\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            }
          ],
          "returns": "System.Guid: The GUID of the pronunciation. ",
          "raises": [
            "FP_NullParameterError: If pronunciation_or_hvo is None."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> guid = project.Pronunciations.GetGuid(pron)\n            >>> print(f\"Pronunciation GUID: {guid}\")\n            Pronunciation GUID: 12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLocation",
          "signature": "GetLocation(pronunciation_or_hvo)",
          "summary": "Get the CV pattern location for the pronunciation.",
          "description": "Get the CV pattern location for the pronunciation.\n\nThe location refers to where in a CV (consonant-vowel) pattern analysis\nthis pronunciation applies. This is used in phonological analysis.\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            }
          ],
          "returns": "object: The location object, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If pronunciation_or_hvo is None."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> location = project.Pronunciations.GetLocation(pron)\n            >>> if location:\n            ...     print(f\"CV Location: {location}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMediaCount",
          "signature": "GetMediaCount(pronunciation_or_hvo)",
          "summary": "Get the count of media files associated with a pronunciation.",
          "description": "Get the count of media files associated with a pronunciation.\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            }
          ],
          "returns": "int: The number of media files. ",
          "raises": [
            "FP_NullParameterError: If pronunciation_or_hvo is None."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> count = project.Pronunciations.GetMediaCount(pron)\n            >>> print(f\"This pronunciation has {count} audio files\")\n            This pronunciation has 2 audio files\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMediaFiles",
          "signature": "GetMediaFiles(pronunciation_or_hvo)",
          "summary": "Get all media files (typically audio) associated with a pronunciation.",
          "description": "Get all media files (typically audio) associated with a pronunciation.\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            }
          ],
          "returns": "list: List of media file objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If pronunciation_or_hvo is None."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> media = project.Pronunciations.GetMediaFiles(pron)\n            >>> for m in media:\n            ...     print(f\"Media: {m}\")\n            Media: audio_recording.wav\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwningEntry",
          "signature": "GetOwningEntry(pronunciation_or_hvo)",
          "summary": "Get the lexical entry that owns this pronunciation.",
          "description": "Get the lexical entry that owns this pronunciation.\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            }
          ],
          "returns": "ILexEntry: The owning entry object. ",
          "raises": [
            "FP_NullParameterError: If pronunciation_or_hvo is None."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> owner = project.Pronunciations.GetOwningEntry(pron)\n            >>> headword = project.LexEntry.GetHeadword(owner)\n            >>> print(f\"Pronunciation belongs to: {headword}\")\n            Pronunciation belongs to: run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a pronunciation for comparison.",
          "description": "Get all syncable properties of a pronunciation for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values.",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveMediaFile",
          "signature": "MoveMediaFile(media, from_pronunciation_or_hvo, to_pronunciation_or_hvo)",
          "summary": "Move a media file from one pronunciation to another pronunciation.",
          "description": "Move a media file from one pronunciation to another pronunciation.\n\nThis is useful when reorganizing pronunciations or moving audio recordings to the\ncorrect pronunciation variant.\n",
          "parameters": [
            {
              "name": "media",
              "type": "",
              "default": null,
              "description": "ICmFile object to move"
            },
            {
              "name": "from_pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "Source ILexPronunciation object or HVO"
            },
            {
              "name": "to_pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "Destination ILexPronunciation object or HVO"
            }
          ],
          "returns": "bool: True if media was successfully moved, False if source and destination are the same pronunciation (no-op) ",
          "raises": [
            "FP_ReadOnlyError: If project not writable",
            "FP_ParameterError: If media not in source pronunciation's collection"
          ],
          "example": "            >>> # Move audio from one pronunciation to another\n            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> pron1 = entry.PronunciationsOS[0]  # IPA: [rn]\n            >>> pron2 = entry.PronunciationsOS[1]  # IPA: [n]\n            >>>\n            >>> media_files = project.Pronunciations.GetMediaFiles(pron1)\n            >>> # Move the audio to the correct pronunciation variant\n            >>> project.Pronunciations.MoveMediaFile(media_files[0], pron1, pron2)\n            >>>\n            >>> # Verify the move\n            >>> print(f\"Pron 1 media: {project.Pronunciations.GetMediaCount(pron1)}\")\n            >>> print(f\"Pron 2 media: {project.Pronunciations.GetMediaCount(pron2)}\")\n\n            >>> # Can also move between different entries\n            >>> entry2 = list(project.LexiconAllEntries())[1]\n            >>> other_pron = entry2.PronunciationsOS[0]\n            >>> project.Pronunciations.MoveMediaFile(media_files[1], pron1, other_pron)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveMediaFile",
          "signature": "RemoveMediaFile(pronunciation_or_hvo, media_or_hvo)",
          "summary": "Remove a media file from a pronunciation.",
          "description": "Remove a media file from a pronunciation.\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            },
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmFile object or HVO to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pronunciation_or_hvo or media_or_hvo is None."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> media_files = project.Pronunciations.GetMediaFiles(pron)\n            >>> if media_files:\n            ...     project.Pronunciations.RemoveMediaFile(pron, media_files[0])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Reorder",
          "signature": "Reorder(entry_or_hvo, pronunciation_list)",
          "summary": "Reorder pronunciations for a lexical entry.",
          "description": "Reorder pronunciations for a lexical entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO."
            },
            {
              "name": "pronunciation_list",
              "type": "",
              "default": null,
              "description": "List of ILexPronunciation objects in desired order."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If entry_or_hvo or pronunciation_list is None.",
            "FP_ParameterError: If pronunciation_list is invalid or contains",
            "pronunciations not owned by this entry."
          ],
          "example": "            >>> entry = list(project.LexiconAllEntries())[0]\n            >>> prons = list(project.Pronunciations.GetAll(entry))\n            >>> if len(prons) > 1:\n            ...     # Reverse the order\n            ...     project.Pronunciations.Reorder(entry, list(reversed(prons)))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetForm",
          "signature": "SetForm(pronunciation_or_hvo, text, wsHandle=None)",
          "summary": "Set the pronunciation form (e.",
          "description": "Set the pronunciation form (e.g., IPA transcription).\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The pronunciation form text (typically IPA notation)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle or tag (e.g., \"en-fonipa\" for IPA). Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pronunciation_or_hvo or text is None."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> # Set IPA form\n            >>> project.Pronunciations.SetForm(pron, \"n\", \"en-fonipa\")\n\n            >>> # Update default WS form\n            >>> project.Pronunciations.SetForm(pron, \"run\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLocation",
          "signature": "SetLocation(pronunciation_or_hvo, location)",
          "summary": "Set the CV pattern location for the pronunciation.",
          "description": "Set the CV pattern location for the pronunciation.\n",
          "parameters": [
            {
              "name": "pronunciation_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexPronunciation object or HVO."
            },
            {
              "name": "location",
              "type": "",
              "default": null,
              "description": "The location object (phonological environment) to set, or None to clear."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If pronunciation_or_hvo is None."
          ],
          "example": "            >>> pron = list(project.Pronunciations.GetAll(entry))[0]\n            >>> # Set location (requires a valid phonological environment object)\n            >>> # env = project.Environments.Find(\"word-final\")\n            >>> # project.Pronunciations.SetLocation(pron, env)\n\n            >>> # Clear location\n            >>> project.Pronunciations.SetLocation(pron, None)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize PronunciationOperations with a FLExProject instance.",
          "description": "Initialize PronunciationOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "ReversalOperations": {
      "name": "ReversalOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.ReversalOperations",
      "source_file": "Lexicon/ReversalOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing reversal entries in a\nFieldWorks project.",
      "description": "This class provides operations for managing reversal entries in a\nFieldWorks project.\n\nReversal entries allow users to look up vernacular words from analysis\nlanguage glosses. Each reversal index corresponds to a specific writing\nsystem (e.g., English, French) and contains entries that link back to\nlexical senses.\n\nThis class should be accessed via FLExProject.Reversal property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all reversal indexes\nfor index in project.Reversal.GetAllIndexes():\nws = index.WritingSystem\nprint(f\"Reversal index: {ws}\")\n\n# Get English reversal index\nen_index = project.Reversal.GetIndex(\"en\")\nif en_index:\n# Get all entries in this index\nfor entry in project.Reversal.GetAll(en_index):\nform = project.Reversal.GetForm(entry)\nprint(f\"Reversal: {form}\")\n\n# Create a new reversal entry\nentry = project.Reversal.Create(en_index, \"run\", \"en\")\n\n# Link to a sense\nlexentry = project.LexEntry.Find(\"run\")\nif lexentry:\nsenses = project.LexEntry.GetSenses(lexentry)\nif senses:\nproject.Reversal.AddSense(entry, senses[0])\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddSense",
          "signature": "AddSense(reversal_entry, sense)",
          "summary": "Link a lexical sense to a reversal entry.",
          "description": "Link a lexical sense to a reversal entry.\n\nThis creates a bidirectional link between the reversal entry and\nthe lexical sense, allowing lookup in both directions.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object."
            },
            {
              "name": "sense",
              "type": "",
              "default": null,
              "description": "The ILexSense object to link."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If reversal_entry or sense is None."
          ],
          "example": "            >>> # Create reversal entry and link to sense\n            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Create(en_index, \"run\")\n            >>>\n            >>> # Find lexical entry and get its sense\n            >>> lexentry = project.LexEntry.Find(\"run\")\n            >>> if lexentry:\n            ...     senses = project.LexEntry.GetSenses(lexentry)\n            ...     if senses:\n            ...         project.Reversal.AddSense(entry, senses[0])\n            ...         print(f\"Linked {len(project.Reversal.GetSenses(entry))} senses\")\n            Linked 1 senses\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two reversal entries and return their differences.",
          "description": "Compare two reversal entries and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first IReversalIndexEntry object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second IReversalIndexEntry object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional ReversalOperations instance for item1."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional ReversalOperations instance for item2."
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(reversal_index, form, ws=None)",
          "summary": "Create a new reversal entry in a reversal index.",
          "description": "Create a new reversal entry in a reversal index.\n",
          "parameters": [
            {
              "name": "reversal_index",
              "type": "",
              "default": null,
              "description": "The IReversalIndex object to add the entry to."
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The reversal form text (e.g., \"run\", \"walk\")."
            },
            {
              "name": "ws",
              "type": "str or int",
              "default": null,
              "description": "Optional writing system tag or handle. If None, uses the reversal index's writing system."
            }
          ],
          "returns": "IReversalIndexEntry: The newly created reversal entry object. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If reversal_index or form is None.",
            "FP_ParameterError: If form is empty."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> if en_index:\n            ...     # Create a reversal entry\n            ...     entry = project.Reversal.Create(en_index, \"run\")\n            ...     print(f\"Created: {project.Reversal.GetForm(entry)}\")\n            Created: run\n\n            >>> # Create with explicit writing system\n            >>> entry2 = project.Reversal.Create(en_index, \"walk\", \"en\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateSubentry",
          "signature": "CreateSubentry(parent_entry, form, ws=None)",
          "summary": "Create a new subentry under a parent reversal entry.",
          "description": "Create a new subentry under a parent reversal entry.\n",
          "parameters": [
            {
              "name": "parent_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object (parent)."
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The reversal form text for the subentry."
            },
            {
              "name": "ws",
              "type": "str or int",
              "default": null,
              "description": "Optional writing system tag or handle. If None, uses the parent entry's reversal index writing system."
            }
          ],
          "returns": "IReversalIndexEntry: The newly created subentry object. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If parent_entry or form is None.",
            "FP_ParameterError: If form is empty."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> parent = project.Reversal.Find(en_index, \"run\")\n            >>> if parent:\n            ...     # Create subentry for \"run away\"\n            ...     subentry = project.Reversal.CreateSubentry(parent, \"run away\")\n            ...     print(f\"Created subentry: {project.Reversal.GetForm(subentry)}\")\n            Created subentry: run away\n\n            >>> # Subentries can have their own senses\n            >>> lexentry = project.LexEntry.Find(\"run away\")\n            >>> if lexentry:\n            ...     senses = project.LexEntry.GetSenses(lexentry)\n            ...     if senses:\n            ...         project.Reversal.AddSense(subentry, senses[0])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(reversal_entry)",
          "summary": "Delete a reversal entry from its reversal index.",
          "description": "Delete a reversal entry from its reversal index.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If reversal_entry is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Find(en_index, \"obsolete\")\n            >>> if entry:\n            ...     project.Reversal.Delete(entry)\n\n        Warning:\n            - This is a destructive operation\n            - All subentries will also be deleted\n            - Links to senses will be removed\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a reversal entry, creating a new copy with a new GUID.",
          "description": "Duplicate a reversal entry, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source entry. If False, insert at end of parent's entry list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (subentries). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "IReversalIndexEntry: The newly created duplicate entry with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Find(en_index, \"run\")\n            >>> if entry:\n            ...     # Shallow duplicate (no subentries)\n            ...     dup = project.Reversal.Duplicate(entry)\n            ...     form = project.Reversal.GetForm(dup)\n            ...     print(f\"Duplicate form: {form}\")\n            Duplicate form: run\n            ...\n            ...     # Deep duplicate (includes all subentries)\n            ...     deep_dup = project.Reversal.Duplicate(entry, deep=True)\n            ...     subentries = project.Reversal.GetSubentries(deep_dup)\n            ...     print(f\"Subentries: {len(subentries)}\")\n            Subentries: 3\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(reversal_index, form, ws=None)",
          "summary": "Check if a reversal entry with the given form exists.",
          "description": "Check if a reversal entry with the given form exists.\n",
          "parameters": [
            {
              "name": "reversal_index",
              "type": "",
              "default": null,
              "description": "The IReversalIndex object to search in."
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The reversal form text to check."
            },
            {
              "name": "ws",
              "type": "str or int",
              "default": null,
              "description": "Optional writing system tag or handle. If None, uses the reversal index's writing system."
            }
          ],
          "returns": "bool: True if an entry exists with this form, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If reversal_index or form is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> if not project.Reversal.Exists(en_index, \"run\"):\n            ...     entry = project.Reversal.Create(en_index, \"run\")\n            >>> else:\n            ...     print(\"Entry already exists\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(reversal_index, form, ws=None)",
          "summary": "Find a reversal entry by its form text.",
          "description": "Find a reversal entry by its form text.\n",
          "parameters": [
            {
              "name": "reversal_index",
              "type": "",
              "default": null,
              "description": "The IReversalIndex object to search in."
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The reversal form text to search for."
            },
            {
              "name": "ws",
              "type": "str or int",
              "default": null,
              "description": "Optional writing system tag or handle. If None, uses the reversal index's writing system."
            }
          ],
          "returns": "IReversalIndexEntry or None: The entry object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If reversal_index or form is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Find(en_index, \"run\")\n            >>> if entry:\n            ...     senses = project.Reversal.GetSenses(entry)\n            ...     print(f\"Found 'run' with {len(senses)} senses\")\n            Found 'run' with 3 senses\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindIndex",
          "signature": "FindIndex(ws)",
          "summary": "Find a reversal index by writing system (alias for GetIndex).",
          "description": "Find a reversal index by writing system (alias for GetIndex).\n",
          "parameters": [
            {
              "name": "ws",
              "type": "str",
              "default": null,
              "description": "The writing system language tag (e.g., \"en\", \"fr\", \"es\")."
            }
          ],
          "returns": "IReversalIndex or None: The reversal index object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If ws is None."
          ],
          "example": "            >>> index = project.Reversal.FindIndex(\"en\")\n            >>> if index:\n            ...     print(f\"Found index for {index.WritingSystem}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(reversal_index)",
          "summary": "Get all reversal entries in a reversal index.",
          "description": "Get all reversal entries in a reversal index.\n",
          "parameters": [
            {
              "name": "reversal_index",
              "type": "",
              "default": null,
              "description": "The IReversalIndex object."
            }
          ],
          "returns": "list: List of IReversalIndexEntry objects. ",
          "raises": [
            "FP_NullParameterError: If reversal_index is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> if en_index:\n            ...     for entry in project.Reversal.GetAll(en_index):\n            ...         form = project.Reversal.GetForm(entry)\n            ...         senses = project.Reversal.GetSenses(entry)\n            ...         print(f\"{form}: {len(senses)} senses\")\n            run: 3 senses\n            walk: 2 senses\n            house: 1 senses\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllIndexes",
          "signature": "GetAllIndexes()",
          "summary": "Get all reversal indexes in the project.",
          "description": "Get all reversal indexes in the project.\n\nA reversal index allows looking up vernacular words from analysis\nlanguage glosses. Each index is tied to a specific writing system\n(e.g., English, French, Spanish).\n",
          "parameters": [],
          "returns": "list: List of IReversalIndex objects. ",
          "raises": [],
          "example": "            >>> for index in project.Reversal.GetAllIndexes():\n            ...     ws = index.WritingSystem\n            ...     count = index.EntriesOC.Count\n            ...     print(f\"{ws}: {count} entries\")\n            en: 245 entries\n            fr: 132 entries\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(reversal_entry, ws=None)",
          "summary": "Get the reversal form text of a reversal entry.",
          "description": "Get the reversal form text of a reversal entry.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object."
            },
            {
              "name": "ws",
              "type": "str or int",
              "default": null,
              "description": "Optional writing system tag or handle. If None, uses the entry's reversal index writing system."
            }
          ],
          "returns": "str: The reversal form text (empty string if not set). ",
          "raises": [
            "FP_NullParameterError: If reversal_entry is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> for entry in project.Reversal.GetAll(en_index):\n            ...     form = project.Reversal.GetForm(entry)\n            ...     print(f\"Reversal: {form}\")\n            Reversal: run\n            Reversal: walk\n            Reversal: house\n\n            >>> # Get in specific writing system\n            >>> form_en = project.Reversal.GetForm(entry, \"en\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetIndex",
          "signature": "GetIndex(ws)",
          "summary": "Get the reversal index for a specific writing system.",
          "description": "Get the reversal index for a specific writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "str",
              "default": null,
              "description": "The writing system language tag (e.g., \"en\", \"fr\", \"es\")."
            }
          ],
          "returns": "IReversalIndex or None: The reversal index object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If ws is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> if en_index:\n            ...     print(f\"English reversal index has {en_index.EntriesOC.Count} entries\")\n            English reversal index has 245 entries\n\n            >>> # Check if index exists\n            >>> fr_index = project.Reversal.GetIndex(\"fr\")\n            >>> if not fr_index:\n            ...     print(\"No French reversal index\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParentEntry",
          "signature": "GetParentEntry(reversal_entry)",
          "summary": "Get the parent reversal entry of a subentry.",
          "description": "Get the parent reversal entry of a subentry.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object (subentry)."
            }
          ],
          "returns": "IReversalIndexEntry or None: The parent entry if this is a subentry, None if this is a top-level entry. ",
          "raises": [
            "FP_NullParameterError: If reversal_entry is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> subentry = project.Reversal.Find(en_index, \"run away\")\n            >>> if subentry:\n            ...     parent = project.Reversal.GetParentEntry(subentry)\n            ...     if parent:\n            ...         form = project.Reversal.GetForm(parent)\n            ...         print(f\"Parent: {form}\")\n            ...     else:\n            ...         print(\"This is a top-level entry\")\n            Parent: run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPartsOfSpeech",
          "signature": "GetPartsOfSpeech(reversal_entry)",
          "summary": "Get all parts of speech associated with a reversal entry.",
          "description": "Get all parts of speech associated with a reversal entry.\n\nParts of speech can be specified for reversal entries to provide\ngrammatical information.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object."
            }
          ],
          "returns": "list: List of part of speech objects (IPartOfSpeech). ",
          "raises": [
            "FP_NullParameterError: If reversal_entry is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Find(en_index, \"run\")\n            >>> if entry:\n            ...     pos_list = project.Reversal.GetPartsOfSpeech(entry)\n            ...     for pos in pos_list:\n            ...         from SIL.LCModel.Core.KernelInterfaces import ITsString\n            ...         name = ITsString(pos.Name.BestAnalysisAlternative).Text\n            ...         print(f\"POS: {name}\")\n            POS: Verb\n            POS: Noun\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSenseCount",
          "signature": "GetSenseCount(reversal_entry)",
          "summary": "Get the count of senses linked to a reversal entry.",
          "description": "Get the count of senses linked to a reversal entry.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object."
            }
          ],
          "returns": "int: The number of senses linked to this entry (0 if none). ",
          "raises": [
            "FP_NullParameterError: If reversal_entry is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Find(en_index, \"run\")\n            >>> if entry:\n            ...     count = project.Reversal.GetSenseCount(entry)\n            ...     print(f\"Entry has {count} linked senses\")\n            Entry has 3 linked senses\n\n            >>> # Check if entry has senses\n            >>> if project.Reversal.GetSenseCount(entry) == 0:\n            ...     print(\"Entry has no linked senses - add one!\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSenses",
          "signature": "GetSenses(reversal_entry)",
          "summary": "Get all senses linked to a reversal entry.",
          "description": "Get all senses linked to a reversal entry.\n\nReversal entries link to lexical senses, allowing users to find\nvernacular words from analysis language glosses.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object."
            }
          ],
          "returns": "list: List of ILexSense objects linked to this reversal entry. ",
          "raises": [
            "FP_NullParameterError: If reversal_entry is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Find(en_index, \"run\")\n            >>> if entry:\n            ...     senses = project.Reversal.GetSenses(entry)\n            ...     for sense in senses:\n            ...         gloss = project.LexiconGetSenseGloss(sense)\n            ...         print(f\"Sense: {gloss}\")\n            Sense: to move rapidly on foot\n            Sense: to operate or function\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubentries",
          "signature": "GetSubentries(reversal_entry)",
          "summary": "Get all subentries of a reversal entry.",
          "description": "Get all subentries of a reversal entry.\n\nSubentries are nested reversal entries that represent compounds,\nphrases, or related terms under a main entry.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object (parent)."
            }
          ],
          "returns": "list: List of IReversalIndexEntry objects (children). ",
          "raises": [
            "FP_NullParameterError: If reversal_entry is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Find(en_index, \"run\")\n            >>> if entry:\n            ...     subentries = project.Reversal.GetSubentries(entry)\n            ...     for subentry in subentries:\n            ...         form = project.Reversal.GetForm(subentry)\n            ...         print(f\"  Subentry: {form}\")\n            Subentry: run away\n            Subentry: run into\n            Subentry: run out\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a reversal entry for comparison.",
          "description": "Get all syncable properties of a reversal entry for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values.",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveSense",
          "signature": "RemoveSense(reversal_entry, sense)",
          "summary": "Unlink a lexical sense from a reversal entry.",
          "description": "Unlink a lexical sense from a reversal entry.\n\nThis removes the bidirectional link between the reversal entry\nand the lexical sense.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object."
            },
            {
              "name": "sense",
              "type": "",
              "default": null,
              "description": "The ILexSense object to unlink."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If reversal_entry or sense is None."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Find(en_index, \"run\")\n            >>> if entry:\n            ...     senses = project.Reversal.GetSenses(entry)\n            ...     if senses:\n            ...         # Remove first sense\n            ...         project.Reversal.RemoveSense(entry, senses[0])\n            ...         print(f\"{len(project.Reversal.GetSenses(entry))} senses remain\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetForm",
          "signature": "SetForm(reversal_entry, text, ws=None)",
          "summary": "Set the reversal form text of a reversal entry.",
          "description": "Set the reversal form text of a reversal entry.\n",
          "parameters": [
            {
              "name": "reversal_entry",
              "type": "",
              "default": null,
              "description": "The IReversalIndexEntry object."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new reversal form text."
            },
            {
              "name": "ws",
              "type": "str or int",
              "default": null,
              "description": "Optional writing system tag or handle. If None, uses the entry's reversal index writing system."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If reversal_entry or text is None.",
            "FP_ParameterError: If text is empty."
          ],
          "example": "            >>> en_index = project.Reversal.GetIndex(\"en\")\n            >>> entry = project.Reversal.Find(en_index, \"runing\")  # typo\n            >>> if entry:\n            ...     project.Reversal.SetForm(entry, \"running\")\n            ...     print(f\"Updated: {project.Reversal.GetForm(entry)}\")\n            Updated: running\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ReversalOperations with a FLExProject instance.",
          "description": "Initialize ReversalOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "SemanticDomainOperations": {
      "name": "SemanticDomainOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.SemanticDomainOperations",
      "source_file": "Lexicon/SemanticDomainOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing semantic domains in a\nFieldWorks project.",
      "description": "This class provides operations for managing semantic domains in a\nFieldWorks project.\n\nSemantic domains are hierarchical categorizations of word meanings used\nto organize the lexicon semantically. Most projects use predefined domain\nlists (e.g., from SIL), but custom domains can also be created.\n\nThis class should be accessed via FLExProject.SemanticDomains property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all semantic domains (flat list)\nfor domain in project.SemanticDomains.GetAll(flat=True):\nnumber = project.SemanticDomains.GetNumber(domain)\nname = project.SemanticDomains.GetName(domain)\nprint(f\"{number} - {name}\")\n\n# Find a specific domain by number\ndomain = project.SemanticDomains.Find(\"7.2.1\")\nif domain:\nname = project.SemanticDomains.GetName(domain)\ndesc = project.SemanticDomains.GetDescription(domain)\nprint(f\"{name}: {desc}\")\n\n# Get all senses in a domain\nsenses = project.SemanticDomains.GetSensesInDomain(domain)\nprint(f\"Found {len(senses)} senses in this domain\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two semantic domains and return their differences.",
          "description": "Compare two semantic domains and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first ICmSemanticDomain object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second ICmSemanticDomain object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional SemanticDomainOperations instance for item1."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional SemanticDomainOperations instance for item2."
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, number, parent=None, wsHandle=None)",
          "summary": "Create a new custom semantic domain.",
          "description": "Create a new custom semantic domain.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the new domain."
            },
            {
              "name": "number",
              "type": "str",
              "default": null,
              "description": "The domain number (e.g., \"900.1\")."
            },
            {
              "name": "parent",
              "type": "",
              "default": null,
              "description": "Optional parent ICmSemanticDomain object or HVO. If None, creates a top-level domain."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmSemanticDomain: The newly created domain object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name or number is None.",
            "FP_ParameterError: If name or number is empty, or domain number",
            "already exists."
          ],
          "example": "            >>> # Create a top-level custom domain\n            >>> custom = project.SemanticDomains.Create(\"Technology\", \"900\")\n            >>> print(project.SemanticDomains.GetName(custom))\n            Technology\n\n            >>> # Create a subdomain\n            >>> computers = project.SemanticDomains.Create(\n            ...     \"Computers\", \"900.1\", parent=custom)\n            >>> print(project.SemanticDomains.GetNumber(computers))\n            900.1\n\n        Warning:\n            - Custom domain numbers should not conflict with standard domains\n            - Standard SIL domains use numbers 1-9\n            - Consider using 900+ for custom domains\n            - Creating many custom domains may impact performance\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(domain_or_hvo)",
          "summary": "Delete a semantic domain.",
          "description": "Delete a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> # Delete a custom domain\n            >>> custom = project.SemanticDomains.Find(\"900.1\")\n            >>> if custom:\n            ...     project.SemanticDomains.Delete(custom)\n\n        Warning:\n            - DO NOT delete standard semantic domains (1-9)\n            - Deletion is permanent and cannot be undone\n            - Deletes all subdomains recursively\n            - Senses using this domain will lose the domain reference\n            - Consider removing from senses first\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a semantic domain, creating a new copy with a new GUID.",
          "description": "Duplicate a semantic domain, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source domain. If False, insert at end of parent's subdomain list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (subdomains, examples). If False (default), only copy simple properties."
            }
          ],
          "returns": "ICmSemanticDomain: The newly created duplicate domain with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Shallow duplicate (no subdomains)\n            >>> domain = project.SemanticDomains.Find(\"900.1\")\n            >>> if domain:\n            ...     dup = project.SemanticDomains.Duplicate(domain)\n            ...     print(f\"Original: {project.SemanticDomains.GetNumber(domain)}\")\n            ...     print(f\"Duplicate: {project.SemanticDomains.GetNumber(dup)}\")\n            ...     # Note: Duplicate will have empty number - must be set manually\n            ...\n            ...     # Deep duplicate (includes all subdomains)\n            ...     deep_dup = project.SemanticDomains.Duplicate(domain, deep=True)\n            ...     subdomains = project.SemanticDomains.GetSubdomains(deep_dup)\n            ...     print(f\"Subdomains: {len(subdomains)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(number)",
          "summary": "Check if a semantic domain with the given number exists.",
          "description": "Check if a semantic domain with the given number exists.\n",
          "parameters": [
            {
              "name": "number",
              "type": "str",
              "default": null,
              "description": "The domain number to check (e.g., \"3.5.1.1\")."
            }
          ],
          "returns": "bool: True if domain exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If number is None."
          ],
          "example": "            >>> if project.SemanticDomains.Exists(\"7.2.1\"):\n            ...     print(\"Walk domain exists\")\n            Walk domain exists\n\n            >>> if not project.SemanticDomains.Exists(\"999.999\"):\n            ...     print(\"Custom domain 999.999 does not exist\")\n            Custom domain 999.999 does not exist\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(number)",
          "summary": "Find a semantic domain by its number.",
          "description": "Find a semantic domain by its number.\n",
          "parameters": [
            {
              "name": "number",
              "type": "str",
              "default": null,
              "description": "The domain number to search for (e.g., \"3.5.1.1\")."
            }
          ],
          "returns": "ICmSemanticDomain or None: The domain object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If number is None."
          ],
          "example": "            >>> # Find a specific domain\n            >>> domain = project.SemanticDomains.Find(\"7.2.1\")\n            >>> if domain:\n            ...     name = project.SemanticDomains.GetName(domain)\n            ...     print(f\"Found: {name}\")\n            Found: Walk\n\n            >>> # Try to find non-existent domain\n            >>> missing = project.SemanticDomains.Find(\"999.999\")\n            >>> print(missing)\n            None\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByName",
          "signature": "FindByName(name)",
          "summary": "Find a semantic domain by its name.",
          "description": "Find a semantic domain by its name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The domain name to search for (case-insensitive)."
            }
          ],
          "returns": "ICmSemanticDomain or None: The domain object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> # Find by English name\n            >>> domain = project.SemanticDomains.FindByName(\"Walk\")\n            >>> if domain:\n            ...     number = project.SemanticDomains.GetNumber(domain)\n            ...     print(f\"Domain number: {number}\")\n            Domain number: 7.2.1\n\n            >>> # Case-insensitive search\n            >>> domain = project.SemanticDomains.FindByName(\"walk\")\n            >>> print(domain is not None)\n            True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAbbreviation",
          "signature": "GetAbbreviation(domain_or_hvo, wsHandle=None)",
          "summary": "Get the abbreviation of a semantic domain.",
          "description": "Get the abbreviation of a semantic domain.\n\nThe abbreviation typically contains the domain number.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The domain abbreviation, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.Find(\"7.2.1\")\n            >>> abbr = project.SemanticDomains.GetAbbreviation(domain)\n            >>> print(abbr)\n            7.2.1\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(flat=True)",
          "summary": "Get all semantic domains in the project.",
          "description": "Get all semantic domains in the project.\n",
          "parameters": [
            {
              "name": "flat",
              "type": "bool",
              "default": true,
              "description": "If True, returns a flat list of all domains including subdomains. If False, returns only top-level domains (use GetSubdomains to navigate hierarchy). Defaults to True."
            }
          ],
          "returns": "list: List of ICmSemanticDomain objects. ",
          "raises": [],
          "example": "            >>> # Get all domains in a flat list\n            >>> for domain in project.SemanticDomains.GetAll(flat=True):\n            ...     number = project.SemanticDomains.GetNumber(domain)\n            ...     name = project.SemanticDomains.GetName(domain)\n            ...     print(f\"{number} - {name}\")\n            1 - Universe, creation\n            1.1 - Sky\n            1.1.1 - Sun\n            1.1.1.1 - Moon\n            ...\n\n            >>> # Get only top-level domains\n            >>> top_level = project.SemanticDomains.GetAll(flat=False)\n            >>> for domain in top_level:\n            ...     print(project.SemanticDomains.GetName(domain))\n            Universe, creation\n            Person\n            Language and thought\n            ...\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDepth",
          "signature": "GetDepth(domain_or_hvo)",
          "summary": "Get the depth of a semantic domain in the hierarchy.",
          "description": "Get the depth of a semantic domain in the hierarchy.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            }
          ],
          "returns": "int: The depth (0 for top-level, 1 for first level subdomains, etc.). ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> # Top-level domain\n            >>> universe = project.SemanticDomains.Find(\"1\")\n            >>> depth = project.SemanticDomains.GetDepth(universe)\n            >>> print(depth)\n            0\n\n            >>> # Third-level domain\n            >>> walk = project.SemanticDomains.Find(\"7.2.1\")\n            >>> depth = project.SemanticDomains.GetDepth(walk)\n            >>> print(depth)\n            2\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(domain_or_hvo, wsHandle=None)",
          "summary": "Get the description of a semantic domain.",
          "description": "Get the description of a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The domain description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.Find(\"7.2.1\")\n            >>> desc = project.SemanticDomains.GetDescription(domain)\n            >>> print(desc)\n            Use this domain for words related to walking.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(domain_or_hvo, wsHandle=None)",
          "summary": "Get the name of a semantic domain.",
          "description": "Get the name of a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The domain name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.Find(\"7.2.1\")\n            >>> name = project.SemanticDomains.GetName(domain)\n            >>> print(name)\n            Walk\n\n            >>> # Get name in a specific writing system\n            >>> name_fr = project.SemanticDomains.GetName(domain,\n            ...                                            project.WSHandle('fr'))\n            >>> print(name_fr)\n            Marcher\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetNumber",
          "signature": "GetNumber(domain_or_hvo)",
          "summary": "Get the domain number of a semantic domain.",
          "description": "Get the domain number of a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            }
          ],
          "returns": "str: The domain number (e.g., \"7.2.1\"), or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.FindByName(\"Walk\")\n            >>> number = project.SemanticDomains.GetNumber(domain)\n            >>> print(number)\n            7.2.1\n\n            >>> # Use number to navigate hierarchy\n            >>> parent_num = \".\".join(number.split(\".\")[:-1])\n            >>> parent = project.SemanticDomains.Find(parent_num)\n            >>> print(project.SemanticDomains.GetName(parent))\n            Move\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOcmCodes",
          "signature": "GetOcmCodes(domain_or_hvo)",
          "summary": "Get OCM (Outline of Cultural Materials) codes for a semantic domain.",
          "description": "Get OCM (Outline of Cultural Materials) codes for a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            }
          ],
          "returns": "str: The OCM codes, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.Find(\"7.2.1\")\n            >>> ocm = project.SemanticDomains.GetOcmCodes(domain)\n            >>> print(ocm)\n            484\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParent",
          "signature": "GetParent(domain_or_hvo)",
          "summary": "Get the parent domain of a semantic domain.",
          "description": "Get the parent domain of a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            }
          ],
          "returns": "ICmSemanticDomain or None: The parent domain, or None if top-level. ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> # Get parent of \"Walk\" (7.2.1)\n            >>> walk = project.SemanticDomains.Find(\"7.2.1\")\n            >>> parent = project.SemanticDomains.GetParent(walk)\n            >>> if parent:\n            ...     number = project.SemanticDomains.GetNumber(parent)\n            ...     name = project.SemanticDomains.GetName(parent)\n            ...     print(f\"Parent: {number} - {name}\")\n            Parent: 7.2 - Move\n\n            >>> # Top-level domains have no parent\n            >>> top = project.SemanticDomains.Find(\"1\")\n            >>> parent = project.SemanticDomains.GetParent(top)\n            >>> print(parent)\n            None\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetQuestions",
          "signature": "GetQuestions(domain_or_hvo, wsHandle=None)",
          "summary": "Get elicitation questions for a semantic domain.",
          "description": "Get elicitation questions for a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The elicitation questions, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.Find(\"7.2.1\")\n            >>> questions = project.SemanticDomains.GetQuestions(domain)\n            >>> print(questions)\n            (1) What words refer to walking?\n            (2) What words refer to the way a person walks?\n            (3) What words refer to walking a long distance?\n            ...\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSenseCount",
          "signature": "GetSenseCount(domain_or_hvo)",
          "summary": "Get the count of lexical senses that belong to this semantic domain.",
          "description": "Get the count of lexical senses that belong to this semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            }
          ],
          "returns": "int: The number of senses using this domain. ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.Find(\"7.2.1\")\n            >>> count = project.SemanticDomains.GetSenseCount(domain)\n            >>> print(f\"Domain 7.2.1 (Walk) has {count} senses\")\n            Domain 7.2.1 (Walk) has 15 senses\n\n            >>> # Find empty domains\n            >>> for domain in project.SemanticDomains.GetAll(flat=True):\n            ...     count = project.SemanticDomains.GetSenseCount(domain)\n            ...     if count == 0:\n            ...         number = project.SemanticDomains.GetNumber(domain)\n            ...         name = project.SemanticDomains.GetName(domain)\n            ...         print(f\"Empty: {number} - {name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSensesInDomain",
          "signature": "GetSensesInDomain(domain_or_hvo)",
          "summary": "Get all lexical senses that belong to this semantic domain.",
          "description": "Get all lexical senses that belong to this semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            }
          ],
          "returns": "list: List of ILexSense objects that reference this domain. ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.Find(\"7.2.1\")\n            >>> senses = project.SemanticDomains.GetSensesInDomain(domain)\n            >>> for sense in senses:\n            ...     entry = sense.Entry\n            ...     headword = project.LexiconGetHeadword(entry)\n            ...     gloss = project.LexiconGetSenseGloss(sense)\n            ...     print(f\"{headword}: {gloss}\")\n            walk: to move on foot\n            stroll: to walk leisurely\n            march: to walk in formation\n            ...\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubdomains",
          "signature": "GetSubdomains(domain_or_hvo)",
          "summary": "Get all direct child subdomains of a semantic domain.",
          "description": "Get all direct child subdomains of a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            }
          ],
          "returns": "list: List of ICmSemanticDomain child objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If domain_or_hvo is None."
          ],
          "example": "            >>> # Get subdomains of \"Universe, creation\"\n            >>> top_domain = project.SemanticDomains.Find(\"1\")\n            >>> subdomains = project.SemanticDomains.GetSubdomains(top_domain)\n            >>> for subdomain in subdomains:\n            ...     number = project.SemanticDomains.GetNumber(subdomain)\n            ...     name = project.SemanticDomains.GetName(subdomain)\n            ...     print(f\"{number} - {name}\")\n            1.1 - Sky\n            1.2 - World\n            1.3 - Water\n            ...\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a semantic domain for comparison.",
          "description": "Get all syncable properties of a semantic domain for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values.",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(domain_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of a semantic domain.",
          "description": "Set the description of a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If domain_or_hvo or description is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.Find(\"900.1\")  # custom domain\n            >>> project.SemanticDomains.SetDescription(domain,\n            ...     \"Use this domain for words related to modern technology.\")\n\n        See Also:\n            GetDescription, SetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(domain_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a semantic domain.",
          "description": "Set the name of a semantic domain.\n",
          "parameters": [
            {
              "name": "domain_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmSemanticDomain object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If domain_or_hvo or name is None."
          ],
          "example": "            >>> domain = project.SemanticDomains.Find(\"900.1\")  # custom domain\n            >>> project.SemanticDomains.SetName(domain, \"Custom Category\")\n            >>> print(project.SemanticDomains.GetName(domain))\n            Custom Category\n\n        Warning:\n            - Modifying standard semantic domains (e.g., SIL domains) may\n              cause compatibility issues with other projects\n            - Consider creating custom domains instead of modifying standard ones\n\n        See Also:\n            GetName, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize SemanticDomainOperations with a FLExProject instance.",
          "description": "Initialize SemanticDomainOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "VariantOperations": {
      "name": "VariantOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lexicon.VariantOperations",
      "source_file": "Lexicon/VariantOperations",
      "category": "lexicon",
      "summary": "This class provides operations for managing variant forms in a FieldWorks project.",
      "description": "This class provides operations for managing variant forms in a FieldWorks project.\n\nVariant forms represent alternative forms of lexical entries, including:\n- Spelling variants (e.g., \"color\" vs. \"colour\")\n- Dialectal variants (e.g., regional pronunciations)\n- Irregularly inflected forms (e.g., \"went\" as past tense of \"go\")\n- Free variants (e.g., \"among\" vs. \"amongst\")\n\nVariants are linked through ILexEntryRef objects which can connect entries\nas variants of each other or as components of complex forms.\n\nThis class should be accessed via FLExProject.Variants property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all variant types\nfor vtype in project.Variants.GetAllTypes():\nname = project.Variants.GetTypeName(vtype)\nprint(f\"Variant type: {name}\")\n\n# Find a specific variant type\nspelling_type = project.Variants.FindType(\"Spelling Variant\")\n\n# Create a variant\nentry = project.LexEntry.Find(\"color\")\nvariant = project.Variants.Create(entry, \"colour\", spelling_type)\n\n# Get all variants for an entry\nfor var in project.Variants.GetAll(entry):\nform = project.Variants.GetForm(var)\nvtype = project.Variants.GetType(var)\nprint(f\"Variant: {form} ({vtype})\")\n\n# For irregularly inflected forms\ngo_entry = project.LexEntry.Find(\"go\")\nwent_entry = project.LexEntry.Find(\"went\")\nirregular_type = project.Variants.FindType(\"Irregularly Inflected Form\")\n\n# Create variant with component\nvariant_ref = project.Variants.Create(went_entry, \"went\", irregular_type)\nproject.Variants.AddComponentLexeme(variant_ref, go_entry)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddComponentLexeme",
          "signature": "AddComponentLexeme(variant_or_hvo, entry_or_hvo)",
          "summary": "Add a component lexeme to a variant.",
          "description": "Add a component lexeme to a variant.\n\nThis creates a link from an irregularly inflected form to its base entry.\nFor example, linking \"went\" to \"go\".\n",
          "parameters": [
            {
              "name": "variant_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO."
            },
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO to add as a component."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If variant_or_hvo or entry_or_hvo is None."
          ],
          "example": "            >>> # Create \"went\" as irregular past of \"go\"\n            >>> went_entry = project.LexEntry.Find(\"went\")\n            >>> go_entry = project.LexEntry.Find(\"go\")\n            >>>\n            >>> irregular_type = project.Variants.FindType(\"Irregularly Inflected Form\")\n            >>> variant_ref = project.Variants.Create(went_entry, \"went\", irregular_type)\n            >>>\n            >>> # Add \"go\" as the component\n            >>> project.Variants.AddComponentLexeme(variant_ref, go_entry)\n            >>>\n            >>> # Verify\n            >>> components = project.Variants.GetComponentLexemes(variant_ref)\n            >>> for comp in components:\n            ...     print(project.LexEntry.GetHeadword(comp))\n            go\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two variant references and return their differences.",
          "description": "Compare two variant references and return their differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "The first ILexEntryRef object."
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "The second ILexEntryRef object."
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional VariantOperations instance for item1."
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional VariantOperations instance for item2."
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(entry_or_hvo, variant_form, variant_type, wsHandle=None)",
          "summary": "Create a variant relationship for an entry.",
          "description": "Create a variant relationship for an entry.\n\nThis creates an ILexEntryRef object that defines the entry as a variant\nof another form. The variant_form can be set as the lexeme form of the\nentry itself, or you can create a separate entry for the variant.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO (the variant entry)."
            },
            {
              "name": "variant_form",
              "type": "str",
              "default": null,
              "description": "The variant form text (for display/reference)."
            },
            {
              "name": "variant_type",
              "type": "",
              "default": null,
              "description": "The ILexEntryType object defining the variant type."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "ILexEntryRef: The newly created variant reference object. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If entry_or_hvo, variant_form, or variant_type is None.",
            "FP_ParameterError: If variant_form is empty."
          ],
          "example": "            >>> # Create spelling variant\n            >>> colour_entry = project.LexEntry.Find(\"colour\")\n            >>> if not colour_entry:\n            ...     colour_entry = project.LexEntry.Create(\"colour\")\n            >>> spelling_type = project.Variants.FindType(\"Spelling Variant\")\n            >>> variant = project.Variants.Create(colour_entry, \"colour\", spelling_type)\n\n            >>> # Create irregularly inflected form\n            >>> went_entry = project.LexEntry.Find(\"went\")\n            >>> irregular_type = project.Variants.FindType(\"Irregularly Inflected Form\")\n            >>> variant_ref = project.Variants.Create(went_entry, \"went\", irregular_type)\n            >>> # Then add the base form as a component\n            >>> go_entry = project.LexEntry.Find(\"go\")\n            >>> project.Variants.AddComponentLexeme(variant_ref, go_entry)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(variant_or_hvo)",
          "summary": "Delete a variant reference.",
          "description": "Delete a variant reference.\n\nThis removes the variant relationship but does not delete the entry itself.\n",
          "parameters": [
            {
              "name": "variant_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If variant_or_hvo is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"colour\")\n            >>> for variant in project.Variants.GetAll(entry):\n            ...     # Delete the variant reference\n            ...     project.Variants.Delete(variant)\n\n        Warning:\n            - Deletes the variant relationship, not the entry\n            - To delete the variant entry itself, use project.LexEntry.Delete()\n            - Deletion is permanent and cannot be undone\n            - Component lexeme links are also removed\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a variant reference, creating a new copy with a new GUID.",
          "description": "Duplicate a variant reference, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source variant. If False, insert at end of parent's entry refs list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "Reserved for future use (variants have no owned objects to duplicate)."
            }
          ],
          "returns": "ILexEntryRef: The newly created duplicate variant reference with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"colour\")\n            >>> variants = list(project.Variants.GetAll(entry))\n            >>> if variants:\n            ...     # Duplicate the variant reference\n            ...     dup = project.Variants.Duplicate(variants[0])\n            ...     print(f\"Original: {variants[0].Guid}\")\n            ...     print(f\"Duplicate: {dup.Guid}\")\n            ...     vtype = project.Variants.GetType(dup)\n            ...     print(f\"Type: {project.Variants.GetTypeName(vtype)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n            Type: Spelling Variant\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindType",
          "signature": "FindType(name)",
          "summary": "Find a variant type by name.",
          "description": "Find a variant type by name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the variant type to find (case-insensitive). Common types: \"Spelling Variant\", \"Dialectal Variant\", \"Irregularly Inflected Form\", \"Free Variant\", etc."
            }
          ],
          "returns": "ILexEntryType or None: The variant type if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> spelling_type = project.Variants.FindType(\"Spelling Variant\")\n            >>> if spelling_type:\n            ...     print(f\"Found: {project.Variants.GetTypeName(spelling_type)}\")\n            Found: Spelling Variant\n\n            >>> # Case-insensitive search\n            >>> dialectal = project.Variants.FindType(\"dialectal variant\")\n            >>> irregular = project.Variants.FindType(\"Irregularly Inflected Form\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(entry_or_hvo=None)",
          "summary": "Get all variant references for a lexical entry, or all variants in the entire project.",
          "description": "Get all variant references for a lexical entry, or all variants in the entire project.\n\nThis returns the entry references that define this entry as a variant\nof other entries, or other entries as variants of this one.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO. If None, iterates all variant references in the entire project."
            }
          ],
          "returns": "ILexEntryRef: Each variant reference associated with the entry (or project). ",
          "raises": [],
          "example": "            >>> # Get variant references for specific entry\n            >>> entry = project.LexEntry.Find(\"colour\")\n            >>> for variant_ref in project.Variants.GetAll(entry):\n            ...     vtype = project.Variants.GetType(variant_ref)\n            ...     type_name = project.Variants.GetTypeName(vtype)\n            ...     print(f\"Variant type: {type_name}\")\n            Variant type: Spelling Variant\n\n            >>> # Get ALL variant references in entire project\n            >>> for variant_ref in project.Variants.GetAll():\n            ...     form = project.Variants.GetForm(variant_ref)\n            ...     print(f\"Variant form: {form}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllTypes",
          "signature": "GetAllTypes()",
          "summary": "Get all variant entry types defined in the project.",
          "description": "Get all variant entry types defined in the project.\n\nVariant types define the nature of the relationship between entries,\nsuch as spelling variants, dialectal variants, irregularly inflected\nforms, etc.\n",
          "parameters": [],
          "returns": "ILexEntryType: Each variant type defined in the project. ",
          "raises": [],
          "example": "            >>> for vtype in project.Variants.GetAllTypes():\n            ...     name = project.Variants.GetTypeName(vtype)\n            ...     desc = project.Variants.GetTypeDescription(vtype)\n            ...     print(f\"{name}: {desc}\")\n            Spelling Variant: A variant spelling of the same word\n            Dialectal Variant: A form used in a particular dialect\n            Irregularly Inflected Form: An irregular inflection of a lexeme\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetComponentLexemes",
          "signature": "GetComponentLexemes(variant_or_hvo)",
          "summary": "Get the component lexemes of a variant.",
          "description": "Get the component lexemes of a variant.\n\nComponent lexemes are the base entries that make up an irregularly\ninflected form. For example, \"went\" has \"go\" as a component.\n",
          "parameters": [
            {
              "name": "variant_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO."
            }
          ],
          "returns": "list: List of ILexEntry objects that are components (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If variant_or_hvo is None."
          ],
          "example": "            >>> # \"went\" is irregular past tense of \"go\"\n            >>> went_entry = project.LexEntry.Find(\"went\")\n            >>> for variant in project.Variants.GetAll(went_entry):\n            ...     components = project.Variants.GetComponentLexemes(variant)\n            ...     for comp in components:\n            ...         headword = project.LexEntry.GetHeadword(comp)\n            ...         print(f\"Component: {headword}\")\n            Component: go\n\n            >>> # \"worse\" might have components \"bad\" or \"ill\"\n            >>> worse_entry = project.LexEntry.Find(\"worse\")\n            >>> for variant in project.Variants.GetAll(worse_entry):\n            ...     for comp in project.Variants.GetComponentLexemes(variant):\n            ...         print(project.LexEntry.GetHeadword(comp))\n            bad\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(variant_or_hvo, wsHandle=None)",
          "summary": "Get the form of a variant.",
          "description": "Get the form of a variant.\n\nThis returns the lexeme form of the entry that owns this variant reference.\n",
          "parameters": [
            {
              "name": "variant_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The variant form text (empty string if not set). ",
          "raises": [
            "FP_NullParameterError: If variant_or_hvo is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"colour\")\n            >>> for variant in project.Variants.GetAll(entry):\n            ...     form = project.Variants.GetForm(variant)\n            ...     print(f\"Variant form: {form}\")\n            Variant form: colour\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwningEntry",
          "signature": "GetOwningEntry(variant_or_hvo)",
          "summary": "Get the entry that owns a variant reference.",
          "description": "Get the entry that owns a variant reference.\n",
          "parameters": [
            {
              "name": "variant_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO."
            }
          ],
          "returns": "ILexEntry: The entry that owns this variant reference. ",
          "raises": [
            "FP_NullParameterError: If variant_or_hvo is None."
          ],
          "example": "            >>> # Find all variants in the lexicon and their owners\n            >>> for entry in project.LexEntry.GetAll():\n            ...     for variant in project.Variants.GetAll(entry):\n            ...         owner = project.Variants.GetOwningEntry(variant)\n            ...         owner_hw = project.LexEntry.GetHeadword(owner)\n            ...         var_form = project.Variants.GetForm(variant)\n            ...         vtype = project.Variants.GetType(variant)\n            ...         type_name = project.Variants.GetTypeName(vtype) if vtype else \"?\"\n            ...         print(f\"{owner_hw} -> {var_form} ({type_name})\")\n            color -> colour (Spelling Variant)\n            go -> went (Irregularly Inflected Form)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a variant reference for comparison.",
          "description": "Get all syncable properties of a variant reference for comparison.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object."
            }
          ],
          "returns": "dict: Dictionary mapping property names to their values.",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetType",
          "signature": "GetType(variant_or_hvo)",
          "summary": "Get the variant type of a variant reference.",
          "description": "Get the variant type of a variant reference.\n",
          "parameters": [
            {
              "name": "variant_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO."
            }
          ],
          "returns": "ILexEntryType or None: The variant type, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If variant_or_hvo is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"colour\")\n            >>> for variant in project.Variants.GetAll(entry):\n            ...     vtype = project.Variants.GetType(variant)\n            ...     if vtype:\n            ...         name = project.Variants.GetTypeName(vtype)\n            ...         print(f\"Variant type: {name}\")\n            Variant type: Spelling Variant\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTypeDescription",
          "signature": "GetTypeDescription(variant_type, wsHandle=None)",
          "summary": "Get the description of a variant type.",
          "description": "Get the description of a variant type.\n",
          "parameters": [
            {
              "name": "variant_type",
              "type": "",
              "default": null,
              "description": "The ILexEntryType object."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The variant type description (empty string if not set). ",
          "raises": [
            "FP_NullParameterError: If variant_type is None."
          ],
          "example": "            >>> spelling_type = project.Variants.FindType(\"Spelling Variant\")\n            >>> if spelling_type:\n            ...     desc = project.Variants.GetTypeDescription(spelling_type)\n            ...     print(desc)\n            A variant spelling of the same word\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTypeName",
          "signature": "GetTypeName(variant_type, wsHandle=None)",
          "summary": "Get the name of a variant type.",
          "description": "Get the name of a variant type.\n",
          "parameters": [
            {
              "name": "variant_type",
              "type": "",
              "default": null,
              "description": "The ILexEntryType object."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The variant type name (empty string if not set). ",
          "raises": [
            "FP_NullParameterError: If variant_type is None."
          ],
          "example": "            >>> for vtype in project.Variants.GetAllTypes():\n            ...     name = project.Variants.GetTypeName(vtype)\n            ...     print(f\"Type: {name}\")\n            Type: Spelling Variant\n            Type: Dialectal Variant\n            Type: Irregularly Inflected Form\n\n            >>> # Get in specific writing system\n            >>> name_fr = project.Variants.GetTypeName(vtype, project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetVariantCount",
          "signature": "GetVariantCount(entry_or_hvo)",
          "summary": "Get the count of variant references for an entry.",
          "description": "Get the count of variant references for an entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO."
            }
          ],
          "returns": "int: The number of variant references (0 if none). ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"colour\")\n            >>> count = project.Variants.GetVariantCount(entry)\n            >>> print(f\"Entry has {count} variant reference(s)\")\n            Entry has 1 variant reference(s)\n\n            >>> # Check if entry has any variants\n            >>> if project.Variants.GetVariantCount(entry) > 0:\n            ...     print(\"This entry has variants\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveComponentLexeme",
          "signature": "RemoveComponentLexeme(variant_or_hvo, entry_or_hvo)",
          "summary": "Remove a component lexeme from a variant.",
          "description": "Remove a component lexeme from a variant.\n",
          "parameters": [
            {
              "name": "variant_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO."
            },
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntry object or HVO to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If variant_or_hvo or entry_or_hvo is None."
          ],
          "example": "            >>> went_entry = project.LexEntry.Find(\"went\")\n            >>> go_entry = project.LexEntry.Find(\"go\")\n            >>>\n            >>> for variant in project.Variants.GetAll(went_entry):\n            ...     # Remove \"go\" as component\n            ...     project.Variants.RemoveComponentLexeme(variant, go_entry)\n            ...\n            ...     # Verify removal\n            ...     components = project.Variants.GetComponentLexemes(variant)\n            ...     print(f\"Remaining components: {len(components)}\")\n            Remaining components: 0\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetForm",
          "signature": "SetForm(variant_or_hvo, text, wsHandle=None)",
          "summary": "Set the form of a variant.",
          "description": "Set the form of a variant.\n\nThis sets the lexeme form of the entry that owns this variant reference.\n",
          "parameters": [
            {
              "name": "variant_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new variant form text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If variant_or_hvo or text is None.",
            "FP_ParameterError: If text is empty or entry has no lexeme form."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"colour\")\n            >>> for variant in project.Variants.GetAll(entry):\n            ...     project.Variants.SetForm(variant, \"coulour\")  # Fix typo\n            ...     print(project.Variants.GetForm(variant))\n            coulour\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetType",
          "signature": "SetType(variant_or_hvo, variant_type)",
          "summary": "Set the variant type of a variant reference.",
          "description": "Set the variant type of a variant reference.\n\nThis replaces all existing variant types with the specified type.\n",
          "parameters": [
            {
              "name": "variant_or_hvo",
              "type": "",
              "default": null,
              "description": "The ILexEntryRef object or HVO."
            },
            {
              "name": "variant_type",
              "type": "",
              "default": null,
              "description": "The ILexEntryType object to set."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If variant_or_hvo or variant_type is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"colour\")\n            >>> for variant in project.Variants.GetAll(entry):\n            ...     dialectal_type = project.Variants.FindType(\"Dialectal Variant\")\n            ...     if dialectal_type:\n            ...         project.Variants.SetType(variant, dialectal_type)\n            ...         vtype = project.Variants.GetType(variant)\n            ...         print(project.Variants.GetTypeName(vtype))\n            Dialectal Variant\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize VariantOperations with a FLExProject instance.",
          "description": "Initialize VariantOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "lexicon",
        "operations"
      ]
    },
    "AgentOperations": {
      "name": "AgentOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lists.AgentOperations",
      "source_file": "Lists/AgentOperations",
      "category": "lists",
      "summary": "This class provides operations for managing analysis agents in a FieldWorks\nproject.",
      "description": "This class provides operations for managing analysis agents in a FieldWorks\nproject.\n\nAgents represent either human analysts or automated parsers that perform\nlinguistic analysis. They are used to track who (or what) created analyses,\nglosses, and evaluations in the project.\n\nThis class should be accessed via FLExProject.Agent property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all agents\nfor agent in project.Agent.GetAll():\nname = project.Agent.GetName(agent)\nagent_type = \"Human\" if project.Agent.IsHuman(agent) else \"Parser\"\nprint(f\"{name} ({agent_type})\")\n\n# Create a human agent\nperson = project.Person.Find(\"John Smith\")\nagent = project.Agent.CreateHumanAgent(\"John Smith\", person)\n\n# Create a parser agent\nparser = project.Agent.CreateParserAgent(\"MyParser\", \"1.0.0\")\nproject.Agent.SetVersion(parser, \"1.0.1\")\n\n# Find agents by type\nhuman_agents = project.Agent.GetHumanAgents()\nparser_agents = project.Agent.GetParserAgents()\n\n# Get evaluations for an agent\nevaluations = project.Agent.GetEvaluations(agent)\ncount = project.Agent.GetEvaluationCount(agent)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two agents and return detailed differences.",
          "description": "Compare two agents and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First agent (from source project)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second agent (from target project)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Operations instance for item1's project (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Operations instance for item2's project (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) where differences_dict contains 'properties' dict with changed property details ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(agent1, agent2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, details in diffs['properties'].items():\n            ...         print(f\"{prop}: {details['source']} -> {details['target']}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, wsHandle=None)",
          "summary": "Create a new agent in the FLEx project.",
          "description": "Create a new agent in the FLEx project.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the agent"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmAgent: The newly created agent object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> # Create a basic agent\n            >>> agent = project.Agent.Create(\"MyParser\")\n            >>> print(project.Agent.GetName(agent))\n            MyParser\n\n            >>> # Create with specific writing system\n            >>> agent = project.Agent.Create(\"AnalyseurFR\",\n            ...                               project.WSHandle('fr'))\n\n            >>> # Create and configure a parser\n            >>> parser = project.Agent.Create(\"AutoAnalyzer\")\n            >>> project.Agent.SetVersion(parser, \"1.0.0\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateHumanAgent",
          "signature": "CreateHumanAgent(name, person, wsHandle=None)",
          "summary": "Create a new human agent linked to a person.",
          "description": "Create a new human agent linked to a person.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the agent (typically matches person's name)"
            },
            {
              "name": "person",
              "type": "",
              "default": null,
              "description": "ICmPerson object to link to this agent"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmAgent: The newly created human agent object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If name or person is None",
            "FP_ParameterError: If name is empty or person is invalid"
          ],
          "example": "            >>> # Create person first\n            >>> person = project.Person.Create(\"John Smith\")\n            >>> project.Person.SetEmail(person, \"john.smith@example.com\")\n\n            >>> # Create human agent linked to person\n            >>> agent = project.Agent.CreateHumanAgent(\"John Smith\", person)\n            >>> print(f\"Created agent for {project.Agent.GetName(agent)}\")\n            Created agent for John Smith\n\n            >>> # Verify it's a human agent\n            >>> if project.Agent.IsHuman(agent):\n            ...     linked_person = project.Agent.GetHuman(agent)\n            ...     print(f\"Linked to: {project.Person.GetName(linked_person)}\")\n            Linked to: John Smith\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateParserAgent",
          "signature": "CreateParserAgent(name, version='', wsHandle=None)",
          "summary": "Create a new parser agent (computer/automated analyzer).",
          "description": "Create a new parser agent (computer/automated analyzer).\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the parser"
            },
            {
              "name": "version",
              "type": "str",
              "default": "",
              "description": "Version string (e.g., \"1.0.0\"). Defaults to empty."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmAgent: The newly created parser agent object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> # Create a parser with version\n            >>> parser = project.Agent.CreateParserAgent(\"MyParser\", \"1.0.0\")\n            >>> print(f\"{project.Agent.GetName(parser)} \"\n            ...       f\"v{project.Agent.GetVersion(parser)}\")\n            MyParser v1.0.0\n\n            >>> # Create parser without initial version\n            >>> analyzer = project.Agent.CreateParserAgent(\"AutoAnalyzer\")\n            >>> project.Agent.SetVersion(analyzer, \"2.1.3\")\n\n            >>> # Verify it's a parser\n            >>> if project.Agent.IsParser(parser):\n            ...     print(\"This is an automated parser\")\n            This is an automated parser\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(agent_or_hvo)",
          "summary": "Delete an agent from the FLEx project.",
          "description": "Delete an agent from the FLEx project.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO (database ID)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If agent_or_hvo is None",
            "FP_ParameterError: If agent doesn't exist"
          ],
          "example": "            >>> agent = project.Agent.Find(\"OldParser\")\n            >>> if agent:\n            ...     project.Agent.Delete(agent)\n\n            >>> # Delete by HVO\n            >>> project.Agent.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - All associated evaluations will be affected\n            - References from analyses may become invalid\n            - Cannot be undone\n            - Agent will be removed from all linked evaluations\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate an agent, creating a new copy with a new GUID.",
          "description": "Duplicate an agent, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source agent. If False, insert at end of agents collection."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "Not applicable for agents (no owned objects to copy). Included for API consistency."
            }
          ],
          "returns": "ICmAgent: The newly created duplicate agent with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Duplicate a parser agent\n            >>> parser = project.Agent.Find(\"MyParser\")\n            >>> dup = project.Agent.Duplicate(parser)\n            >>> print(f\"Original: {project.Agent.GetName(parser)}\")\n            >>> print(f\"Duplicate: {project.Agent.GetName(dup)}\")\n            Original: MyParser\n            Duplicate: MyParser\n            >>>\n            >>> # Modify the duplicate\n            >>> project.Agent.SetName(dup, \"MyParser Copy\")\n            >>> project.Agent.SetVersion(dup, \"1.0.1\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name, wsHandle=None)",
          "summary": "Check if an agent with the given name exists.",
          "description": "Check if an agent with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "bool: True if an agent exists with this name, False otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> if not project.Agent.Exists(\"MyParser\"):\n            ...     parser = project.Agent.CreateParserAgent(\"MyParser\", \"1.0.0\")\n\n            >>> # Check in specific writing system\n            >>> if project.Agent.Exists(\"AnalyseurFR\", project.WSHandle('fr')):\n            ...     print(\"French analyzer exists\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name, wsHandle=None)",
          "summary": "Find an agent by name.",
          "description": "Find an agent by name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmAgent or None: The agent object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> agent = project.Agent.Find(\"MyParser\")\n            >>> if agent:\n            ...     version = project.Agent.GetVersion(agent)\n            ...     print(f\"Found: {name} v{version}\")\n            Found: MyParser v1.0.0\n\n            >>> # Search in specific writing system\n            >>> agent = project.Agent.Find(\"AnalyseurFR\",\n            ...                             project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByType",
          "signature": "FindByType(is_human)",
          "summary": "Find all agents of a specific type (human or parser).",
          "description": "Find all agents of a specific type (human or parser).\n",
          "parameters": [
            {
              "name": "is_human",
              "type": "bool",
              "default": null,
              "description": "True to find human agents, False for parsers"
            }
          ],
          "returns": "list: List of ICmAgent objects matching the type ",
          "raises": [],
          "example": "            >>> # Get all human agents\n            >>> humans = project.Agent.FindByType(True)\n            >>> for agent in humans:\n            ...     name = project.Agent.GetName(agent)\n            ...     person = project.Agent.GetHuman(agent)\n            ...     email = project.Person.GetEmail(person)\n            ...     print(f\"{name}: {email}\")\n\n            >>> # Get all parsers\n            >>> parsers = project.Agent.FindByType(False)\n            >>> for parser in parsers:\n            ...     name = project.Agent.GetName(parser)\n            ...     version = project.Agent.GetVersion(parser)\n            ...     print(f\"{name} v{version}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all agents in the project.",
          "description": "Get all agents in the project.\n\nThis method returns an iterator over all ICmAgent objects in the\nproject database, including both human analysts and automated parsers.\n",
          "parameters": [],
          "returns": "ICmAgent: Each agent object in the project ",
          "raises": [],
          "example": "            >>> for agent in project.Agent.GetAll():\n            ...     name = project.Agent.GetName(agent)\n            ...     version = project.Agent.GetVersion(agent)\n            ...     agent_type = \"Human\" if project.Agent.IsHuman(agent) else \"Parser\"\n            ...     print(f\"{name} v{version} ({agent_type})\")\n            John Smith v (Human)\n            MyParser v1.0.0 (Parser)\n            AutoAnalyzer v2.1.3 (Parser)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(agent_or_hvo)",
          "summary": "Get the creation date of an agent record.",
          "description": "Get the creation date of an agent record.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            }
          ],
          "returns": "System.DateTime: The date and time the agent record was created ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> agent = project.Agent.Find(\"MyParser\")\n            >>> created = project.Agent.GetDateCreated(agent)\n            >>> print(f\"Created: {created}\")\n            Created: 2025-01-15 14:30:22\n\n            >>> # Find oldest agent\n            >>> agents = list(project.Agent.GetAll())\n            >>> oldest = min(agents, key=lambda a: project.Agent.GetDateCreated(a))\n            >>> print(f\"Oldest: {project.Agent.GetName(oldest)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified(agent_or_hvo)",
          "summary": "Get the last modification date of an agent record.",
          "description": "Get the last modification date of an agent record.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            }
          ],
          "returns": "System.DateTime: The date and time the agent record was last modified ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> agent = project.Agent.Find(\"MyParser\")\n            >>> modified = project.Agent.GetDateModified(agent)\n            >>> print(f\"Last modified: {modified}\")\n            Last modified: 2025-01-20 09:15:43\n\n            >>> # Find recently modified agents\n            >>> from datetime import datetime, timedelta\n            >>> # Note: System.DateTime, not Python datetime\n            >>> for agent in project.Agent.GetAll():\n            ...     modified = project.Agent.GetDateModified(agent)\n            ...     name = project.Agent.GetName(agent)\n            ...     print(f\"{name}: {modified}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEvaluationCount",
          "signature": "GetEvaluationCount(agent_or_hvo)",
          "summary": "Get the number of evaluations created by an agent.",
          "description": "Get the number of evaluations created by an agent.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            }
          ],
          "returns": "int: Number of evaluations (0 if none) ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> agent = project.Agent.Find(\"MyParser\")\n            >>> count = project.Agent.GetEvaluationCount(agent)\n            >>> print(f\"Parser has {count} evaluations\")\n            Parser has 145 evaluations\n\n            >>> # Compare human vs parser evaluations\n            >>> for agent in project.Agent.GetAll():\n            ...     name = project.Agent.GetName(agent)\n            ...     count = project.Agent.GetEvaluationCount(agent)\n            ...     agent_type = \"Human\" if project.Agent.IsHuman(agent) else \"Parser\"\n            ...     print(f\"{name} ({agent_type}): {count} evaluations\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEvaluations",
          "signature": "GetEvaluations(agent_or_hvo)",
          "summary": "Get all evaluations created by an agent.",
          "description": "Get all evaluations created by an agent.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            }
          ],
          "returns": "list: List of ICmAgentEvaluation objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> agent = project.Agent.Find(\"MyParser\")\n            >>> evaluations = project.Agent.GetEvaluations(agent)\n            >>> print(f\"Parser created {len(evaluations)} evaluations\")\n            Parser created 145 evaluations\n\n            >>> # Examine evaluations\n            >>> for eval in evaluations[:5]:\n            ...     # Access evaluation properties\n            ...     print(f\"Evaluation: {eval.Guid}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(agent_or_hvo)",
          "summary": "Get the GUID (Globally Unique Identifier) of an agent.",
          "description": "Get the GUID (Globally Unique Identifier) of an agent.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            }
          ],
          "returns": "System.Guid: The agent's GUID ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> agent = project.Agent.Find(\"MyParser\")\n            >>> guid = project.Agent.GetGuid(agent)\n            >>> print(guid)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\n            >>> # Use GUID to retrieve agent later\n            >>> agent2 = project.Object(guid)\n            >>> print(project.Agent.GetName(agent2))\n            MyParser\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetHuman",
          "signature": "GetHuman(agent_or_hvo)",
          "summary": "Get the linked person for a human agent.",
          "description": "Get the linked person for a human agent.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            }
          ],
          "returns": "ICmPerson or None: The linked person object, or None if not set ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> agent = project.Agent.Find(\"John Smith\")\n            >>> if project.Agent.IsHuman(agent):\n            ...     person = project.Agent.GetHuman(agent)\n            ...     name = project.Person.GetName(person)\n            ...     email = project.Person.GetEmail(person)\n            ...     print(f\"{name}: {email}\")\n            John Smith: john.smith@example.com\n\n            >>> # Parser agents return None\n            >>> parser = project.Agent.Find(\"MyParser\")\n            >>> person = project.Agent.GetHuman(parser)\n            >>> print(person)\n            None\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetHumanAgents",
          "signature": "GetHumanAgents()",
          "summary": "Get all human agents in the project.",
          "description": "Get all human agents in the project.\n",
          "parameters": [],
          "returns": "list: List of ICmAgent objects representing human analysts ",
          "raises": [],
          "example": "            >>> humans = project.Agent.GetHumanAgents()\n            >>> print(f\"Found {len(humans)} human agents\")\n            Found 3 human agents\n\n            >>> for agent in humans:\n            ...     name = project.Agent.GetName(agent)\n            ...     person = project.Agent.GetHuman(agent)\n            ...     email = project.Person.GetEmail(person)\n            ...     print(f\"Analyst: {name} ({email})\")\n            Analyst: John Smith (john.smith@example.com)\n            Analyst: Maria Garcia (maria.garcia@example.com)\n            Analyst: Ahmed Hassan (ahmed.hassan@example.com)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(agent_or_hvo, wsHandle=None)",
          "summary": "Get the name of an agent.",
          "description": "Get the name of an agent.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The agent's name (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> agent = project.Agent.Find(\"MyParser\")\n            >>> name = project.Agent.GetName(agent)\n            >>> print(name)\n            MyParser\n\n            >>> # Get in specific writing system\n            >>> name_fr = project.Agent.GetName(agent, project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParserAgents",
          "signature": "GetParserAgents()",
          "summary": "Get all parser agents in the project.",
          "description": "Get all parser agents in the project.\n",
          "parameters": [],
          "returns": "list: List of ICmAgent objects representing automated parsers ",
          "raises": [],
          "example": "            >>> parsers = project.Agent.GetParserAgents()\n            >>> print(f\"Found {len(parsers)} parsers\")\n            Found 2 parsers\n\n            >>> for parser in parsers:\n            ...     name = project.Agent.GetName(parser)\n            ...     version = project.Agent.GetVersion(parser)\n            ...     count = project.Agent.GetEvaluationCount(parser)\n            ...     print(f\"{name} v{version}: {count} evaluations\")\n            MyParser v1.0.0: 145 evaluations\n            AutoAnalyzer v2.1.3: 89 evaluations\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.\n\nReturns all syncable properties of an agent including MultiString fields\nand reference properties.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmAgent object"
            }
          ],
          "returns": "dict: Dictionary of syncable properties ",
          "raises": [],
          "example": "            >>> props = project.Agent.GetSyncableProperties(agent)\n            >>> print(props)\n            {'Name': 'MyParser', 'Version': '1.0.0', 'Human': None}",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetVersion",
          "signature": "GetVersion(agent_or_hvo, wsHandle=None)",
          "summary": "Get the version string of an agent.",
          "description": "Get the version string of an agent.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The agent's version string (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> parser = project.Agent.Find(\"MyParser\")\n            >>> version = project.Agent.GetVersion(parser)\n            >>> print(f\"Version: {version}\")\n            Version: 1.0.0\n\n            >>> # Human agents typically don't have versions\n            >>> human = project.Agent.Find(\"John Smith\")\n            >>> version = project.Agent.GetVersion(human)\n            >>> print(version)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsHuman",
          "signature": "IsHuman(agent_or_hvo)",
          "summary": "Check if an agent is a human analyst.",
          "description": "Check if an agent is a human analyst.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            }
          ],
          "returns": "bool: True if agent has a linked human (ICmPerson), False otherwise ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> for agent in project.Agent.GetAll():\n            ...     name = project.Agent.GetName(agent)\n            ...     if project.Agent.IsHuman(agent):\n            ...         person = project.Agent.GetHuman(agent)\n            ...         email = project.Person.GetEmail(person)\n            ...         print(f\"Human: {name} ({email})\")\n            ...     else:\n            ...         version = project.Agent.GetVersion(agent)\n            ...         print(f\"Parser: {name} v{version}\")\n            Human: John Smith (john.smith@example.com)\n            Parser: MyParser v1.0.0\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsParser",
          "signature": "IsParser(agent_or_hvo)",
          "summary": "Check if an agent is a parser (automated analyzer).",
          "description": "Check if an agent is a parser (automated analyzer).\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            }
          ],
          "returns": "bool: True if agent has no linked human, False otherwise ",
          "raises": [
            "FP_NullParameterError: If agent_or_hvo is None"
          ],
          "example": "            >>> parser = project.Agent.Find(\"MyParser\")\n            >>> if project.Agent.IsParser(parser):\n            ...     version = project.Agent.GetVersion(parser)\n            ...     print(f\"Parser version: {version}\")\n            Parser version: 1.0.0\n\n            >>> # Filter only parsers\n            >>> parsers = [a for a in project.Agent.GetAll()\n            ...            if project.Agent.IsParser(a)]\n            >>> print(f\"Found {len(parsers)} parsers\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetHuman",
          "signature": "SetHuman(agent_or_hvo, person)",
          "summary": "Set the linked person for an agent (making it a human agent).",
          "description": "Set the linked person for an agent (making it a human agent).\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            },
            {
              "name": "person",
              "type": "",
              "default": null,
              "description": "ICmPerson object to link (or None to unlink)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If agent_or_hvo is None",
            "FP_ParameterError: If person is not a valid ICmPerson (when not None)"
          ],
          "example": "            >>> # Convert parser to human agent\n            >>> agent = project.Agent.Find(\"MyAgent\")\n            >>> person = project.Person.Find(\"John Smith\")\n            >>> project.Agent.SetHuman(agent, person)\n\n            >>> # Unlink person (convert to parser)\n            >>> project.Agent.SetHuman(agent, None)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(agent_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of an agent.",
          "description": "Set the name of an agent.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If agent_or_hvo or name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> agent = project.Agent.Find(\"MyParser\")\n            >>> project.Agent.SetName(agent, \"MyParser Pro\")\n            >>> print(project.Agent.GetName(agent))\n            MyParser Pro\n\n            >>> # Set in specific writing system\n            >>> project.Agent.SetName(agent, \"Mon Analyseur\",\n            ...                        project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetVersion",
          "signature": "SetVersion(agent_or_hvo, version, wsHandle=None)",
          "summary": "Set the version string of an agent.",
          "description": "Set the version string of an agent.\n",
          "parameters": [
            {
              "name": "agent_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmAgent object or its HVO"
            },
            {
              "name": "version",
              "type": "str",
              "default": null,
              "description": "The version string (e.g., \"1.0.0\")"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If agent_or_hvo or version is None"
          ],
          "example": "            >>> parser = project.Agent.Find(\"MyParser\")\n            >>> project.Agent.SetVersion(parser, \"1.0.1\")\n            >>> print(project.Agent.GetVersion(parser))\n            1.0.1\n\n            >>> # Update to new version\n            >>> project.Agent.SetVersion(parser, \"2.0.0\")\n\n            >>> # Clear version\n            >>> project.Agent.SetVersion(parser, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize AgentOperations with a FLExProject instance.",
          "description": "Initialize AgentOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "lists",
        "operations"
      ]
    },
    "ConfidenceOperations": {
      "name": "ConfidenceOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lists.ConfidenceOperations",
      "source_file": "Lists/ConfidenceOperations",
      "category": "lists",
      "summary": "This class provides operations for managing confidence levels (quality\nratings) in a FieldWorks project.",
      "description": "This class provides operations for managing confidence levels (quality\nratings) in a FieldWorks project.\n\nConfidence levels are used to rate the quality or certainty of linguistic\nanalyses and glosses. They provide a standardized way to indicate how\nconfident a linguist or parser is about a particular analysis or gloss.\nConfidence levels are implemented as a possibility list using ICmPossibility.\n\nCommon confidence levels might include:\n- High Confidence (for well-established analyses)\n- Medium Confidence (for probable but uncertain analyses)\n- Low Confidence (for tentative analyses)\n- Unconfirmed (for machine-generated or unverified analyses)\n\nThis class should be accessed via FLExProject.Confidence property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all confidence levels\nfor level in project.Confidence.GetAll():\nname = project.Confidence.GetName(level)\ndesc = project.Confidence.GetDescription(level)\nprint(f\"{name}: {desc}\")\n\n# Find a specific confidence level\nhigh = project.Confidence.Find(\"High Confidence\")\nif high:\n# Get analyses using this confidence level\nanalyses = project.Confidence.GetAnalysesWithConfidence(high)\nprint(f\"{len(analyses)} analyses have high confidence\")\n\n# Create a custom confidence level\ncustom = project.Confidence.Create(\"Verified\", \"en\")\nproject.Confidence.SetDescription(custom,\n\"Analysis verified by native speaker\")\n\n# Find the default confidence level\ndefault = project.Confidence.GetDefault()\nif default:\nprint(f\"Default: {project.Confidence.GetName(default)}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two confidence levels and return detailed differences.",
          "description": "Compare two confidence levels and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First confidence level (from source project)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second confidence level (from target project)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Operations instance for item1's project (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Operations instance for item2's project (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) where differences_dict contains 'properties' dict with changed property details ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(level1, level2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, details in diffs['properties'].items():\n            ...         print(f\"{prop}: {details['source']} -> {details['target']}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, wsHandle=None)",
          "summary": "Create a new confidence level.",
          "description": "Create a new confidence level.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the new confidence level."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmPossibility: The newly created confidence level object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty or confidence level list doesn't exist."
          ],
          "example": "            >>> # Create a new confidence level\n            >>> verified = project.Confidence.Create(\"Verified by Speaker\", \"en\")\n            >>> print(project.Confidence.GetName(verified))\n            Verified by Speaker\n\n            >>> # Create with description\n            >>> custom = project.Confidence.Create(\"Provisional\", \"en\")\n            >>> project.Confidence.SetDescription(custom,\n            ...     \"Provisional analysis pending further research\")\n\n            >>> # Create multilingual confidence level\n            >>> level = project.Confidence.Create(\"High\", \"en\")\n            >>> project.Confidence.SetName(level, \"Haute\", \"fr\")\n            >>> project.Confidence.SetName(level, \"Alta\", \"es\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(level_or_hvo)",
          "summary": "Delete a confidence level from the project.",
          "description": "Delete a confidence level from the project.\n",
          "parameters": [
            {
              "name": "level_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If level_or_hvo is None."
          ],
          "example": "            >>> # Delete an unused confidence level\n            >>> level = project.Confidence.Find(\"Obsolete Level\")\n            >>> if level:\n            ...     # Check if it's being used\n            ...     analyses = project.Confidence.GetAnalysesWithConfidence(level)\n            ...     if not analyses:\n            ...         project.Confidence.Delete(level)\n            ...     else:\n            ...         print(f\"Cannot delete: used by {len(analyses)} analyses\")\n\n            >>> # Delete by HVO\n            >>> project.Confidence.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - Deletion is permanent and cannot be undone\n            - Analyses and glosses using this level will lose the confidence reference\n            - Check usage with GetAnalysesWithConfidence() before deleting\n            - DO NOT delete standard confidence levels used throughout the project\n            - Consider setting a different confidence level on referencing objects first\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a confidence level, creating a new copy with a new GUID.",
          "description": "Duplicate a confidence level, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source level. If False, insert at end of confidence levels list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "Not applicable for confidence levels (no owned objects). Included for API consistency."
            }
          ],
          "returns": "ICmPossibility: The newly created duplicate confidence level with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Duplicate a confidence level\n            >>> high = project.Confidence.Find(\"High Confidence\")\n            >>> dup = project.Confidence.Duplicate(high)\n            >>> print(f\"Original: {project.Confidence.GetName(high)}\")\n            >>> print(f\"Duplicate: {project.Confidence.GetName(dup)}\")\n            Original: High Confidence\n            Duplicate: High Confidence\n            >>>\n            >>> # Modify the duplicate\n            >>> project.Confidence.SetName(dup, \"Very High Confidence\")\n            >>> project.Confidence.SetDescription(dup,\n            ...     \"Analysis confirmed by multiple expert sources\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name)",
          "summary": "Check if a confidence level with the given name exists.",
          "description": "Check if a confidence level with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The confidence level name to check."
            }
          ],
          "returns": "bool: True if confidence level exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> if project.Confidence.Exists(\"High Confidence\"):\n            ...     print(\"High confidence level exists\")\n            High confidence level exists\n\n            >>> if not project.Confidence.Exists(\"Custom Level\"):\n            ...     level = project.Confidence.Create(\"Custom Level\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find a confidence level by its name.",
          "description": "Find a confidence level by its name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The confidence level name to search for (case-insensitive)."
            }
          ],
          "returns": "ICmPossibility or None: The confidence level object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> # Find by name\n            >>> high = project.Confidence.Find(\"High Confidence\")\n            >>> if high:\n            ...     desc = project.Confidence.GetDescription(high)\n            ...     print(f\"Found: {desc}\")\n            Found: Analysis confirmed by multiple sources\n\n            >>> # Case-insensitive search\n            >>> level = project.Confidence.Find(\"high confidence\")\n            >>> print(level is not None)\n            True\n\n            >>> # Not found\n            >>> missing = project.Confidence.Find(\"Nonexistent Level\")\n            >>> print(missing)\n            None\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all confidence levels in the project.",
          "description": "Get all confidence levels in the project.\n",
          "parameters": [],
          "returns": "list: List of ICmPossibility objects representing confidence levels. ",
          "raises": [],
          "example": "            >>> # Get all confidence levels\n            >>> for level in project.Confidence.GetAll():\n            ...     name = project.Confidence.GetName(level)\n            ...     desc = project.Confidence.GetDescription(level)\n            ...     print(f\"{name}: {desc}\")\n            High Confidence: Analysis confirmed by multiple sources\n            Medium Confidence: Analysis likely but needs verification\n            Low Confidence: Tentative analysis requiring review\n            Unconfirmed: Machine-generated, not reviewed\n\n            >>> # Count confidence levels\n            >>> levels = project.Confidence.GetAll()\n            >>> print(f\"Project has {len(levels)} confidence levels\")\n            Project has 4 confidence levels\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnalysesWithConfidence",
          "signature": "GetAnalysesWithConfidence(level_or_hvo)",
          "summary": "Get all wordform analyses that use this confidence level.",
          "description": "Get all wordform analyses that use this confidence level.\n",
          "parameters": [
            {
              "name": "level_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO."
            }
          ],
          "returns": "list: List of IWfiAnalysis objects that reference this confidence level. ",
          "raises": [
            "FP_NullParameterError: If level_or_hvo is None."
          ],
          "example": "            >>> high = project.Confidence.Find(\"High Confidence\")\n            >>> analyses = project.Confidence.GetAnalysesWithConfidence(high)\n            >>> print(f\"Found {len(analyses)} high-confidence analyses\")\n            Found 127 high-confidence analyses\n\n            >>> # Show analyses for each confidence level\n            >>> for level in project.Confidence.GetAll():\n            ...     name = project.Confidence.GetName(level)\n            ...     analyses = project.Confidence.GetAnalysesWithConfidence(level)\n            ...     print(f\"{name}: {len(analyses)} analyses\")\n\n            >>> # Find analyses that need review\n            >>> low = project.Confidence.Find(\"Low Confidence\")\n            >>> if low:\n            ...     review_list = project.Confidence.GetAnalysesWithConfidence(low)\n            ...     for analysis in review_list:\n            ...         # Process analyses needing review\n            ...         pass\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDefault",
          "signature": "GetDefault()",
          "summary": "Get the default confidence level for the project.",
          "description": "Get the default confidence level for the project.\n\nThe default confidence level is typically used for new analyses when\nno specific confidence level is assigned.\n",
          "parameters": [],
          "returns": "ICmPossibility or None: The default confidence level, or None if not set. ",
          "raises": [],
          "example": "            >>> # Get default confidence level\n            >>> default = project.Confidence.GetDefault()\n            >>> if default:\n            ...     name = project.Confidence.GetName(default)\n            ...     print(f\"Default confidence level: {name}\")\n            Default confidence level: Medium Confidence\n\n            >>> # Use default for new analysis\n            >>> default = project.Confidence.GetDefault()\n            >>> if default:\n            ...     # Apply to new analysis\n            ...     pass\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(level_or_hvo, wsHandle=None)",
          "summary": "Get the description of a confidence level.",
          "description": "Get the description of a confidence level.\n",
          "parameters": [
            {
              "name": "level_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The confidence level description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If level_or_hvo is None."
          ],
          "example": "            >>> level = project.Confidence.Find(\"High Confidence\")\n            >>> desc = project.Confidence.GetDescription(level)\n            >>> print(desc)\n            Analysis confirmed by multiple sources and verified\n            by native speaker consultation.\n\n            >>> # Display all levels with descriptions\n            >>> for level in project.Confidence.GetAll():\n            ...     name = project.Confidence.GetName(level)\n            ...     desc = project.Confidence.GetDescription(level)\n            ...     if desc:\n            ...         print(f\"{name}: {desc}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGlossesWithConfidence",
          "signature": "GetGlossesWithConfidence(level_or_hvo)",
          "summary": "Get all wordform glosses that use this confidence level.",
          "description": "Get all wordform glosses that use this confidence level.\n",
          "parameters": [
            {
              "name": "level_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO."
            }
          ],
          "returns": "list: List of IWfiGloss objects that reference this confidence level. ",
          "raises": [
            "FP_NullParameterError: If level_or_hvo is None."
          ],
          "example": "            >>> high = project.Confidence.Find(\"High Confidence\")\n            >>> glosses = project.Confidence.GetGlossesWithConfidence(high)\n            >>> print(f\"Found {len(glosses)} high-confidence glosses\")\n            Found 89 high-confidence glosses\n\n            >>> # Show glosses for each confidence level\n            >>> for level in project.Confidence.GetAll():\n            ...     name = project.Confidence.GetName(level)\n            ...     glosses = project.Confidence.GetGlossesWithConfidence(level)\n            ...     print(f\"{name}: {len(glosses)} glosses\")\n\n            >>> # Find glosses that need verification\n            >>> unconfirmed = project.Confidence.Find(\"Unconfirmed\")\n            >>> if unconfirmed:\n            ...     pending = project.Confidence.GetGlossesWithConfidence(unconfirmed)\n            ...     for gloss in pending:\n            ...         # Process glosses needing verification\n            ...         pass\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(level_or_hvo)",
          "summary": "Get the GUID (Globally Unique Identifier) of a confidence level.",
          "description": "Get the GUID (Globally Unique Identifier) of a confidence level.\n",
          "parameters": [
            {
              "name": "level_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO."
            }
          ],
          "returns": "System.Guid: The confidence level's GUID. ",
          "raises": [
            "FP_NullParameterError: If level_or_hvo is None."
          ],
          "example": "            >>> level = project.Confidence.Find(\"High Confidence\")\n            >>> guid = project.Confidence.GetGuid(level)\n            >>> print(guid)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\n            >>> # Use GUID to retrieve level later\n            >>> level2 = project.Object(guid)\n            >>> print(project.Confidence.GetName(level2))\n            High Confidence\n\n            >>> # Store GUID for cross-project references\n            >>> import System\n            >>> guid_str = str(guid)\n            >>> # Later: retrieve using System.Guid.Parse(guid_str)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(level_or_hvo, wsHandle=None)",
          "summary": "Get the name of a confidence level.",
          "description": "Get the name of a confidence level.\n",
          "parameters": [
            {
              "name": "level_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The confidence level name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If level_or_hvo is None."
          ],
          "example": "            >>> level = project.Confidence.Find(\"High Confidence\")\n            >>> name = project.Confidence.GetName(level)\n            >>> print(name)\n            High Confidence\n\n            >>> # Get name in specific writing system\n            >>> name_fr = project.Confidence.GetName(level, project.WSHandle('fr'))\n            >>> print(name_fr)\n            Haute Confiance\n\n            >>> # Iterate all levels\n            >>> for level in project.Confidence.GetAll():\n            ...     name = project.Confidence.GetName(level)\n            ...     print(f\"Level: {name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.\n\nReturns all syncable properties of a confidence level including\nMultiString fields.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object (confidence level)"
            }
          ],
          "returns": "dict: Dictionary of syncable properties ",
          "raises": [],
          "example": "            >>> props = project.Confidence.GetSyncableProperties(level)\n            >>> print(props)\n            {'Name': 'High Confidence', 'Description': 'Verified analysis'}",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(level_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of a confidence level.",
          "description": "Set the description of a confidence level.\n",
          "parameters": [
            {
              "name": "level_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If level_or_hvo or description is None."
          ],
          "example": "            >>> level = project.Confidence.Find(\"High Confidence\")\n            >>> desc = (\"Analysis confirmed by multiple sources including:\\n\"\n            ...         \"- Native speaker consultation\\n\"\n            ...         \"- Published dictionary references\\n\"\n            ...         \"- Cross-linguistic comparison\")\n            >>> project.Confidence.SetDescription(level, desc)\n\n            >>> # Set multilingual descriptions\n            >>> project.Confidence.SetDescription(level, desc_en, \"en\")\n            >>> project.Confidence.SetDescription(level, desc_fr, \"fr\")\n\n            >>> # Clear description\n            >>> project.Confidence.SetDescription(level, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(level_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a confidence level.",
          "description": "Set the name of a confidence level.\n",
          "parameters": [
            {
              "name": "level_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If level_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> level = project.Confidence.Find(\"Old Name\")\n            >>> if level:\n            ...     project.Confidence.SetName(level, \"New Name\")\n            ...     print(project.Confidence.GetName(level))\n            New Name\n\n            >>> # Set multilingual names\n            >>> level = project.Confidence.Create(\"High\")\n            >>> project.Confidence.SetName(level, \"High\", \"en\")\n            >>> project.Confidence.SetName(level, \"Haute\", \"fr\")\n            >>> project.Confidence.SetName(level, \"Alta\", \"es\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ConfidenceOperations with a FLExProject instance.",
          "description": "Initialize ConfidenceOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "lists",
        "operations"
      ]
    },
    "OverlayOperations": {
      "name": "OverlayOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lists.OverlayOperations",
      "source_file": "Lists/OverlayOperations",
      "category": "lists",
      "summary": "Discourse chart overlay and layer management operations for FLEx projects.",
      "description": "Discourse chart overlay and layer management operations for FLEx projects.\n\nThis class provides methods for creating and managing overlays (layers) in\ndiscourse constituent charts. Overlays allow multiple levels of analysis to\nbe displayed in the same chart, with each overlay representing a different\nanalytical perspective or feature set.\n\nOverlays can be toggled on/off for visibility and have customizable display\norder. They are used to organize complex chart analyses by separating different\naspects of discourse structure into manageable layers.\n",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddElement",
          "signature": "AddElement(overlay_or_hvo, element)",
          "summary": "Add a chart element to an overlay.",
          "description": "Add a chart element to an overlay.\n\nAssociates a chart element with this overlay layer so it will be displayed\nwhen the overlay is visible.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            },
            {
              "name": "element",
              "type": "",
              "default": null,
              "description": "The chart element object to add."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If overlay_or_hvo or element is None.",
            "FP_ParameterError: If the overlay or element is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.Find(chart, \"Participants\")\n            >>>\n            >>> # Add a chart element to the overlay\n            >>> # (assuming 'element' is a valid chart element)\n            >>> overlay_ops.AddElement(overlay, element)\n            >>> elements = overlay_ops.GetElements(overlay)\n            >>> print(f\"Overlay now has {len(elements)} elements\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two overlays and return detailed differences.",
          "description": "Compare two overlays and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First overlay (from source project)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second overlay (from target project)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Operations instance for item1's project (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Operations instance for item2's project (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) where differences_dict contains 'properties' dict with changed property details ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(overlay1, overlay2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, details in diffs['properties'].items():\n            ...         print(f\"{prop}: {details['source']} -> {details['target']}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(chart_or_hvo, name)",
          "summary": "Create a new overlay (layer) for a discourse chart.",
          "description": "Create a new overlay (layer) for a discourse chart.\n\nCreates a new overlay that can be used to organize different aspects of\nchart analysis. The overlay is initially visible and added to the end of\nthe display order.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChart object or its HVO (integer identifier)."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the overlay. Must be non-empty."
            }
          ],
          "returns": "Overlay object: The newly created overlay. ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If chart_or_hvo or name is None.",
            "FP_ParameterError: If name is empty or chart is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>>\n            >>> # Create overlays for different analytical perspectives\n            >>> participants = overlay_ops.Create(chart, \"Participants\")\n            >>> overlay_ops.SetDescription(participants, \"Track participant chains\")\n            >>>\n            >>> discourse = overlay_ops.Create(chart, \"Discourse Features\")\n            >>> overlay_ops.SetDescription(discourse, \"Discourse markers and structure\")\n            >>>\n            >>> theme = overlay_ops.Create(chart, \"Thematic Structure\")\n            >>> print(f\"Created overlay: {overlay_ops.GetName(theme)}\")\n            Created overlay: Thematic Structure\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(overlay_or_hvo)",
          "summary": "Delete an overlay from its chart.",
          "description": "Delete an overlay from its chart.\n\nRemoves the overlay and all its associated elements from the chart. This\nwill affect the display of the chart but does not delete the underlying\nchart data.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If overlay_or_hvo is None.",
            "FP_ParameterError: If the overlay does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlays = list(overlay_ops.GetAll(chart))\n            >>> if overlays:\n            ...     # Delete the last overlay\n            ...     overlay_ops.Delete(overlays[-1])\n            ...     print(f\"Chart now has {len(list(overlay_ops.GetAll(chart)))} overlays\")\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - All overlay configuration and associations will be lost\n            - Chart elements linked only to this overlay may become orphaned\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate an overlay, creating a new copy with a new GUID.",
          "description": "Duplicate an overlay, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source overlay. If False, insert at end of owner's collection."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned sub-possibilities. If False (default), only copy simple properties."
            }
          ],
          "returns": "Overlay object: The newly created duplicate overlay with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the overlay is invalid or has no owner."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.Find(chart, \"Participants\")\n            >>> if overlay:\n            ...     dup = overlay_ops.Duplicate(overlay)\n            ...     print(f\"Original: {overlay_ops.GetName(overlay)}\")\n            ...     print(f\"Duplicate: {overlay_ops.GetName(dup)}\")\n            Original: Participants\n            Duplicate: Participants\n            >>>\n            >>> # Modify the duplicate\n            >>> overlay_ops.SetName(dup, \"Secondary Participants\")\n            >>> overlay_ops.SetDescription(dup, \"Track secondary participant chains\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(chart_or_hvo, name)",
          "summary": "Find an overlay by name within a chart.",
          "description": "Find an overlay by name within a chart.\n\nSearches for an overlay with the specified name in the given chart.\nSearch is case-sensitive.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChart object or its HVO (integer identifier)."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the overlay to find."
            }
          ],
          "returns": "Overlay object or None: The overlay if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo or name is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>>\n            >>> # Find a specific overlay\n            >>> participants = overlay_ops.Find(chart, \"Participants\")\n            >>> if participants:\n            ...     print(f\"Found overlay: {overlay_ops.GetName(participants)}\")\n            ... else:\n            ...     print(\"Overlay not found\")\n            Found overlay: Participants\n            >>>\n            >>> # Search is case-sensitive\n            >>> result = overlay_ops.Find(chart, \"participants\")\n            >>> print(result)\n            None\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByChart",
          "signature": "FindByChart(chart_or_hvo, name)",
          "summary": "Find an overlay by name within a specific chart.",
          "description": "Find an overlay by name within a specific chart.\n\nThis is an alias for Find() for consistency with other operations classes.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChart object or its HVO (integer identifier)."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the overlay to find."
            }
          ],
          "returns": "Overlay object or None: The overlay if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo or name is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.FindByChart(chart, \"Participants\")\n            >>> if overlay:\n            ...     print(f\"Found: {overlay_ops.GetName(overlay)}\")\n            Found: Participants\n\n        See Also:\n            Find, GetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(chart_or_hvo)",
          "summary": "Get all overlays (layers) for a discourse chart.",
          "description": "Get all overlays (layers) for a discourse chart.\n\nRetrieves all overlay layers defined for the specified chart, including\nboth visible and hidden overlays.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChart object or its HVO (integer identifier)."
            }
          ],
          "returns": "Overlay objects: Each overlay/layer associated with the chart. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlays = list(overlay_ops.GetAll(chart))\n            >>> print(f\"Chart has {len(overlays)} overlays\")\n            Chart has 3 overlays\n            >>>\n            >>> for overlay in overlays:\n            ...     name = overlay_ops.GetName(overlay)\n            ...     visible = overlay_ops.IsVisible(overlay)\n            ...     print(f\"Overlay: {name} (visible: {visible})\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetChart",
          "signature": "GetChart(overlay_or_hvo)",
          "summary": "Get the chart that owns an overlay.",
          "description": "Get the chart that owns an overlay.\n\nRetrieves the IConstChart object that contains this overlay.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            }
          ],
          "returns": "IConstChart: The chart object that owns the overlay. ",
          "raises": [
            "FP_NullParameterError: If overlay_or_hvo is None.",
            "FP_ParameterError: If the overlay does not exist or has no owner."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlays = list(overlay_ops.GetAll(chart))\n            >>> if overlays:\n            ...     owner_chart = overlay_ops.GetChart(overlays[0])\n            ...     chart_name = discourse_ops.GetChartName(owner_chart)\n            ...     print(f\"Overlay belongs to chart: {chart_name}\")\n            Overlay belongs to chart: Main Analysis\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(overlay_or_hvo, wsHandle=None)",
          "summary": "Get the description of an overlay.",
          "description": "Get the description of an overlay.\n\nRetrieves the overlay's description in the specified writing system, or\nthe default analysis writing system if not specified.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system."
            }
          ],
          "returns": "str: The overlay description in the specified writing system. Returns empty string if no description is set. ",
          "raises": [
            "FP_NullParameterError: If overlay_or_hvo is None.",
            "FP_ParameterError: If the overlay does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.Find(chart, \"Participants\")\n            >>> if overlay:\n            ...     desc = overlay_ops.GetDescription(overlay)\n            ...     if desc:\n            ...         print(f\"Description: {desc}\")\n            ... else:\n            ...     print(\"No description set\")\n            Description: Track participant chains throughout the discourse\n\n        See Also:\n            SetDescription, GetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDisplayOrder",
          "signature": "GetDisplayOrder(overlay_or_hvo)",
          "summary": "Get the display order of an overlay.",
          "description": "Get the display order of an overlay.\n\nRetrieves the numeric position that determines the order in which overlays\nare displayed in the chart. Lower numbers appear first.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            }
          ],
          "returns": "int: The display order position (0-based). Returns 0 if not set. ",
          "raises": [
            "FP_NullParameterError: If overlay_or_hvo is None.",
            "FP_ParameterError: If the overlay does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlays = list(overlay_ops.GetAll(chart))\n            >>> for overlay in overlays:\n            ...     name = overlay_ops.GetName(overlay)\n            ...     order = overlay_ops.GetDisplayOrder(overlay)\n            ...     print(f\"{order}: {name}\")\n            0: Participants\n            1: Discourse Features\n            2: Theme\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetElements",
          "signature": "GetElements(overlay_or_hvo)",
          "summary": "Get all chart elements associated with an overlay.",
          "description": "Get all chart elements associated with an overlay.\n\nRetrieves the chart elements (cells, markers, word groups, etc.) that are\ndisplayed in this overlay layer.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            }
          ],
          "returns": "list: List of chart element objects. Returns empty list if no elements. ",
          "raises": [
            "FP_NullParameterError: If overlay_or_hvo is None.",
            "FP_ParameterError: If the overlay does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.Find(chart, \"Participants\")\n            >>> if overlay:\n            ...     elements = overlay_ops.GetElements(overlay)\n            ...     print(f\"Overlay has {len(elements)} elements\")\n            Overlay has 12 elements\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(overlay_or_hvo)",
          "summary": "Get the GUID of an overlay.",
          "description": "Get the GUID of an overlay.\n\nRetrieves the globally unique identifier for the overlay.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            }
          ],
          "returns": "System.Guid: The GUID of the overlay. ",
          "raises": [
            "FP_NullParameterError: If overlay_or_hvo is None.",
            "FP_ParameterError: If the overlay does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlays = list(overlay_ops.GetAll(chart))\n            >>> if overlays:\n            ...     guid = overlay_ops.GetGuid(overlays[0])\n            ...     print(f\"Overlay GUID: {guid}\")\n            Overlay GUID: 12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(overlay_or_hvo, wsHandle=None)",
          "summary": "Get the name of an overlay.",
          "description": "Get the name of an overlay.\n\nRetrieves the overlay's name in the specified writing system, or the default\nanalysis writing system if not specified.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system."
            }
          ],
          "returns": "str: The overlay name in the specified writing system. Returns empty string if no name is set. ",
          "raises": [
            "FP_NullParameterError: If overlay_or_hvo is None.",
            "FP_ParameterError: If the overlay does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlays = list(overlay_ops.GetAll(chart))\n            >>> if overlays:\n            ...     name = overlay_ops.GetName(overlays[0])\n            ...     print(f\"Overlay name: {name}\")\n            Overlay name: Participants\n\n        See Also:\n            SetName, GetDescription",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPossItems",
          "signature": "GetPossItems(overlay_or_hvo)",
          "summary": "Get the possibility items (column/row labels) for an overlay.",
          "description": "Get the possibility items (column/row labels) for an overlay.\n\nRetrieves the possibility items that define the structure of this overlay,\nsuch as column headers or row labels.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            }
          ],
          "returns": "list: List of ICmPossibility objects. Returns empty list if none. ",
          "raises": [
            "FP_NullParameterError: If overlay_or_hvo is None.",
            "FP_ParameterError: If the overlay does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.Find(chart, \"Participants\")\n            >>> if overlay:\n            ...     items = overlay_ops.GetPossItems(overlay)\n            ...     print(f\"Overlay has {len(items)} possibility items\")\n            Overlay has 5 possibility items\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.\n\nReturns all syncable properties of an overlay including MultiString fields\nand boolean/atomic properties.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The overlay object (ICmPossibility or similar)"
            }
          ],
          "returns": "dict: Dictionary of syncable properties ",
          "raises": [],
          "example": "            >>> props = overlay_ops.GetSyncableProperties(overlay)\n            >>> print(props)\n            {'Name': 'Participants', 'Description': '...', 'Hidden': False, 'SortSpec': 0}",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetVisibleOverlays",
          "signature": "GetVisibleOverlays(chart_or_hvo)",
          "summary": "Get all visible overlays for a chart.",
          "description": "Get all visible overlays for a chart.\n\nRetrieves only the overlays that are currently set to be visible in the\nchart view, filtered by their visibility status.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChart object or its HVO (integer identifier)."
            }
          ],
          "returns": "Overlay objects: Each visible overlay in the chart. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>>\n            >>> # Get only visible overlays\n            >>> visible = list(overlay_ops.GetVisibleOverlays(chart))\n            >>> print(f\"Chart has {len(visible)} visible overlays\")\n            Chart has 2 visible overlays\n            >>>\n            >>> for overlay in visible:\n            ...     name = overlay_ops.GetName(overlay)\n            ...     order = overlay_ops.GetDisplayOrder(overlay)\n            ...     print(f\"{order}: {name}\")\n            0: Participants\n            2: Theme\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsVisible",
          "signature": "IsVisible(overlay_or_hvo)",
          "summary": "Check if an overlay is currently visible.",
          "description": "Check if an overlay is currently visible.\n\nDetermines whether the overlay is set to be displayed in the chart view.\nHidden overlays are still part of the chart but not shown in the UI.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            }
          ],
          "returns": "bool: True if the overlay is visible, False if hidden. ",
          "raises": [
            "FP_NullParameterError: If overlay_or_hvo is None.",
            "FP_ParameterError: If the overlay does not exist or is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlays = list(overlay_ops.GetAll(chart))\n            >>> for overlay in overlays:\n            ...     name = overlay_ops.GetName(overlay)\n            ...     visible = overlay_ops.IsVisible(overlay)\n            ...     status = \"visible\" if visible else \"hidden\"\n            ...     print(f\"{name}: {status}\")\n            Participants: visible\n            Discourse Features: hidden\n            Theme: visible\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveElement",
          "signature": "RemoveElement(overlay_or_hvo, element)",
          "summary": "Remove a chart element from an overlay.",
          "description": "Remove a chart element from an overlay.\n\nRemoves the association between a chart element and this overlay layer.\nThe element remains in the chart but is no longer displayed in this overlay.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            },
            {
              "name": "element",
              "type": "",
              "default": null,
              "description": "The chart element object to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If overlay_or_hvo or element is None.",
            "FP_ParameterError: If the overlay or element is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.Find(chart, \"Participants\")\n            >>> elements = overlay_ops.GetElements(overlay)\n            >>> if elements:\n            ...     # Remove the first element\n            ...     overlay_ops.RemoveElement(overlay, elements[0])\n            ...     print(f\"Overlay now has {len(overlay_ops.GetElements(overlay))} elements\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(overlay_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of an overlay.",
          "description": "Set the description of an overlay.\n\nUpdates the overlay's description in the specified writing system, or the\ndefault analysis writing system if not specified.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The description text. Can be empty to clear."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If overlay_or_hvo or description is None.",
            "FP_ParameterError: If the overlay is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.Find(chart, \"Participants\")\n            >>> if overlay:\n            ...     overlay_ops.SetDescription(\n            ...         overlay,\n            ...         \"Track participant chains and reference throughout the narrative\"\n            ...     )\n            ...     print(overlay_ops.GetDescription(overlay))\n            Track participant chains and reference throughout the narrative\n\n        See Also:\n            GetDescription, SetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDisplayOrder",
          "signature": "SetDisplayOrder(overlay_or_hvo, order)",
          "summary": "Set the display order of an overlay.",
          "description": "Set the display order of an overlay.\n\nUpdates the numeric position that determines the order in which overlays\nare displayed in the chart. Lower numbers appear first.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            },
            {
              "name": "order",
              "type": "int",
              "default": null,
              "description": "The display order position (0-based). Must be non-negative."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If overlay_or_hvo or order is None.",
            "FP_ParameterError: If order is negative or overlay is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.Find(chart, \"Theme\")\n            >>>\n            >>> # Move to first position\n            >>> overlay_ops.SetDisplayOrder(overlay, 0)\n            >>> print(f\"Display order: {overlay_ops.GetDisplayOrder(overlay)}\")\n            Display order: 0\n            >>>\n            >>> # Move to third position\n            >>> overlay_ops.SetDisplayOrder(overlay, 2)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(overlay_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of an overlay.",
          "description": "Set the name of an overlay.\n\nUpdates the overlay's name in the specified writing system, or the default\nanalysis writing system if not specified.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name for the overlay. Must be non-empty."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If overlay_or_hvo or name is None.",
            "FP_ParameterError: If name is empty or overlay is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlays = list(overlay_ops.GetAll(chart))\n            >>> if overlays:\n            ...     overlay_ops.SetName(overlays[0], \"Participant Tracking\")\n            ...     print(overlay_ops.GetName(overlays[0]))\n            Participant Tracking\n\n        See Also:\n            GetName, SetDescription",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetVisible",
          "signature": "SetVisible(overlay_or_hvo, visible)",
          "summary": "Set the visibility status of an overlay.",
          "description": "Set the visibility status of an overlay.\n\nControls whether the overlay is displayed in the chart view. Hidden overlays\nremain part of the chart but are not shown in the UI.\n",
          "parameters": [
            {
              "name": "overlay_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an overlay object or its HVO (integer identifier)."
            },
            {
              "name": "visible",
              "type": "bool",
              "default": null,
              "description": "True to make visible, False to hide."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If overlay_or_hvo or visible is None.",
            "FP_ParameterError: If the overlay is invalid."
          ],
          "example": "            >>> overlay_ops = OverlayOperations(project)\n            >>> chart = discourse_ops.GetAllCharts(text)[0]\n            >>> overlay = overlay_ops.Find(chart, \"Participants\")\n            >>>\n            >>> # Hide an overlay\n            >>> overlay_ops.SetVisible(overlay, False)\n            >>> print(f\"Visible: {overlay_ops.IsVisible(overlay)}\")\n            Visible: False\n            >>>\n            >>> # Show it again\n            >>> overlay_ops.SetVisible(overlay, True)\n            >>> print(f\"Visible: {overlay_ops.IsVisible(overlay)}\")\n            Visible: True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize OverlayOperations with a FLExProject instance.",
          "description": "Initialize OverlayOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "lists",
        "operations"
      ]
    },
    "PossibilityListOperations": {
      "name": "PossibilityListOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lists.PossibilityListOperations",
      "source_file": "Lists/PossibilityListOperations",
      "category": "lists",
      "summary": "This class provides generic operations for managing possibility lists\nin a FieldWorks project.",
      "description": "This class provides generic operations for managing possibility lists\nin a FieldWorks project.\n\nPossibility lists are hierarchical categorization systems used throughout\nFLEx for various purposes (e.g., semantic domains, parts of speech,\ngrammatical categories, locations, people, text genres, etc.).\n\nThis class provides generic operations that work with any possibility list,\nregardless of its specific purpose.\n\nThis class should be accessed via FLExProject.PossibilityLists property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all possibility lists in the project\nfor poss_list in project.PossibilityLists.GetAllLists():\nname = project.PossibilityLists.GetListName(poss_list)\nprint(f\"List: {name}\")\n\n# Get items in each list\nitems = project.PossibilityLists.GetItems(poss_list, flat=True)\nprint(f\"  Contains {len(items)} items\")\n\n# Work with a specific list\ngenre_list = project.PossibilityLists.FindList(\"Text Genres\")\nif genre_list:\n# Create a new genre\nnarrative = project.PossibilityLists.CreateItem(\ngenre_list, \"Narrative\", \"en\")\n\n# Create a sub-genre\nfolktale = project.PossibilityLists.CreateItem(\ngenre_list, \"Folktale\", \"en\", parent=narrative)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two possibility items and return detailed differences.",
          "description": "Compare two possibility items and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First item (from source project)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second item (from target project)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Operations instance for item1's project (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Operations instance for item2's project (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) where differences_dict contains 'properties' dict with changed property details ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(item1, item2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, details in diffs['properties'].items():\n            ...         print(f\"{prop}: {details['source']} -> {details['target']}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateItem",
          "signature": "CreateItem(list_or_hvo, name, wsHandle=None, parent=None)",
          "summary": "Create a new item in a possibility list.",
          "description": "Create a new item in a possibility list.\n",
          "parameters": [
            {
              "name": "list_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibilityList object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the new item."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            },
            {
              "name": "parent",
              "type": "",
              "default": null,
              "description": "Optional parent ICmPossibility object or HVO. If None, creates a top-level item. If provided, creates a subitem."
            }
          ],
          "returns": "ICmPossibility: The newly created item object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If list_or_hvo or name is None.",
            "FP_ParameterError: If name is empty or parent is invalid."
          ],
          "example": "            >>> # Create a top-level item\n            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> narrative = project.PossibilityLists.CreateItem(\n            ...     genre_list, \"Narrative\", \"en\")\n            >>> print(project.PossibilityLists.GetItemName(narrative))\n            Narrative\n\n            >>> # Create a subitem\n            >>> folktale = project.PossibilityLists.CreateItem(\n            ...     genre_list, \"Folktale\", \"en\", parent=narrative)\n            >>> parent = project.PossibilityLists.GetParentItem(folktale)\n            >>> print(project.PossibilityLists.GetItemName(parent))\n            Narrative\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateList",
          "signature": "CreateList(name, wsHandle=None)",
          "summary": "Create a new possibility list.",
          "description": "Create a new possibility list.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the new list."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmPossibilityList: The newly created list object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> # Create a custom possibility list\n            >>> custom_list = project.PossibilityLists.CreateList(\"Custom Categories\")\n            >>> print(project.PossibilityLists.GetListName(custom_list))\n            Custom Categories\n\n        Warning:\n            - Custom possibility lists may not integrate with all FLEx features\n            - Consider using existing lists where possible\n            - Created lists are not automatically linked to any field\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "DeleteItem",
          "signature": "DeleteItem(item_or_hvo)",
          "summary": "Delete an item from a possibility list.",
          "description": "Delete an item from a possibility list.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Delete an item\n            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> obsolete = project.PossibilityLists.FindItem(genre_list, \"Obsolete\")\n            >>> if obsolete:\n            ...     project.PossibilityLists.DeleteItem(obsolete)\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - Deletes all subitems recursively\n            - Objects referencing this item will lose the reference\n            - Consider removing references first\n            - DO NOT delete standard list items unless you know what you're doing\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "DeleteList",
          "signature": "DeleteList(list_or_hvo)",
          "summary": "Delete a possibility list.",
          "description": "Delete a possibility list.\n",
          "parameters": [
            {
              "name": "list_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibilityList object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If list_or_hvo is None.",
            "FP_ParameterError: If trying to delete a system list."
          ],
          "example": "            >>> # Delete a custom list\n            >>> custom = project.PossibilityLists.FindList(\"Old Custom List\")\n            >>> if custom:\n            ...     project.PossibilityLists.DeleteList(custom)\n\n        Warning:\n            - DO NOT delete standard FLEx lists (semantic domains, POS, etc.)\n            - Deletion is permanent and cannot be undone\n            - Deletes all items in the list recursively\n            - Any fields referencing this list will be broken\n            - Only delete custom lists that are no longer needed\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a possibility item, creating a new copy with a new GUID.",
          "description": "Duplicate a possibility item, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source item. If False, insert at end of parent's collection."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned subitems recursively. If False (default), only copy simple properties."
            }
          ],
          "returns": "ICmPossibility: The newly created duplicate item with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Duplicate a top-level item (shallow copy)\n            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> narrative = project.PossibilityLists.FindItem(genre_list, \"Narrative\")\n            >>> dup = project.PossibilityLists.Duplicate(narrative)\n            >>> print(f\"Original: {project.PossibilityLists.GetItemName(narrative)}\")\n            >>> print(f\"Duplicate: {project.PossibilityLists.GetItemName(dup)}\")\n            Original: Narrative\n            Duplicate: Narrative\n            >>>\n            >>> # Modify the duplicate\n            >>> project.PossibilityLists.SetItemName(dup, \"Epic Narrative\")\n            >>> project.PossibilityLists.SetItemAbbreviation(dup, \"Epic\")\n            >>>\n            >>> # Deep duplicate (includes all subitems)\n            >>> deep_dup = project.PossibilityLists.Duplicate(narrative, deep=True)\n            >>> subitems = project.PossibilityLists.GetSubitems(deep_dup)\n            >>> print(f\"Duplicate has {len(subitems)} subitems\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindItem",
          "signature": "FindItem(list_or_hvo, name)",
          "summary": "Find an item in a possibility list by name.",
          "description": "Find an item in a possibility list by name.\n",
          "parameters": [
            {
              "name": "list_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibilityList object or HVO to search in."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The item name to search for (case-insensitive)."
            }
          ],
          "returns": "ICmPossibility or None: The item object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If list_or_hvo or name is None."
          ],
          "example": "            >>> # Find an item\n            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> narrative = project.PossibilityLists.FindItem(genre_list, \"Narrative\")\n            >>> if narrative:\n            ...     subitems = project.PossibilityLists.GetSubitems(narrative)\n            ...     print(f\"Found {len(subitems)} sub-genres\")\n\n            >>> # Case-insensitive search\n            >>> item = project.PossibilityLists.FindItem(genre_list, \"narrative\")\n            >>> print(item is not None)\n            True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindList",
          "signature": "FindList(name)",
          "summary": "Find a possibility list by its name.",
          "description": "Find a possibility list by its name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The list name to search for (case-insensitive)."
            }
          ],
          "returns": "ICmPossibilityList or None: The list object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> # Find the semantic domains list\n            >>> sd_list = project.PossibilityLists.FindList(\"Semantic Domains\")\n            >>> if sd_list:\n            ...     items = project.PossibilityLists.GetItems(sd_list, flat=True)\n            ...     print(f\"Found {len(items)} semantic domains\")\n\n            >>> # Find text genres list\n            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllLists",
          "signature": "GetAllLists()",
          "summary": "Get all possibility lists in the project.",
          "description": "Get all possibility lists in the project.\n",
          "parameters": [],
          "returns": "list: List of ICmPossibilityList objects representing all possibility lists in the project. ",
          "raises": [],
          "example": "            >>> for poss_list in project.PossibilityLists.GetAllLists():\n            ...     name = project.PossibilityLists.GetListName(poss_list)\n            ...     guid = project.PossibilityLists.GetListGuid(poss_list)\n            ...     print(f\"{name}: {guid}\")\n            Semantic Domains: 63403699-07c1-43f3-a47c-069d6e4316e5\n            Parts of Speech: d1b6f191-6664-4f28-b2cc-5c37e24f69f1\n            Text Genres: 3f99fdad-19c9-44e7-8d04-4b0f284137f9\n            ...\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDepth",
          "signature": "GetDepth(item_or_hvo)",
          "summary": "Get the depth of an item in the hierarchy.",
          "description": "Get the depth of an item in the hierarchy.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "int: The depth (0 for top-level, 1 for first level subitems, etc.). ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Top-level item\n            >>> pos_list = project.PossibilityLists.FindList(\"Parts of Speech\")\n            >>> noun = project.PossibilityLists.FindItem(pos_list, \"Noun\")\n            >>> depth = project.PossibilityLists.GetDepth(noun)\n            >>> print(depth)\n            0\n\n            >>> # Second-level item\n            >>> proper = project.PossibilityLists.FindItem(pos_list, \"Proper Noun\")\n            >>> depth = project.PossibilityLists.GetDepth(proper)\n            >>> print(depth)\n            1\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetItemAbbreviation",
          "signature": "GetItemAbbreviation(item_or_hvo, wsHandle=None)",
          "summary": "Get the abbreviation of a possibility item.",
          "description": "Get the abbreviation of a possibility item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The item abbreviation, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> pos_list = project.PossibilityLists.FindList(\"Parts of Speech\")\n            >>> noun = project.PossibilityLists.FindItem(pos_list, \"Noun\")\n            >>> abbr = project.PossibilityLists.GetItemAbbreviation(noun)\n            >>> print(abbr)\n            N\n\n        See Also:\n            SetItemAbbreviation, GetItemName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetItemDescription",
          "signature": "GetItemDescription(item_or_hvo, wsHandle=None)",
          "summary": "Get the description of a possibility item.",
          "description": "Get the description of a possibility item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The item description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> sd_list = project.PossibilityLists.FindList(\"Semantic Domains\")\n            >>> walk = project.PossibilityLists.FindItem(sd_list, \"Walk\")\n            >>> desc = project.PossibilityLists.GetItemDescription(walk)\n            >>> print(desc)\n            Use this domain for words related to walking.\n\n        See Also:\n            SetItemDescription, GetItemName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetItemGuid",
          "signature": "GetItemGuid(item_or_hvo)",
          "summary": "Get the GUID of a possibility item.",
          "description": "Get the GUID of a possibility item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "System.Guid: The item's globally unique identifier. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> pos_list = project.PossibilityLists.FindList(\"Parts of Speech\")\n            >>> noun = project.PossibilityLists.FindItem(pos_list, \"Noun\")\n            >>> guid = project.PossibilityLists.GetItemGuid(noun)\n            >>> print(guid)\n            a23b6fcc-654c-4983-a11c-5e4e15e1f6e9\n\n            >>> # Use GUID to retrieve item later\n            >>> retrieved = project.Object(guid)\n            >>> name = project.PossibilityLists.GetItemName(retrieved)\n            >>> print(name)\n            Noun\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetItemHvo",
          "signature": "GetItemHvo(item)",
          "summary": "Get the HVO (handle value) of a possibility item.",
          "description": "Get the HVO (handle value) of a possibility item.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object."
            }
          ],
          "returns": "int: The item's HVO. ",
          "raises": [
            "FP_NullParameterError: If item is None."
          ],
          "example": "            >>> pos_list = project.PossibilityLists.FindList(\"Parts of Speech\")\n            >>> noun = project.PossibilityLists.FindItem(pos_list, \"Noun\")\n            >>> hvo = project.PossibilityLists.GetItemHvo(noun)\n            >>> print(hvo)\n            123456\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetItemName",
          "signature": "GetItemName(item_or_hvo, wsHandle=None)",
          "summary": "Get the name of a possibility item.",
          "description": "Get the name of a possibility item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The item name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> items = project.PossibilityLists.GetItems(genre_list)\n            >>> for item in items:\n            ...     name = project.PossibilityLists.GetItemName(item)\n            ...     print(f\"Genre: {name}\")\n            Genre: Narrative\n            Genre: Procedural\n            Genre: Expository\n\n            >>> # Get name in a specific writing system\n            >>> name_fr = project.PossibilityLists.GetItemName(\n            ...     item, project.WSHandle('fr'))\n\n        See Also:\n            SetItemName, GetItemAbbreviation, FindItem",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetItems",
          "signature": "GetItems(list_or_hvo, flat=False)",
          "summary": "Get items from a possibility list.",
          "description": "Get items from a possibility list.\n",
          "parameters": [
            {
              "name": "list_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibilityList object or HVO."
            },
            {
              "name": "flat",
              "type": "bool",
              "default": false,
              "description": "If True, returns a flat list of all items including nested items. If False, returns only top-level items. Defaults to False."
            }
          ],
          "returns": "list: List of ICmPossibility objects. ",
          "raises": [
            "FP_NullParameterError: If list_or_hvo is None."
          ],
          "example": "            >>> # Get top-level items only\n            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> top_items = project.PossibilityLists.GetItems(genre_list)\n            >>> for item in top_items:\n            ...     name = project.PossibilityLists.GetItemName(item)\n            ...     print(name)\n            Narrative\n            Procedural\n            Expository\n            ...\n\n            >>> # Get all items including nested ones\n            >>> all_items = project.PossibilityLists.GetItems(genre_list, flat=True)\n            >>> print(f\"Total items: {len(all_items)}\")\n            Total items: 25\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetListGuid",
          "signature": "GetListGuid(list_or_hvo)",
          "summary": "Get the GUID of a possibility list.",
          "description": "Get the GUID of a possibility list.\n",
          "parameters": [
            {
              "name": "list_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibilityList object or HVO."
            }
          ],
          "returns": "System.Guid: The list's globally unique identifier. ",
          "raises": [
            "FP_NullParameterError: If list_or_hvo is None."
          ],
          "example": "            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> guid = project.PossibilityLists.GetListGuid(genre_list)\n            >>> print(guid)\n            3f99fdad-19c9-44e7-8d04-4b0f284137f9\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetListHvo",
          "signature": "GetListHvo(poss_list)",
          "summary": "Get the HVO (handle value) of a possibility list.",
          "description": "Get the HVO (handle value) of a possibility list.\n",
          "parameters": [
            {
              "name": "poss_list",
              "type": "",
              "default": null,
              "description": "The ICmPossibilityList object."
            }
          ],
          "returns": "int: The list's HVO. ",
          "raises": [
            "FP_NullParameterError: If poss_list is None."
          ],
          "example": "            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> hvo = project.PossibilityLists.GetListHvo(genre_list)\n            >>> print(hvo)\n            789012\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetListName",
          "signature": "GetListName(list_or_hvo, wsHandle=None)",
          "summary": "Get the name of a possibility list.",
          "description": "Get the name of a possibility list.\n",
          "parameters": [
            {
              "name": "list_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibilityList object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The list name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If list_or_hvo is None."
          ],
          "example": "            >>> lists = project.PossibilityLists.GetAllLists()\n            >>> for poss_list in lists:\n            ...     name = project.PossibilityLists.GetListName(poss_list)\n            ...     print(f\"List: {name}\")\n            List: Semantic Domains\n            List: Parts of Speech\n            List: Text Genres\n            ...\n\n        See Also:\n            SetListName, FindList",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParentItem",
          "signature": "GetParentItem(item_or_hvo)",
          "summary": "Get the parent item of a possibility item.",
          "description": "Get the parent item of a possibility item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "ICmPossibility or None: The parent item, or None if top-level. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Get parent\n            >>> pos_list = project.PossibilityLists.FindList(\"Parts of Speech\")\n            >>> proper_noun = project.PossibilityLists.FindItem(\n            ...     pos_list, \"Proper Noun\")\n            >>> parent = project.PossibilityLists.GetParentItem(proper_noun)\n            >>> if parent:\n            ...     name = project.PossibilityLists.GetItemName(parent)\n            ...     print(f\"Parent: {name}\")\n            Parent: Noun\n\n            >>> # Top-level items have no parent\n            >>> noun = project.PossibilityLists.FindItem(pos_list, \"Noun\")\n            >>> parent = project.PossibilityLists.GetParentItem(noun)\n            >>> print(parent)\n            None\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubitems",
          "signature": "GetSubitems(item_or_hvo)",
          "summary": "Get all direct child subitems of a possibility item.",
          "description": "Get all direct child subitems of a possibility item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "list: List of ICmPossibility child objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Get subitems\n            >>> pos_list = project.PossibilityLists.FindList(\"Parts of Speech\")\n            >>> noun = project.PossibilityLists.FindItem(pos_list, \"Noun\")\n            >>> subcats = project.PossibilityLists.GetSubitems(noun)\n            >>> for subcat in subcats:\n            ...     name = project.PossibilityLists.GetItemName(subcat)\n            ...     print(f\"  {name}\")\n              Proper Noun\n              Common Noun\n              Count Noun\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.\n\nReturns all syncable properties of a possibility item including\nMultiString fields.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object"
            }
          ],
          "returns": "dict: Dictionary of syncable properties ",
          "raises": [],
          "example": "            >>> props = project.PossibilityLists.GetSyncableProperties(item)\n            >>> print(props)\n            {'Name': 'Narrative', 'Abbreviation': 'Narr', 'Description': '...'}",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveItem",
          "signature": "MoveItem(item_or_hvo, new_parent_or_hvo=None)",
          "summary": "Move an item to a different parent or to top level.",
          "description": "Move an item to a different parent or to top level.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO to move."
            },
            {
              "name": "new_parent_or_hvo",
              "type": "",
              "default": null,
              "description": "The new parent ICmPossibility object or HVO. If None, moves item to top level of its list."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If new parent is in a different list or",
            "if trying to make an item its own descendant."
          ],
          "example": "            >>> # Move item to a different parent\n            >>> pos_list = project.PossibilityLists.FindList(\"Parts of Speech\")\n            >>> common_noun = project.PossibilityLists.FindItem(\n            ...     pos_list, \"Common Noun\")\n            >>> noun = project.PossibilityLists.FindItem(pos_list, \"Noun\")\n            >>> project.PossibilityLists.MoveItem(common_noun, noun)\n\n            >>> # Move item to top level\n            >>> project.PossibilityLists.MoveItem(common_noun, None)\n\n        Warning:\n            - Cannot move item to its own descendant (would create cycle)\n            - Cannot move item between different lists\n            - Moving changes the item's hierarchical position\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetItemAbbreviation",
          "signature": "SetItemAbbreviation(item_or_hvo, abbr, wsHandle=None)",
          "summary": "Set the abbreviation of a possibility item.",
          "description": "Set the abbreviation of a possibility item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "abbr",
              "type": "str",
              "default": null,
              "description": "The new abbreviation."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or abbr is None."
          ],
          "example": "            >>> pos_list = project.PossibilityLists.FindList(\"Parts of Speech\")\n            >>> noun = project.PossibilityLists.FindItem(pos_list, \"Noun\")\n            >>> project.PossibilityLists.SetItemAbbreviation(noun, \"N\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetItemDescription",
          "signature": "SetItemDescription(item_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of a possibility item.",
          "description": "Set the description of a possibility item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or description is None."
          ],
          "example": "            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> narrative = project.PossibilityLists.FindItem(genre_list, \"Narrative\")\n            >>> project.PossibilityLists.SetItemDescription(\n            ...     narrative, \"Stories that tell about events in sequence\")\n\n        See Also:\n            GetItemDescription, SetItemName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetItemName",
          "signature": "SetItemName(item_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a possibility item.",
          "description": "Set the name of a possibility item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> genre_list = project.PossibilityLists.FindList(\"Text Genres\")\n            >>> item = project.PossibilityLists.FindItem(genre_list, \"Old Name\")\n            >>> if item:\n            ...     project.PossibilityLists.SetItemName(item, \"New Name\")\n\n        See Also:\n            GetItemName, SetItemAbbreviation",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetListName",
          "signature": "SetListName(list_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a possibility list.",
          "description": "Set the name of a possibility list.\n",
          "parameters": [
            {
              "name": "list_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibilityList object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If list_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> custom_list = project.PossibilityLists.CreateList(\"Temp\")\n            >>> project.PossibilityLists.SetListName(custom_list, \"Custom List\")\n\n        Warning:\n            - Renaming standard FLEx lists is not recommended\n            - Only rename custom lists you created\n            - Changes affect how the list appears throughout the UI\n\n        See Also:\n            GetListName, CreateList",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize PossibilityListOperations with a FLExProject instance.",
          "description": "Initialize PossibilityListOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "lists",
        "operations"
      ]
    },
    "PublicationOperations": {
      "name": "PublicationOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lists.PublicationOperations",
      "source_file": "Lists/PublicationOperations",
      "category": "lists",
      "summary": "This class provides operations for managing publications and publishing\nworkflows in a FieldWorks project.",
      "description": "This class provides operations for managing publications and publishing\nworkflows in a FieldWorks project.\n\nPublications in FLEx define output formats for dictionary and text publishing.\nThey specify page layouts, formatting options, divisions (e.g., main entries,\nminor entries), header/footer settings, and default publication types. These\nare used when exporting dictionaries or texts to various formats.\n\nThis class should be accessed via FLExProject.Publications property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all publications\nfor pub in project.Publications.GetAll():\nname = project.Publications.GetName(pub)\nis_default = project.Publications.GetIsDefault(pub)\nprint(f\"{name} (Default: {is_default})\")\n\n# Create a new publication\npub = project.Publications.Create(\"Web Dictionary\", \"en\")\n\n# Set page layout and formatting\nproject.Publications.SetPageWidth(pub, 8.5)\nproject.Publications.SetPageHeight(pub, 11.0)\nproject.Publications.SetDescription(pub,\n\"Dictionary layout for web publication\")\n\n# Set as default publication\nproject.Publications.SetIsDefault(pub, True)\n\n# Find a publication by name\nmain_pub = project.Publications.Find(\"Main Dictionary\")\nif main_pub:\nwidth = project.Publications.GetPageWidth(main_pub)\nheight = project.Publications.GetPageHeight(main_pub)\nprint(f\"Page size: {width} x {height} inches\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddDivision",
          "signature": "AddDivision(publication_or_hvo, division_name, wsHandle=None)",
          "summary": "Add a division to a publication.",
          "description": "Add a division to a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "division_name",
              "type": "str",
              "default": null,
              "description": "Name of the division (e.g., \"Main Entries\")."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmPossibility: The newly created division object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If publication_or_hvo or division_name is None.",
            "FP_ParameterError: If division_name is empty."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> # Add standard divisions\n            >>> main = project.Publications.AddDivision(pub, \"Main Entries\")\n            >>> minor = project.Publications.AddDivision(pub, \"Minor Entries\")\n            >>> back = project.Publications.AddDivision(pub, \"Back Matter\")\n\n            >>> # Verify divisions were added\n            >>> divisions = project.Publications.GetDivisions(pub)\n            >>> print(f\"Publication has {len(divisions)} divisions\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two publications and return detailed differences.",
          "description": "Compare two publications and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First publication (from source project)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second publication (from target project)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Operations instance for item1's project (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Operations instance for item2's project (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) where differences_dict contains 'properties' dict with changed property details ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(pub1, pub2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, details in diffs['properties'].items():\n            ...         print(f\"{prop}: {details['source']} -> {details['target']}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, wsHandle=None)",
          "summary": "Create a new publication.",
          "description": "Create a new publication.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the publication (e.g., \"Main Dictionary\")."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmPossibility: The newly created publication object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty or publication already exists."
          ],
          "example": "            >>> # Create a simple publication\n            >>> pub = project.Publications.Create(\"Web Dictionary\")\n            >>> print(project.Publications.GetName(pub))\n            Web Dictionary\n\n            >>> # Create with specific writing system\n            >>> pub = project.Publications.Create(\"Diccionario Web\",\n            ...                                    project.WSHandle('es'))\n\n            >>> # Create and configure\n            >>> pub = project.Publications.Create(\"Print Dictionary\")\n            >>> project.Publications.SetPageWidth(pub, 8.5)\n            >>> project.Publications.SetPageHeight(pub, 11.0)\n            >>> project.Publications.SetDescription(pub,\n            ...     \"Standard letter-size print layout\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(publication_or_hvo)",
          "summary": "Delete a publication from the project.",
          "description": "Delete a publication from the project.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If publication_or_hvo is None.",
            "FP_ParameterError: If trying to delete the default publication."
          ],
          "example": "            >>> # Delete a publication\n            >>> pub = project.Publications.Find(\"Old Publication\")\n            >>> if pub and not project.Publications.GetIsDefault(pub):\n            ...     project.Publications.Delete(pub)\n\n            >>> # Delete by HVO\n            >>> project.Publications.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - Deletion is permanent and cannot be undone\n            - Cannot delete the default publication\n            - Any references to this publication will be removed\n            - Lexical entries using this publication may lose formatting info\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a publication, creating a new copy with a new GUID.",
          "description": "Duplicate a publication, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source publication. If False, insert at end of publications list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned divisions/sub-publications. If False (default), only copy simple properties."
            }
          ],
          "returns": "ICmPossibility: The newly created duplicate publication with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Duplicate a publication\n            >>> main_pub = project.Publications.Find(\"Main Dictionary\")\n            >>> dup = project.Publications.Duplicate(main_pub)\n            >>> print(f\"Original: {project.Publications.GetName(main_pub)}\")\n            >>> print(f\"Duplicate: {project.Publications.GetName(dup)}\")\n            Original: Main Dictionary\n            Duplicate: Main Dictionary\n            >>>\n            >>> # Modify the duplicate\n            >>> project.Publications.SetName(dup, \"Web Dictionary\")\n            >>> project.Publications.SetPageWidth(dup, 10.0)\n            >>> project.Publications.SetPageHeight(dup, 12.0)\n            >>>\n            >>> # Deep duplicate (includes all divisions)\n            >>> deep_dup = project.Publications.Duplicate(main_pub, deep=True)\n            >>> divisions = project.Publications.GetDivisions(deep_dup)\n            >>> print(f\"Duplicate has {len(divisions)} divisions\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name)",
          "summary": "Check if a publication with the given name exists.",
          "description": "Check if a publication with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The publication name to check."
            }
          ],
          "returns": "bool: True if publication exists, False otherwise. ",
          "raises": [],
          "example": "            >>> if project.Publications.Exists(\"Main Dictionary\"):\n            ...     print(\"Main Dictionary publication exists\")\n            Main Dictionary publication exists\n\n            >>> if not project.Publications.Exists(\"New Publication\"):\n            ...     pub = project.Publications.Create(\"New Publication\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find a publication by its name.",
          "description": "Find a publication by its name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The publication name to search for (case-sensitive)."
            }
          ],
          "returns": "ICmPossibility or None: The publication object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> # Find by name\n            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> if pub:\n            ...     width = project.Publications.GetPageWidth(pub)\n            ...     height = project.Publications.GetPageHeight(pub)\n            ...     print(f\"Page size: {width}\" x {height}\"\")\n            Page size: 8.5\" x 11.0\"\n\n            >>> # Check if publication exists before using\n            >>> pub = project.Publications.Find(\"Web Dictionary\")\n            >>> if pub:\n            ...     project.Publications.SetPageWidth(pub, 10)\n            ... else:\n            ...     pub = project.Publications.Create(\"Web Dictionary\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(flat=True)",
          "summary": "Get all publications in the project.",
          "description": "Get all publications in the project.\n",
          "parameters": [
            {
              "name": "flat",
              "type": "bool",
              "default": true,
              "description": "If True, returns a flat list of all publications including sub-publications. If False, returns only top-level publications. Defaults to True."
            }
          ],
          "returns": "list: List of ICmPossibility objects representing publications. ",
          "raises": [],
          "example": "            >>> # Get all publications\n            >>> for pub in project.Publications.GetAll():\n            ...     name = project.Publications.GetName(pub)\n            ...     desc = project.Publications.GetDescription(pub)\n            ...     is_default = project.Publications.GetIsDefault(pub)\n            ...     default_str = \" [DEFAULT]\" if is_default else \"\"\n            ...     print(f\"{name}{default_str}: {desc}\")\n            Main Dictionary [DEFAULT]: Primary publication for dictionary\n            Root-based Dictionary: Dictionary organized by roots\n            Thematic Dictionary: Dictionary organized by semantic domains\n\n            >>> # Get only top-level publications\n            >>> top_pubs = project.Publications.GetAll(flat=False)\n            >>> for pub in top_pubs:\n            ...     name = project.Publications.GetName(pub)\n            ...     subs = project.Publications.GetSubPublications(pub)\n            ...     print(f\"{name} ({len(subs)} variants)\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(publication_or_hvo)",
          "summary": "Get the creation date of a publication.",
          "description": "Get the creation date of a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "System.DateTime or None: The creation date/time, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> date = project.Publications.GetDateCreated(pub)\n            >>> if date:\n            ...     print(f\"Created: {date}\")\n            Created: 11/23/2025 10:30:45 AM\n\n            >>> # Sort publications by creation date\n            >>> pubs = project.Publications.GetAll()\n            >>> sorted_pubs = sorted(pubs,\n            ...     key=lambda p: project.Publications.GetDateCreated(p) or DateTime.MinValue)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified(publication_or_hvo)",
          "summary": "Get the last modification date of a publication.",
          "description": "Get the last modification date of a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "System.DateTime or None: The modification date/time, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> modified = project.Publications.GetDateModified(pub)\n            >>> if modified:\n            ...     print(f\"Last modified: {modified}\")\n            Last modified: 11/23/2025 2:15:30 PM\n\n            >>> # Find recently modified publications\n            >>> from System import DateTime\n            >>> one_week_ago = DateTime.Now.AddDays(-7)\n            >>> pubs = project.Publications.GetAll()\n            >>> recent = [p for p in pubs\n            ...     if project.Publications.GetDateModified(p) and\n            ...        project.Publications.GetDateModified(p) > one_week_ago]\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(publication_or_hvo, wsHandle=None)",
          "summary": "Get the description of a publication.",
          "description": "Get the description of a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The publication description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> desc = project.Publications.GetDescription(pub)\n            >>> print(desc)\n            Primary publication format for comprehensive dictionary.\n            Letter-size pages, two-column layout.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDivisions",
          "signature": "GetDivisions(publication_or_hvo)",
          "summary": "Get the publication divisions (e.",
          "description": "Get the publication divisions (e.g., main entries, minor entries).\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "list: List of ICmPossibility objects representing divisions. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> divisions = project.Publications.GetDivisions(pub)\n            >>> for div in divisions:\n            ...     name = ITsString(div.Name.BestAnalysisAlternative).Text\n            ...     print(f\"Division: {name}\")\n            Division: Main Entries\n            Division: Minor Entries\n            Division: Back Matter\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(publication_or_hvo)",
          "summary": "Get the GUID (Globally Unique Identifier) of a publication.",
          "description": "Get the GUID (Globally Unique Identifier) of a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "System.Guid: The publication's GUID. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> guid = project.Publications.GetGuid(pub)\n            >>> print(guid)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\n            >>> # Use GUID to retrieve publication later\n            >>> pub2 = project.Object(guid)\n            >>> print(project.Publications.GetName(pub2))\n            Main Dictionary\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetHeaderFooter",
          "signature": "GetHeaderFooter(publication_or_hvo, wsHandle=None)",
          "summary": "Get the header/footer configuration for a publication.",
          "description": "Get the header/footer configuration for a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: Header/footer configuration text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> header = project.Publications.GetHeaderFooter(pub)\n            >>> print(header)\n            Header: Dictionary title | Page number\n            Footer: Copyright notice\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetIsDefault",
          "signature": "GetIsDefault(publication_or_hvo)",
          "summary": "Check if a publication is the default publication.",
          "description": "Check if a publication is the default publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "bool: True if this is the default publication, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> for pub in project.Publications.GetAll():\n            ...     name = project.Publications.GetName(pub)\n            ...     is_default = project.Publications.GetIsDefault(pub)\n            ...     default_marker = \" [DEFAULT]\" if is_default else \"\"\n            ...     print(f\"{name}{default_marker}\")\n            Main Dictionary [DEFAULT]\n            Root-based Dictionary\n            Thematic Dictionary\n\n            >>> # Find the default publication\n            >>> default_pub = None\n            >>> for pub in project.Publications.GetAll():\n            ...     if project.Publications.GetIsDefault(pub):\n            ...         default_pub = pub\n            ...         break\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetIsLandscape",
          "signature": "GetIsLandscape(publication_or_hvo)",
          "summary": "Check if publication uses landscape orientation.",
          "description": "Check if publication uses landscape orientation.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "bool: True if landscape orientation, False if portrait or not set. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> is_landscape = project.Publications.GetIsLandscape(pub)\n            >>> if is_landscape:\n            ...     print(\"Landscape orientation\")\n            ... else:\n            ...     print(\"Portrait orientation\")\n            Portrait orientation\n\n            >>> # Check orientation and page dimensions\n            >>> width = project.Publications.GetPageWidth(pub)\n            >>> height = project.Publications.GetPageHeight(pub)\n            >>> is_landscape = project.Publications.GetIsLandscape(pub)\n            >>> orientation = \"Landscape\" if is_landscape else \"Portrait\"\n            >>> print(f\"{orientation}: {width}\" x {height}\"\")\n            Portrait: 8.5\" x 11.0\"\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(publication_or_hvo, wsHandle=None)",
          "summary": "Get the name of a publication.",
          "description": "Get the name of a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The publication name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> name = project.Publications.GetName(pub)\n            >>> print(name)\n            Main Dictionary\n\n            >>> # Get name in specific writing system\n            >>> name_es = project.Publications.GetName(pub,\n            ...                                        project.WSHandle('es'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPageHeight",
          "signature": "GetPageHeight(publication_or_hvo)",
          "summary": "Get the page height for a publication.",
          "description": "Get the page height for a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "float or None: Page height in inches, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> height = project.Publications.GetPageHeight(pub)\n            >>> if height:\n            ...     print(f\"Page height: {height} inches\")\n            Page height: 11.0 inches\n\n            >>> # Get both dimensions\n            >>> width = project.Publications.GetPageWidth(pub)\n            >>> height = project.Publications.GetPageHeight(pub)\n            >>> if width and height:\n            ...     print(f\"Page size: {width}\" x {height}\"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPageLayout",
          "signature": "GetPageLayout(publication_or_hvo, wsHandle=None)",
          "summary": "Get the page layout description for a publication.",
          "description": "Get the page layout description for a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: Page layout description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> layout = project.Publications.GetPageLayout(pub)\n            >>> print(layout)\n            Two-column layout with headers and footers\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPageWidth",
          "signature": "GetPageWidth(publication_or_hvo)",
          "summary": "Get the page width for a publication.",
          "description": "Get the page width for a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "float or None: Page width in inches, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> width = project.Publications.GetPageWidth(pub)\n            >>> if width:\n            ...     print(f\"Page width: {width} inches\")\n            Page width: 8.5 inches\n\n            >>> # Check if dimensions are set\n            >>> width = project.Publications.GetPageWidth(pub)\n            >>> height = project.Publications.GetPageHeight(pub)\n            >>> if width and height:\n            ...     aspect = width / height\n            ...     print(f\"Aspect ratio: {aspect:.2f}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParent",
          "signature": "GetParent(publication_or_hvo)",
          "summary": "Get the parent publication of a sub-publication.",
          "description": "Get the parent publication of a sub-publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "ICmPossibility or None: The parent publication, or None if top-level. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Web Dictionary Variant\")\n            >>> parent = project.Publications.GetParent(pub)\n            >>> if parent:\n            ...     parent_name = project.Publications.GetName(parent)\n            ...     print(f\"Parent: {parent_name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubPublications",
          "signature": "GetSubPublications(publication_or_hvo)",
          "summary": "Get all sub-publications of a publication.",
          "description": "Get all sub-publications of a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            }
          ],
          "returns": "list: List of ICmPossibility sub-publication objects. ",
          "raises": [
            "FP_NullParameterError: If publication_or_hvo is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> subs = project.Publications.GetSubPublications(pub)\n            >>> for sub in subs:\n            ...     name = project.Publications.GetName(sub)\n            ...     print(f\"Variant: {name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.\n\nReturns all syncable properties of a publication including MultiString fields.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object (publication)"
            }
          ],
          "returns": "dict: Dictionary of syncable properties ",
          "raises": [],
          "example": "            >>> props = project.Publication.GetSyncableProperties(pub)\n            >>> print(props)\n            {'Name': 'Dictionary', 'Description': '...', 'Abbreviation': 'Dict'}",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(publication_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of a publication.",
          "description": "Set the description of a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If publication_or_hvo or description is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> desc = (\"Primary publication format.\\n\"\n            ...         \"Letter-size pages, two-column layout.\\n\"\n            ...         \"Includes main entries and subentries.\")\n            >>> project.Publications.SetDescription(pub, desc)\n\n            >>> # Clear description\n            >>> project.Publications.SetDescription(pub, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetIsDefault",
          "signature": "SetIsDefault(publication_or_hvo, is_default)",
          "summary": "Set whether a publication is the default publication.",
          "description": "Set whether a publication is the default publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "is_default",
              "type": "bool",
              "default": null,
              "description": "True to make this the default, False otherwise."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If publication_or_hvo or is_default is None."
          ],
          "example": "            >>> # Set a publication as default\n            >>> pub = project.Publications.Find(\"Web Dictionary\")\n            >>> project.Publications.SetIsDefault(pub, True)\n\n            >>> # Remove default status (sets first publication as default)\n            >>> project.Publications.SetIsDefault(pub, False)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(publication_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a publication.",
          "description": "Set the name of a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If publication_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Old Name\")\n            >>> project.Publications.SetName(pub, \"New Name\")\n            >>> print(project.Publications.GetName(pub))\n            New Name\n\n            >>> # Set name in multiple writing systems\n            >>> project.Publications.SetName(pub, \"Dictionary\", \"en\")\n            >>> project.Publications.SetName(pub, \"Diccionario\", \"es\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetPageHeight",
          "signature": "SetPageHeight(publication_or_hvo, height)",
          "summary": "Set the page height for a publication.",
          "description": "Set the page height for a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "height",
              "type": "float",
              "default": null,
              "description": "Page height in inches."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If publication_or_hvo or height is None.",
            "FP_ParameterError: If height is not positive."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> # Set letter-size height\n            >>> project.Publications.SetPageHeight(pub, 11.0)\n\n            >>> # Set A4 height\n            >>> project.Publications.SetPageHeight(pub, 11.69)\n\n            >>> # Set legal-size height\n            >>> project.Publications.SetPageHeight(pub, 14.0)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetPageLayout",
          "signature": "SetPageLayout(publication_or_hvo, layout, wsHandle=None)",
          "summary": "Set the page layout description for a publication.",
          "description": "Set the page layout description for a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "layout",
              "type": "str",
              "default": null,
              "description": "Page layout description."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If publication_or_hvo or layout is None."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> project.Publications.SetPageLayout(pub,\n            ...     \"Two-column layout with running headers\")\n\n            >>> # Clear layout description\n            >>> project.Publications.SetPageLayout(pub, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetPageWidth",
          "signature": "SetPageWidth(publication_or_hvo, width)",
          "summary": "Set the page width for a publication.",
          "description": "Set the page width for a publication.\n",
          "parameters": [
            {
              "name": "publication_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility publication object or its HVO."
            },
            {
              "name": "width",
              "type": "float",
              "default": null,
              "description": "Page width in inches."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If publication_or_hvo or width is None.",
            "FP_ParameterError: If width is not positive."
          ],
          "example": "            >>> pub = project.Publications.Find(\"Main Dictionary\")\n            >>> # Set letter-size width\n            >>> project.Publications.SetPageWidth(pub, 8.5)\n\n            >>> # Set A4 width\n            >>> project.Publications.SetPageWidth(pub, 8.27)\n\n            >>> # Set custom width\n            >>> project.Publications.SetPageWidth(pub, 7.0)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize PublicationOperations with a FLExProject instance.",
          "description": "Initialize PublicationOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "lists",
        "operations"
      ]
    },
    "TranslationTypeOperations": {
      "name": "TranslationTypeOperations",
      "type": "class",
      "namespace": "FlexLibs2.Lists.TranslationTypeOperations",
      "source_file": "Lists/TranslationTypeOperations",
      "category": "lists",
      "summary": "This class provides operations for managing translation types in a\nFieldWorks project.",
      "description": "This class provides operations for managing translation types in a\nFieldWorks project.\n\nTranslation types categorize different kinds of translations such as\nfree translation (idiomatic), literal translation (word-for-word),\nand back translation (reverse translation for verification).\n\nTranslation types are stored as items in the Translation Tags possibility\nlist and can be applied to text translations at both text and segment levels.\n\nThis class should be accessed via FLExProject.TranslationTypes property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all translation types\nfor trans_type in project.TranslationTypes.GetAll():\nname = project.TranslationTypes.GetName(trans_type)\nabbr = project.TranslationTypes.GetAbbreviation(trans_type)\nprint(f\"{name} ({abbr})\")\n\n# Get predefined types\nfree = project.TranslationTypes.GetFreeTranslationType()\nliteral = project.TranslationTypes.GetLiteralTranslationType()\nback = project.TranslationTypes.GetBackTranslationType()\n\n# Create a custom translation type\nidiomatic = project.TranslationTypes.Create(\n\"Idiomatic Translation\", \"Idio\")\n\n# Get writing system for a translation type\nws = project.TranslationTypes.GetAnalysisWS(free)\n\n# Find texts using a specific translation type\ntexts = project.TranslationTypes.GetTextsWithType(free)\nprint(f\"{len(list(texts))} texts use free translation\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two translation types and return detailed differences.",
          "description": "Compare two translation types and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First translation type (from source project)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second translation type (from target project)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Operations instance for item1's project (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Operations instance for item2's project (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) where differences_dict contains 'properties' dict with changed property details ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(type1, type2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, details in diffs['properties'].items():\n            ...         print(f\"{prop}: {details['source']} -> {details['target']}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, abbreviation=None, wsHandle=None)",
          "summary": "Create a new translation type.",
          "description": "Create a new translation type.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the translation type (e.g., \"Idiomatic\")."
            },
            {
              "name": "abbreviation",
              "type": "str, optional",
              "default": null,
              "description": "Short abbreviation (e.g., \"Idio\"). If None, uses the name. Defaults to None."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmPossibility: The newly created translation type object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty, or if a translation type",
            "with this name already exists."
          ],
          "example": "            >>> # Create a custom translation type\n            >>> idiomatic = project.TranslationTypes.Create(\n            ...     \"Idiomatic Translation\", \"Idio\")\n            >>> print(project.TranslationTypes.GetName(idiomatic))\n            Idiomatic Translation\n\n            >>> # Create without abbreviation (uses name)\n            >>> summary = project.TranslationTypes.Create(\"Summary\")\n            >>> print(project.TranslationTypes.GetAbbreviation(summary))\n            Summary\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(type_or_hvo)",
          "summary": "Delete a translation type.",
          "description": "Delete a translation type.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If type_or_hvo is None.",
            "FP_ParameterError: If trying to delete a predefined type",
            "(free, literal, back translation)."
          ],
          "example": "            >>> # Delete a custom type\n            >>> custom = project.TranslationTypes.Find(\"Old Custom Type\")\n            >>> if custom:\n            ...     project.TranslationTypes.Delete(custom)\n\n        Warning:\n            - Cannot delete predefined translation types\n            - Deleting a type that is in use may cause issues\n            - Deletion is permanent and cannot be undone\n            - Check usage with GetTextsWithType() before deleting\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a translation type, creating a new copy with a new GUID.",
          "description": "Duplicate a translation type, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility object or its HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source type. If False, insert at end of translation types list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "Not applicable for translation types (no owned objects). Included for API consistency."
            }
          ],
          "returns": "ICmPossibility: The newly created duplicate translation type with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Duplicate a translation type\n            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> dup = project.TranslationTypes.Duplicate(free)\n            >>> print(f\"Original: {project.TranslationTypes.GetName(free)}\")\n            >>> print(f\"Duplicate: {project.TranslationTypes.GetName(dup)}\")\n            Original: Free translation\n            Duplicate: Free translation\n            >>>\n            >>> # Modify the duplicate\n            >>> project.TranslationTypes.SetName(dup, \"Idiomatic Translation\")\n            >>> project.TranslationTypes.SetAbbreviation(dup, \"idio\")\n            >>>\n            >>> # Set multilingual content\n            >>> fr_ws = project.WSHandle('fr')\n            >>> project.TranslationTypes.SetAnalysisWS(dup, fr_ws,\n            ...     name=\"Traduction idiomatique\",\n            ...     abbreviation=\"idio\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name)",
          "summary": "Check if a translation type with the given name exists.",
          "description": "Check if a translation type with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for (case-insensitive)."
            }
          ],
          "returns": "bool: True if translation type exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> if not project.TranslationTypes.Exists(\"Idiomatic\"):\n            ...     project.TranslationTypes.Create(\"Idiomatic\", \"Idio\")\n\n            >>> # Check for standard types\n            >>> has_free = project.TranslationTypes.Exists(\"Free translation\")\n            >>> print(f\"Has free translation: {has_free}\")\n            Has free translation: True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find a translation type by name.",
          "description": "Find a translation type by name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for (case-insensitive)."
            }
          ],
          "returns": "ICmPossibility or None: The translation type object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> # Find predefined types\n            >>> free = project.TranslationTypes.Find(\"Free translation\")\n            >>> if free:\n            ...     abbr = project.TranslationTypes.GetAbbreviation(free)\n            ...     print(f\"Found: {abbr}\")\n            Found: fr\n\n            >>> # Find custom type\n            >>> custom = project.TranslationTypes.Find(\"Idiomatic Translation\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByWS",
          "signature": "FindByWS(wsHandle)",
          "summary": "Find all translation types that have content in a specific\nwriting system.",
          "description": "Find all translation types that have content in a specific\nwriting system.\n",
          "parameters": [
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Writing system handle to search for."
            }
          ],
          "returns": "ICmPossibility: Each translation type that has name or abbreviation defined in the specified writing system. ",
          "raises": [
            "FP_NullParameterError: If wsHandle is None."
          ],
          "example": "            >>> # Find types with English content\n            >>> en_ws = project.WSHandle('en')\n            >>> for trans_type in project.TranslationTypes.FindByWS(en_ws):\n            ...     name = project.TranslationTypes.GetName(\n            ...         trans_type, en_ws)\n            ...     print(name)\n            Free translation\n            Literal translation\n            Back translation\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAbbreviation",
          "signature": "GetAbbreviation(type_or_hvo, wsHandle=None)",
          "summary": "Get the abbreviation of a translation type.",
          "description": "Get the abbreviation of a translation type.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The translation type abbreviation, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If type_or_hvo is None."
          ],
          "example": "            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> abbr = project.TranslationTypes.GetAbbreviation(free)\n            >>> print(abbr)\n            fr\n\n            >>> literal = project.TranslationTypes.GetLiteralTranslationType()\n            >>> abbr = project.TranslationTypes.GetAbbreviation(literal)\n            >>> print(abbr)\n            lit\n\n        See Also:\n            SetAbbreviation, GetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all translation types in the project.",
          "description": "Get all translation types in the project.\n\nYields all translation types (translation tags) defined in the project,\nincluding predefined types (free, literal, back) and any custom types.\n",
          "parameters": [],
          "returns": "ICmPossibility: Each translation type object. ",
          "raises": [],
          "example": "            >>> for trans_type in project.TranslationTypes.GetAll():\n            ...     name = project.TranslationTypes.GetName(trans_type)\n            ...     abbr = project.TranslationTypes.GetAbbreviation(trans_type)\n            ...     guid = project.TranslationTypes.GetGuid(trans_type)\n            ...     print(f\"{name} ({abbr}): {guid}\")\n            Free translation (fr): eb92e50f-ba96-4d1d-b632-057b5c274132\n            Literal translation (lit): c6e13529-97ed-4a8a-86f9-7b30b3b0b1c0\n            Back translation (bt): d7f713e4-e8cf-11d3-9764-00c04f186933\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnalysisWS",
          "signature": "GetAnalysisWS(type_or_hvo)",
          "summary": "Get the analysis writing systems used by a translation type.",
          "description": "Get the analysis writing systems used by a translation type.\n\nReturns the writing systems in which this translation type has\ntranslations defined.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "list: List of writing system handles (integers) for which this type has content defined. ",
          "raises": [
            "FP_NullParameterError: If type_or_hvo is None."
          ],
          "example": "            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> ws_list = project.TranslationTypes.GetAnalysisWS(free)\n            >>> for ws_handle in ws_list:\n            ...     ws_obj = project.project.ServiceLocator.WritingSystemManager\\\n            ...         .Get(ws_handle)\n            ...     print(f\"Writing system: {ws_obj.Id}\")\n            Writing system: en\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBackTranslationType",
          "signature": "GetBackTranslationType()",
          "summary": "Get the predefined \"Back translation\" type.",
          "description": "Get the predefined \"Back translation\" type.\n\nReturns the standard back translation type that is present in all\nFLEx projects. Back translation is a reverse translation from the\ntarget language back to the source language for verification purposes.\n",
          "parameters": [],
          "returns": "ICmPossibility or None: The back translation type object, or None if not found. ",
          "raises": [],
          "example": "            >>> back = project.TranslationTypes.GetBackTranslationType()\n            >>> if back:\n            ...     name = project.TranslationTypes.GetName(back)\n            ...     abbr = project.TranslationTypes.GetAbbreviation(back)\n            ...     print(f\"{name} ({abbr})\")\n            Back translation (bt)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFreeTranslationType",
          "signature": "GetFreeTranslationType()",
          "summary": "Get the predefined \"Free translation\" type.",
          "description": "Get the predefined \"Free translation\" type.\n\nReturns the standard free translation type that is present in all\nFLEx projects. Free translation represents idiomatic, natural\nlanguage translation.\n",
          "parameters": [],
          "returns": "ICmPossibility or None: The free translation type object, or None if not found. ",
          "raises": [],
          "example": "            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> if free:\n            ...     name = project.TranslationTypes.GetName(free)\n            ...     abbr = project.TranslationTypes.GetAbbreviation(free)\n            ...     print(f\"{name} ({abbr})\")\n            Free translation (fr)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(type_or_hvo)",
          "summary": "Get the GUID (Globally Unique Identifier) of a translation type.",
          "description": "Get the GUID (Globally Unique Identifier) of a translation type.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "System.Guid: The GUID of the translation type. ",
          "raises": [
            "FP_NullParameterError: If type_or_hvo is None."
          ],
          "example": "            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> guid = project.TranslationTypes.GetGuid(free)\n            >>> print(guid)\n            eb92e50f-ba96-4d1d-b632-057b5c274132\n\n            >>> # Check if it's the predefined free translation type\n            >>> expected = System.Guid(\"eb92e50f-ba96-4d1d-b632-057b5c274132\")\n            >>> print(f\"Is free translation: {guid == expected}\")\n            Is free translation: True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLiteralTranslationType",
          "signature": "GetLiteralTranslationType()",
          "summary": "Get the predefined \"Literal translation\" type.",
          "description": "Get the predefined \"Literal translation\" type.\n\nReturns the standard literal translation type that is present in all\nFLEx projects. Literal translation represents word-for-word,\nmorpheme-aligned translation.\n",
          "parameters": [],
          "returns": "ICmPossibility or None: The literal translation type object, or None if not found. ",
          "raises": [],
          "example": "            >>> literal = project.TranslationTypes.GetLiteralTranslationType()\n            >>> if literal:\n            ...     name = project.TranslationTypes.GetName(literal)\n            ...     abbr = project.TranslationTypes.GetAbbreviation(literal)\n            ...     print(f\"{name} ({abbr})\")\n            Literal translation (lit)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(type_or_hvo, wsHandle=None)",
          "summary": "Get the name of a translation type.",
          "description": "Get the name of a translation type.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The translation type name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If type_or_hvo is None."
          ],
          "example": "            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> name = project.TranslationTypes.GetName(free)\n            >>> print(name)\n            Free translation\n\n            >>> # Get name in a specific writing system\n            >>> name_en = project.TranslationTypes.GetName(free,\n            ...     project.WSHandle('en'))\n\n        See Also:\n            SetName, GetAbbreviation",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSegmentsWithType",
          "signature": "GetSegmentsWithType(type_or_hvo)",
          "summary": "Get all segments that use a specific translation type.",
          "description": "Get all segments that use a specific translation type.\n\nSearches through all segments in all texts and returns those that\nreference this translation type in their translations.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "ISegment: Each segment object that uses this translation type. ",
          "raises": [
            "FP_NullParameterError: If type_or_hvo is None."
          ],
          "example": "            >>> literal = project.TranslationTypes.GetLiteralTranslationType()\n            >>> segments = list(project.TranslationTypes.GetSegmentsWithType(\n            ...     literal))\n            >>> print(f\"{len(segments)} segments use literal translation\")\n            458 segments use literal translation\n\n        Warning:\n            - This operation can be very slow for large projects\n            - Scans all paragraphs and segments in the entire project\n            - Consider using GetTextsWithType() for faster overview\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.\n\nReturns all syncable properties of a translation type including MultiString fields.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object (translation type)"
            }
          ],
          "returns": "dict: Dictionary of syncable properties ",
          "raises": [],
          "example": "            >>> props = project.TranslationType.GetSyncableProperties(trans_type)\n            >>> print(props)\n            {'Name': 'Free Translation', 'Abbreviation': 'ft'}",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTextsWithType",
          "signature": "GetTextsWithType(type_or_hvo)",
          "summary": "Get all texts that use a specific translation type.",
          "description": "Get all texts that use a specific translation type.\n\nSearches through all texts in the project and returns those that\nreference this translation type in their translations.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "IText: Each text object that uses this translation type. ",
          "raises": [
            "FP_NullParameterError: If type_or_hvo is None."
          ],
          "example": "            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> texts = list(project.TranslationTypes.GetTextsWithType(free))\n            >>> print(f\"{len(texts)} texts use free translation\")\n            12 texts use free translation\n\n            >>> for text in texts:\n            ...     name = text.Name.BestAnalysisAlternative.Text\n            ...     print(f\"  - {name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsDefault",
          "signature": "IsDefault(type_or_hvo)",
          "summary": "Check if a translation type is one of the predefined default types.",
          "description": "Check if a translation type is one of the predefined default types.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "bool: True if this is a predefined type (free, literal, or back), False if it's a custom type. ",
          "raises": [
            "FP_NullParameterError: If type_or_hvo is None."
          ],
          "example": "            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> is_default = project.TranslationTypes.IsDefault(free)\n            >>> print(f\"Is default: {is_default}\")\n            Is default: True\n\n            >>> custom = project.TranslationTypes.Find(\"Idiomatic\")\n            >>> if custom:\n            ...     is_default = project.TranslationTypes.IsDefault(custom)\n            ...     print(f\"Is default: {is_default}\")\n            Is default: False\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAbbreviation",
          "signature": "SetAbbreviation(type_or_hvo, abbreviation, wsHandle=None)",
          "summary": "Set the abbreviation of a translation type.",
          "description": "Set the abbreviation of a translation type.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "abbreviation",
              "type": "str",
              "default": null,
              "description": "The new abbreviation."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If type_or_hvo or abbreviation is None.",
            "FP_ParameterError: If abbreviation is empty."
          ],
          "example": "            >>> custom = project.TranslationTypes.Find(\"Idiomatic Translation\")\n            >>> if custom:\n            ...     project.TranslationTypes.SetAbbreviation(custom, \"Idio\")\n\n        Warning:\n            - Avoid changing abbreviations for predefined types\n            - Abbreviations should be short and distinctive\n            - Only modify custom types you created\n\n        See Also:\n            GetAbbreviation, SetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAnalysisWS",
          "signature": "SetAnalysisWS(type_or_hvo, wsHandle, name=None, abbreviation=None)",
          "summary": "Set the name and abbreviation for a translation type in a specific\nwriting system.",
          "description": "Set the name and abbreviation for a translation type in a specific\nwriting system.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Writing system handle to set content for."
            },
            {
              "name": "name",
              "type": "str, optional",
              "default": null,
              "description": "Name in the specified writing system. If None, uses existing or empty. Defaults to None."
            },
            {
              "name": "abbreviation",
              "type": "str, optional",
              "default": null,
              "description": "Abbreviation in the specified writing system. If None, uses existing or empty. Defaults to None."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If type_or_hvo or wsHandle is None."
          ],
          "example": "            >>> # Set French translations for a type\n            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> fr_ws = project.WSHandle('fr')\n            >>> project.TranslationTypes.SetAnalysisWS(\n            ...     free, fr_ws,\n            ...     name=\"Traduction libre\",\n            ...     abbreviation=\"tl\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDefault",
          "signature": "SetDefault(type_or_hvo)",
          "summary": "Set a translation type as the default for new translations.",
          "description": "Set a translation type as the default for new translations.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If type_or_hvo is None.",
            "FP_ParameterError: Feature not fully supported."
          ],
          "example": "            >>> # This method is provided for API completeness\n            >>> # but may not have full functionality\n            >>> free = project.TranslationTypes.GetFreeTranslationType()\n            >>> # project.TranslationTypes.SetDefault(free)\n\n        Warning:\n            - This feature may not be fully implemented in FLEx\n            - Translation type defaults are typically context-dependent\n            - Consider this method as a placeholder for future enhancement\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(type_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a translation type.",
          "description": "Set the name of a translation type.\n",
          "parameters": [
            {
              "name": "type_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If type_or_hvo or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> custom = project.TranslationTypes.Find(\"Temp Type\")\n            >>> if custom:\n            ...     project.TranslationTypes.SetName(custom,\n            ...         \"Idiomatic Translation\")\n\n        Warning:\n            - Avoid renaming predefined types (free, literal, back)\n            - Changes affect how the type appears throughout the UI\n            - Only rename custom types you created\n\n        See Also:\n            GetName, SetAbbreviation",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize TranslationTypeOperations with a FLExProject instance.",
          "description": "Initialize TranslationTypeOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ],
      "tags": [
        "lists",
        "operations"
      ]
    },
    "AnthropologyOperations": {
      "name": "AnthropologyOperations",
      "type": "class",
      "namespace": "FlexLibs2.Notebook.AnthropologyOperations",
      "source_file": "Notebook/AnthropologyOperations",
      "category": "notebook",
      "summary": "This class provides operations for managing anthropological and cultural\nitems in a FieldWorks project.",
      "description": "This class provides operations for managing anthropological and cultural\nitems in a FieldWorks project.\n\nAnthropological items (ICmAnthroItem) are used to categorize and organize\ncultural information collected during fieldwork. They support hierarchical\norganization, OCM (Outline of Cultural Materials) codes, and linking to\ntexts and researchers. These items help linguists document cultural context\nalongside linguistic data.\n\nThis class should be accessed via FLExProject.Anthropology property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Create a new anthropology item\nitem = project.Anthropology.Create(\"Marriage Customs\", \"MAR\")\n\n# Set OCM code\nproject.Anthropology.SetAnthroCode(item, \"586\")\n\n# Set description\nproject.Anthropology.SetDescription(item,\n\"Traditional marriage practices and ceremonies\")\n\n# Create hierarchical structure\nsubitem = project.Anthropology.CreateSubitem(item,\n\"Wedding Ceremony\", \"WED\")\n\n# Link to texts\ntext = project.Texts.Find(\"Wedding Story 1\")\nif text:\nproject.Anthropology.AddText(item, text)\n\n# Get all items linked to a specific text\nfor anthro_item in project.Anthropology.GetItemsForText(text):\nname = project.Anthropology.GetName(anthro_item)\ncode = project.Anthropology.GetAnthroCode(anthro_item)\nprint(f\"{name} ({code})\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddResearcher",
          "signature": "AddResearcher(item_or_hvo, person)",
          "summary": "Link a researcher (person) to an anthropology item.",
          "description": "Link a researcher (person) to an anthropology item.\n\nCreates a link between the item and a person object, typically used\nto track which researchers are responsible for documenting particular\ncultural items.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "person",
              "type": "",
              "default": null,
              "description": "The ICmPerson object to link."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or person is None.",
            "FP_ParameterError: If the item or person is invalid, or if the",
            "person is already linked to this item."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>>\n            >>> # Get or create a person\n            >>> # (assuming people are in project.lp.PeopleOA)\n            >>> person = project.lp.PeopleOA.PossibilitiesOS[0]\n            >>>\n            >>> # Link person to item\n            >>> project.Anthropology.AddResearcher(item, person)\n            >>>\n            >>> # Verify link\n            >>> researchers = project.Anthropology.GetResearchers(item)\n            >>> print(f\"Item has {len(researchers)} researcher(s)\")\n            Item has 1 researcher(s)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddText",
          "signature": "AddText(item_or_hvo, text)",
          "summary": "Link a text to an anthropology item.",
          "description": "Link a text to an anthropology item.\n\nCreates a bidirectional link between the item and the text. The same\ntext can be linked to multiple anthropology items.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "text",
              "type": "",
              "default": null,
              "description": "The IText object to link."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or text is None.",
            "FP_ParameterError: If the item or text is invalid, or if the",
            "text is already linked to this item."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> text = project.Texts.Find(\"Wedding Story 1\")\n            >>>\n            >>> # Link text to item\n            >>> project.Anthropology.AddText(item, text)\n            >>>\n            >>> # Verify link\n            >>> texts = project.Anthropology.GetTexts(item)\n            >>> print(f\"Item now has {len(texts)} text(s)\")\n            Item now has 1 text(s)\n\n            >>> # Link same text to multiple items\n            >>> wedding = project.Anthropology.Find(\"Wedding Ceremony\")\n            >>> project.Anthropology.AddText(wedding, text)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two anthropology items and return detailed differences.",
          "description": "Compare two anthropology items and return detailed differences.",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null
            },
            {
              "name": "item2",
              "type": "",
              "default": null
            },
            {
              "name": "ops1",
              "type": "",
              "default": null
            },
            {
              "name": "ops2",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, abbreviation=None, anthro_code=None)",
          "summary": "Create a new anthropology item.",
          "description": "Create a new anthropology item.\n\nCreates a new top-level ICmAnthroItem in the project's anthropology list.\nUse CreateSubitem() to create hierarchical items.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the item (e.g., \"Marriage Customs\")."
            },
            {
              "name": "abbreviation",
              "type": "str, optional",
              "default": null,
              "description": "Short abbreviation (e.g., \"MAR\"). If None, no abbreviation is set. Defaults to None."
            },
            {
              "name": "anthro_code",
              "type": "str, optional",
              "default": null,
              "description": "OCM (Outline of Cultural Materials) code (e.g., \"586\" for marriage). If None, no code is set. Defaults to None."
            }
          ],
          "returns": "ICmAnthroItem: The newly created anthropology item object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None or empty.",
            "FP_ParameterError: If an item with this name already exists."
          ],
          "example": "            >>> # Create a simple item\n            >>> item = project.Anthropology.Create(\"Marriage Customs\")\n            >>> print(project.Anthropology.GetName(item))\n            Marriage Customs\n\n            >>> # Create with abbreviation and OCM code\n            >>> item = project.Anthropology.Create(\n            ...     \"Marriage Customs\",\n            ...     abbreviation=\"MAR\",\n            ...     anthro_code=\"586\"\n            ... )\n            >>> print(project.Anthropology.GetAnthroCode(item))\n            586\n\n            >>> # Create multiple items\n            >>> kinship = project.Anthropology.Create(\"Kinship\", \"KIN\", \"600\")\n            >>> religion = project.Anthropology.Create(\"Religion\", \"REL\", \"770\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateSubitem",
          "signature": "CreateSubitem(parent_item, name, abbreviation=None, anthro_code=None)",
          "summary": "Create a new anthropology item as a child of an existing item.",
          "description": "Create a new anthropology item as a child of an existing item.\n\nCreates a hierarchical relationship where the new item is a subcategory\nor more specific aspect of the parent item.\n",
          "parameters": [
            {
              "name": "parent_item",
              "type": "",
              "default": null,
              "description": "The parent ICmAnthroItem object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the subitem (e.g., \"Wedding Ceremony\")."
            },
            {
              "name": "abbreviation",
              "type": "str, optional",
              "default": null,
              "description": "Short abbreviation. Defaults to None."
            },
            {
              "name": "anthro_code",
              "type": "str, optional",
              "default": null,
              "description": "OCM code for the subitem. Defaults to None."
            }
          ],
          "returns": "ICmAnthroItem: The newly created subitem object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If parent_item or name is None/empty.",
            "FP_ParameterError: If parent_item is invalid."
          ],
          "example": "            >>> # Create parent item\n            >>> marriage = project.Anthropology.Create(\"Marriage Customs\", \"MAR\", \"586\")\n            >>>\n            >>> # Create subitems\n            >>> wedding = project.Anthropology.CreateSubitem(\n            ...     marriage, \"Wedding Ceremony\", \"WED\", \"586.1\"\n            ... )\n            >>> gifts = project.Anthropology.CreateSubitem(\n            ...     marriage, \"Marriage Gifts\", \"GIFT\", \"586.2\"\n            ... )\n            >>>\n            >>> # Verify hierarchy\n            >>> parent = project.Anthropology.GetParent(wedding)\n            >>> print(project.Anthropology.GetName(parent))\n            Marriage Customs\n            >>>\n            >>> # Get all subitems\n            >>> for sub in project.Anthropology.GetSubitems(marriage):\n            ...     print(project.Anthropology.GetName(sub))\n            Wedding Ceremony\n            Marriage Gifts\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(item_or_hvo)",
          "summary": "Delete an anthropology item.",
          "description": "Delete an anthropology item.\n\nRemoves the item from the project. If the item has subitems, they\nwill also be deleted. Removes all links to texts and researchers.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> # Delete a specific item\n            >>> item = project.Anthropology.Find(\"Obsolete Item\")\n            >>> if item:\n            ...     project.Anthropology.Delete(item)\n\n            >>> # Delete by HVO\n            >>> project.Anthropology.Delete(item_hvo)\n\n        Warning:\n            - Deleting an item also deletes all its subitems\n            - This operation cannot be undone (unless using UndoActionSequence)\n            - Text and researcher links are removed, but the texts and\n              researchers themselves are not deleted\n\n        See Also:\n            Create, CreateSubitem, Exists",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate an anthropology item, creating a new copy with a new GUID.",
          "description": "Duplicate an anthropology item, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source item. If False, insert at end of parent's subitems list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (subitems). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "ICmAnthroItem: The newly created duplicate item with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> # Shallow duplicate (no subitems)\n            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> dup = project.Anthropology.Duplicate(item)\n            >>> print(f\"Original: {project.Anthropology.GetGuid(item)}\")\n            >>> print(f\"Duplicate: {project.Anthropology.GetGuid(dup)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n\n            >>> # Deep duplicate (includes all subitems)\n            >>> deep_dup = project.Anthropology.Duplicate(item, deep=True)\n            >>> print(f\"Subitems: {len(project.Anthropology.GetSubitems(deep_dup))}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name)",
          "summary": "Check if an anthropology item with the given name exists.",
          "description": "Check if an anthropology item with the given name exists.\n\nPerforms a case-sensitive comparison of item names in the default\nanalysis writing system.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the item to check."
            }
          ],
          "returns": "bool: True if an item with the given name exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None or empty."
          ],
          "example": "            >>> if project.Anthropology.Exists(\"Marriage Customs\"):\n            ...     print(\"Item already exists\")\n            ... else:\n            ...     item = project.Anthropology.Create(\"Marriage Customs\")\n\n            >>> # Case-sensitive check\n            >>> print(project.Anthropology.Exists(\"marriage customs\"))\n            False\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find an anthropology item by its name.",
          "description": "Find an anthropology item by its name.\n\nSearches through all anthropology items (including subitems) and\nreturns the first item with a matching name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for."
            }
          ],
          "returns": "ICmAnthroItem or None: The item object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> # Find by name\n            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> if item:\n            ...     code = project.Anthropology.GetAnthroCode(item)\n            ...     print(f\"Found item with code: {code}\")\n            Found item with code: 586\n\n            >>> # Handle not found\n            >>> item = project.Anthropology.Find(\"Nonexistent Item\")\n            >>> if not item:\n            ...     print(\"Item not found\")\n            Item not found\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByCategory",
          "signature": "FindByCategory(category)",
          "summary": "Find all anthropology items in a specific category.",
          "description": "Find all anthropology items in a specific category.\n\nSearches for items that have been assigned to a particular category\npossibility.\n",
          "parameters": [
            {
              "name": "category",
              "type": "",
              "default": null,
              "description": "ICmPossibility object representing the category."
            }
          ],
          "returns": "list: List of ICmAnthroItem objects in that category. ",
          "raises": [
            "FP_NullParameterError: If category is None."
          ],
          "example": "            >>> # Get a category from the categories list\n            >>> categories = project.lp.AnthroListOA\n            >>> if categories and categories.PossibilitiesOS.Count > 0:\n            ...     category = categories.PossibilitiesOS[0]\n            ...     items = project.Anthropology.FindByCategory(category)\n            ...     for item in items:\n            ...         name = project.Anthropology.GetName(item)\n            ...         print(f\"Item: {name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByCode",
          "signature": "FindByCode(anthro_code)",
          "summary": "Find an anthropology item by its OCM code.",
          "description": "Find an anthropology item by its OCM code.\n\nSearches through all anthropology items and returns the first item\nwith a matching AnthroCode (Outline of Cultural Materials code).\n",
          "parameters": [
            {
              "name": "anthro_code",
              "type": "str",
              "default": null,
              "description": "The OCM code to search for (e.g., \"586\")."
            }
          ],
          "returns": "ICmAnthroItem or None: The item object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If anthro_code is None."
          ],
          "example": "            >>> # Find by OCM code\n            >>> item = project.Anthropology.FindByCode(\"586\")\n            >>> if item:\n            ...     name = project.Anthropology.GetName(item)\n            ...     print(f\"Code 586 is: {name}\")\n            Code 586 is: Marriage Customs\n\n            >>> # Find hierarchical codes\n            >>> item = project.Anthropology.FindByCode(\"586.1\")\n            >>> if item:\n            ...     name = project.Anthropology.GetName(item)\n            ...     parent = project.Anthropology.GetParent(item)\n            ...     parent_name = project.Anthropology.GetName(parent)\n            ...     print(f\"{name} is subcategory of {parent_name}\")\n            Wedding Ceremony is subcategory of Marriage Customs\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAbbreviation",
          "signature": "GetAbbreviation(item_or_hvo, wsHandle=None)",
          "summary": "Get the abbreviation of an anthropology item.",
          "description": "Get the abbreviation of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The abbreviation, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> abbr = project.Anthropology.GetAbbreviation(item)\n            >>> print(abbr)\n            MAR\n\n            >>> # Use in display\n            >>> for item in project.Anthropology.GetAll():\n            ...     name = project.Anthropology.GetName(item)\n            ...     abbr = project.Anthropology.GetAbbreviation(item)\n            ...     if abbr:\n            ...         print(f\"{abbr}: {name}\")\n            ...     else:\n            ...         print(name)\n            MAR: Marriage Customs\n            WED: Wedding Ceremony\n            KIN: Kinship\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(flat=True)",
          "summary": "Get all anthropology items in the project.",
          "description": "Get all anthropology items in the project.\n",
          "parameters": [
            {
              "name": "flat",
              "type": "bool",
              "default": true,
              "description": "If True, returns a flat list of all items including subitems. If False, returns only top-level items (use GetSubitems to navigate hierarchy). Defaults to True."
            }
          ],
          "returns": "list: List of ICmAnthroItem objects. ",
          "raises": [],
          "example": "            >>> # Get all items in a flat list\n            >>> for item in project.Anthropology.GetAll(flat=True):\n            ...     name = project.Anthropology.GetName(item)\n            ...     code = project.Anthropology.GetAnthroCode(item)\n            ...     print(f\"{name} - {code}\")\n            Marriage Customs - 586\n            Wedding Ceremony - 586.1\n            Divorce - 587\n            ...\n\n            >>> # Get only top-level items\n            >>> top_level = project.Anthropology.GetAll(flat=False)\n            >>> for item in top_level:\n            ...     name = project.Anthropology.GetName(item)\n            ...     print(f\"Parent: {name}\")\n            ...     for subitem in project.Anthropology.GetSubitems(item):\n            ...         sub_name = project.Anthropology.GetName(subitem)\n            ...         print(f\"  - {sub_name}\")\n            Parent: Marriage Customs\n              - Wedding Ceremony\n              - Marriage Gifts\n            ...\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnthroCode",
          "signature": "GetAnthroCode(item_or_hvo)",
          "summary": "Get the OCM (Outline of Cultural Materials) code of an item.",
          "description": "Get the OCM (Outline of Cultural Materials) code of an item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "str: The OCM code, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> code = project.Anthropology.GetAnthroCode(item)\n            >>> print(code)\n            586\n\n            >>> # Display all items with their codes\n            >>> for item in project.Anthropology.GetAll():\n            ...     name = project.Anthropology.GetName(item)\n            ...     code = project.Anthropology.GetAnthroCode(item)\n            ...     if code:\n            ...         print(f\"{code}: {name}\")\n            ...     else:\n            ...         print(f\"No code: {name}\")\n            586: Marriage Customs\n            586.1: Wedding Ceremony\n            587: Divorce\n            No code: Custom Category\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCategory",
          "signature": "GetCategory(item_or_hvo)",
          "summary": "Get the category of an anthropology item.",
          "description": "Get the category of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "ICmPossibility or None: The category object if set, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> category = project.Anthropology.GetCategory(item)\n            >>> if category:\n            ...     cat_name = category.Name.BestAnalysisAlternative.Text\n            ...     print(f\"Category: {cat_name}\")\n            ... else:\n            ...     print(\"No category assigned\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(item_or_hvo)",
          "summary": "Get the creation date of an anthropology item.",
          "description": "Get the creation date of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "System.DateTime or None: The creation date, or None if not available. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> date = project.Anthropology.GetDateCreated(item)\n            >>> if date:\n            ...     print(f\"Created: {date}\")\n            Created: 2024-01-15 10:30:00\n\n            >>> # Find recently created items\n            >>> from System import DateTime, TimeSpan\n            >>> week_ago = DateTime.Now - TimeSpan.FromDays(7)\n            >>> recent = []\n            >>> for item in project.Anthropology.GetAll():\n            ...     date = project.Anthropology.GetDateCreated(item)\n            ...     if date and date > week_ago:\n            ...         name = project.Anthropology.GetName(item)\n            ...         recent.append(name)\n            >>> print(f\"Items created in last week: {recent}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified(item_or_hvo)",
          "summary": "Get the last modification date of an anthropology item.",
          "description": "Get the last modification date of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "System.DateTime or None: The modification date, or None if not available. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> date = project.Anthropology.GetDateModified(item)\n            >>> if date:\n            ...     print(f\"Last modified: {date}\")\n            Last modified: 2024-03-20 14:45:00\n\n            >>> # Find recently modified items\n            >>> from System import DateTime, TimeSpan\n            >>> day_ago = DateTime.Now - TimeSpan.FromDays(1)\n            >>> modified = []\n            >>> for item in project.Anthropology.GetAll():\n            ...     date = project.Anthropology.GetDateModified(item)\n            ...     if date and date > day_ago:\n            ...         name = project.Anthropology.GetName(item)\n            ...         modified.append(name)\n            >>> print(f\"Modified today: {modified}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(item_or_hvo, wsHandle=None)",
          "summary": "Get the description of an anthropology item.",
          "description": "Get the description of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> desc = project.Anthropology.GetDescription(item)\n            >>> print(desc)\n            Traditional marriage practices, including courtship,\n            betrothal, wedding ceremonies, and gift exchanges.\n\n            >>> # Display full item information\n            >>> name = project.Anthropology.GetName(item)\n            >>> code = project.Anthropology.GetAnthroCode(item)\n            >>> desc = project.Anthropology.GetDescription(item)\n            >>> print(f\"{name} ({code})\")\n            >>> print(f\"Description: {desc}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(item_or_hvo)",
          "summary": "Get the GUID (Globally Unique Identifier) of an anthropology item.",
          "description": "Get the GUID (Globally Unique Identifier) of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "System.Guid: The GUID of the item. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> guid = project.Anthropology.GetGuid(item)\n            >>> print(f\"GUID: {guid}\")\n            GUID: 12345678-1234-1234-1234-123456789abc\n\n            >>> # Use GUID for stable cross-references\n            >>> guid_str = str(guid)\n            >>> # Store guid_str in external database...\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetItemsForText",
          "signature": "GetItemsForText(text)",
          "summary": "Get all anthropology items linked to a specific text.",
          "description": "Get all anthropology items linked to a specific text.\n\nSearches through all anthropology items to find which ones are\nlinked to the specified text.\n",
          "parameters": [
            {
              "name": "text",
              "type": "",
              "default": null,
              "description": "The IText object to search for."
            }
          ],
          "returns": "list: List of ICmAnthroItem objects linked to this text. ",
          "raises": [
            "FP_NullParameterError: If text is None."
          ],
          "example": "            >>> text = project.Texts.Find(\"Wedding Story 1\")\n            >>> items = project.Anthropology.GetItemsForText(text)\n            >>> print(f\"Text is linked to {len(items)} item(s)\")\n            Text is linked to 2 item(s)\n            >>>\n            >>> for item in items:\n            ...     name = project.Anthropology.GetName(item)\n            ...     code = project.Anthropology.GetAnthroCode(item)\n            ...     print(f\"  {code}: {name}\")\n              586: Marriage Customs\n              586.1: Wedding Ceremony\n\n            >>> # Find texts not linked to any items\n            >>> for text in project.Texts.GetAll():\n            ...     items = project.Anthropology.GetItemsForText(text)\n            ...     if not items:\n            ...         name = text.Name.BestAnalysisAlternative.Text\n            ...         print(f\"Unlinked text: {name}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(item_or_hvo, wsHandle=None)",
          "summary": "Get the name of an anthropology item.",
          "description": "Get the name of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The item name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> name = project.Anthropology.GetName(item)\n            >>> print(name)\n            Marriage Customs\n\n            >>> # Get name in a specific writing system\n            >>> name_fr = project.Anthropology.GetName(item,\n            ...                                         project.WSHandle('fr'))\n            >>> print(name_fr)\n            Coutumes matrimoniales\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParent",
          "signature": "GetParent(item_or_hvo)",
          "summary": "Get the parent item of an anthropology item.",
          "description": "Get the parent item of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "ICmAnthroItem or None: The parent item if this is a subitem, None if this is a top-level item. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> # Get parent of a subitem\n            >>> wedding = project.Anthropology.Find(\"Wedding Ceremony\")\n            >>> parent = project.Anthropology.GetParent(wedding)\n            >>> if parent:\n            ...     parent_name = project.Anthropology.GetName(parent)\n            ...     print(f\"Parent: {parent_name}\")\n            ... else:\n            ...     print(\"This is a top-level item\")\n            Parent: Marriage Customs\n\n            >>> # Build breadcrumb trail\n            >>> def get_path(item):\n            ...     path = []\n            ...     current = item\n            ...     while current:\n            ...         name = project.Anthropology.GetName(current)\n            ...         path.insert(0, name)\n            ...         current = project.Anthropology.GetParent(current)\n            ...     return \" > \".join(path)\n            >>> print(get_path(wedding))\n            Marriage Customs > Wedding Ceremony\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetResearchers",
          "signature": "GetResearchers(item_or_hvo)",
          "summary": "Get all researchers (people) linked to an anthropology item.",
          "description": "Get all researchers (people) linked to an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "list: List of ICmPerson objects linked to this item. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> researchers = project.Anthropology.GetResearchers(item)\n            >>> for person in researchers:\n            ...     name = person.Name.BestAnalysisAlternative.Text\n            ...     print(f\"Researcher: {name}\")\n            Researcher: John Smith\n            Researcher: Jane Doe\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubitems",
          "signature": "GetSubitems(item_or_hvo)",
          "summary": "Get all direct subitems of an anthropology item.",
          "description": "Get all direct subitems of an anthropology item.\n\nReturns only immediate children, not all descendants. For a full\nhierarchical view, use GetAll(flat=True).\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "list: List of ICmAnthroItem objects that are direct children. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> # Get subitems of a parent\n            >>> marriage = project.Anthropology.Find(\"Marriage Customs\")\n            >>> subitems = project.Anthropology.GetSubitems(marriage)\n            >>> for sub in subitems:\n            ...     name = project.Anthropology.GetName(sub)\n            ...     print(f\"  - {name}\")\n              - Wedding Ceremony\n              - Marriage Gifts\n              - Bride Price\n\n            >>> # Check if item has subitems\n            >>> if project.Anthropology.GetSubitems(marriage):\n            ...     print(\"Has subitems\")\n            ... else:\n            ...     print(\"No subitems\")\n            Has subitems\n\n            >>> # Build hierarchical display\n            >>> def display_hierarchy(item, indent=0):\n            ...     name = project.Anthropology.GetName(item)\n            ...     print(\"  \" * indent + name)\n            ...     for sub in project.Anthropology.GetSubitems(item):\n            ...         display_hierarchy(sub, indent + 1)\n            >>> for top in project.Anthropology.GetAll(flat=False):\n            ...     display_hierarchy(top)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTextCount",
          "signature": "GetTextCount(item_or_hvo)",
          "summary": "Get the count of texts linked to an anthropology item.",
          "description": "Get the count of texts linked to an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "int: The number of texts linked to this item. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> count = project.Anthropology.GetTextCount(item)\n            >>> print(f\"Item has {count} linked text(s)\")\n            Item has 3 linked text(s)\n\n            >>> # Find items with linked texts\n            >>> for item in project.Anthropology.GetAll():\n            ...     count = project.Anthropology.GetTextCount(item)\n            ...     if count > 0:\n            ...         name = project.Anthropology.GetName(item)\n            ...         print(f\"{name}: {count} text(s)\")\n            Marriage Customs: 3 text(s)\n            Kinship: 5 text(s)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTexts",
          "signature": "GetTexts(item_or_hvo)",
          "summary": "Get all texts linked to an anthropology item.",
          "description": "Get all texts linked to an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            }
          ],
          "returns": "list: List of IText objects linked to this item. ",
          "raises": [
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> texts = project.Anthropology.GetTexts(item)\n            >>> print(f\"Found {len(texts)} texts\")\n            Found 3 texts\n            >>>\n            >>> for text in texts:\n            ...     name = text.Name.BestAnalysisAlternative.Text\n            ...     print(f\"  - {name}\")\n              - Wedding Story 1\n              - Wedding Story 2\n              - Marriage Interview\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveResearcher",
          "signature": "RemoveResearcher(item_or_hvo, person)",
          "summary": "Remove a researcher link from an anthropology item.",
          "description": "Remove a researcher link from an anthropology item.\n\nRemoves the link between the item and the person. The person object\nitself is not deleted, only the link.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "person",
              "type": "",
              "default": null,
              "description": "The ICmPerson object to unlink."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or person is None.",
            "FP_ParameterError: If the item or person is invalid, or if the",
            "person is not linked to this item."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> person = project.lp.PeopleOA.PossibilitiesOS[0]\n            >>>\n            >>> # Remove person link\n            >>> project.Anthropology.RemoveResearcher(item, person)\n            >>>\n            >>> # Verify removal\n            >>> researchers = project.Anthropology.GetResearchers(item)\n            >>> print(f\"Item has {len(researchers)} researcher(s)\")\n            Item has 0 researcher(s)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveText",
          "signature": "RemoveText(item_or_hvo, text)",
          "summary": "Remove a text link from an anthropology item.",
          "description": "Remove a text link from an anthropology item.\n\nRemoves the bidirectional link between the item and the text. The\ntext itself is not deleted, only the link.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "text",
              "type": "",
              "default": null,
              "description": "The IText object to unlink."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or text is None.",
            "FP_ParameterError: If the item or text is invalid, or if the",
            "text is not linked to this item."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> text = project.Texts.Find(\"Wedding Story 1\")\n            >>>\n            >>> # Remove text link\n            >>> project.Anthropology.RemoveText(item, text)\n            >>>\n            >>> # Verify removal\n            >>> texts = project.Anthropology.GetTexts(item)\n            >>> print(f\"Item now has {len(texts)} text(s)\")\n            Item now has 0 text(s)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAbbreviation",
          "signature": "SetAbbreviation(item_or_hvo, abbreviation, wsHandle=None)",
          "summary": "Set the abbreviation of an anthropology item.",
          "description": "Set the abbreviation of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "abbreviation",
              "type": "str",
              "default": null,
              "description": "The new abbreviation."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or abbreviation is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> project.Anthropology.SetAbbreviation(item, \"MAR\")\n            >>> print(project.Anthropology.GetAbbreviation(item))\n            MAR\n\n            >>> # Clear abbreviation\n            >>> project.Anthropology.SetAbbreviation(item, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAnthroCode",
          "signature": "SetAnthroCode(item_or_hvo, anthro_code)",
          "summary": "Set the OCM (Outline of Cultural Materials) code of an item.",
          "description": "Set the OCM (Outline of Cultural Materials) code of an item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "anthro_code",
              "type": "str",
              "default": null,
              "description": "The OCM code to set."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or anthro_code is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> project.Anthropology.SetAnthroCode(item, \"586\")\n            >>> print(project.Anthropology.GetAnthroCode(item))\n            586\n\n            >>> # Set hierarchical codes\n            >>> subitem = project.Anthropology.Find(\"Wedding Ceremony\")\n            >>> project.Anthropology.SetAnthroCode(subitem, \"586.1\")\n\n            >>> # Clear code\n            >>> project.Anthropology.SetAnthroCode(item, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetCategory",
          "signature": "SetCategory(item_or_hvo, category)",
          "summary": "Set the category of an anthropology item.",
          "description": "Set the category of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "category",
              "type": "",
              "default": null,
              "description": "ICmPossibility object or None to clear."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the item or category is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>>\n            >>> # Set category from a possibility list\n            >>> # (assuming categories are defined in a list)\n            >>> category = project.lp.AnthroListOA.PossibilitiesOS[0]\n            >>> project.Anthropology.SetCategory(item, category)\n            >>>\n            >>> # Clear category\n            >>> project.Anthropology.SetCategory(item, None)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(item_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of an anthropology item.",
          "description": "Set the description of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or description is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage Customs\")\n            >>> project.Anthropology.SetDescription(item,\n            ...     \"Traditional marriage practices, including courtship, \"\n            ...     \"betrothal, wedding ceremonies, and gift exchanges.\"\n            ... )\n\n            >>> # Set in multiple languages\n            >>> project.Anthropology.SetDescription(item,\n            ...     \"Traditional marriage practices...\", \"en\")\n            >>> project.Anthropology.SetDescription(item,\n            ...     \"Pratiques matrimoniales traditionnelles...\",\n            ...     project.WSHandle('fr'))\n\n            >>> # Clear description\n            >>> project.Anthropology.SetDescription(item, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(item_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of an anthropology item.",
          "description": "Set the name of an anthropology item.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnthroItem object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo or name is None.",
            "FP_ParameterError: If the item is invalid."
          ],
          "example": "            >>> item = project.Anthropology.Find(\"Marriage\")\n            >>> project.Anthropology.SetName(item, \"Marriage Customs\")\n            >>> print(project.Anthropology.GetName(item))\n            Marriage Customs\n\n            >>> # Set in multiple writing systems\n            >>> project.Anthropology.SetName(item, \"Marriage Customs\", \"en\")\n            >>> project.Anthropology.SetName(item, \"Coutumes matrimoniales\",\n            ...                               project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize AnthropologyOperations with a FLExProject instance.",
          "description": "Initialize AnthropologyOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ],
      "tags": [
        "notebook",
        "operations"
      ]
    },
    "DataNotebookOperations": {
      "name": "DataNotebookOperations",
      "type": "class",
      "namespace": "FlexLibs2.Notebook.DataNotebookOperations",
      "source_file": "Notebook/DataNotebookOperations",
      "category": "notebook",
      "summary": "This class provides operations for managing research notebook records in a\nFieldWorks project.",
      "description": "This class provides operations for managing research notebook records in a\nFieldWorks project.\n\nResearch notebook records (IRnGenericRec) are used to document field research,\nobservations, interviews, and other data collection activities. They support\nhierarchical organization, linking to texts and participants, media attachments,\ncategorization by record type, and status tracking.\n\nNotebook records are essential for documenting the research process and\nmaintaining a structured record of linguistic fieldwork activities.\n\nThis class should be accessed via FLExProject.DataNotebook property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Create a new notebook record\nrecord = project.DataNotebook.Create(\n\"Interview with Speaker A\",\n\"Detailed notes from interview about kinship terminology\"\n)\n\n# Set record type\nrecord_types = project.DataNotebook.GetAllRecordTypes()\nif record_types:\nproject.DataNotebook.SetRecordType(record, record_types[0])\n\n# Set date of event\nproject.DataNotebook.SetDateOfEvent(record, \"2024-01-15\")\n\n# Add researchers\nresearcher = project.Person.Find(\"John Doe\")\nif researcher:\nproject.DataNotebook.AddResearcher(record, researcher)\n\n# Link to text\ntext = project.Texts.Find(\"Interview 1\")\nif text:\nproject.DataNotebook.LinkToText(record, text)\n\n# Add media file\nmedia = project.Media.Find(\"interview_audio.wav\")\nif media:\nproject.DataNotebook.AddMediaFile(record, media)\n\n# Set status\nproject.DataNotebook.SetStatus(record, \"Reviewed\")\n\n# Create hierarchical structure\nsubrecord = project.DataNotebook.CreateSubRecord(\nrecord,\n\"Analysis Notes\",\n\"Follow-up analysis of terminology patterns\"\n)\n\n# Query records\nrecent = project.DataNotebook.FindByDate(\"2024-01-01\", \"2024-12-31\")\nfor rec in recent:\ntitle = project.DataNotebook.GetTitle(rec)\ndate = project.DataNotebook.GetDateOfEvent(rec)\nprint(f\"{title} - {date}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddLocation",
          "signature": "AddLocation(record_or_hvo, location)",
          "summary": "Add a location to a notebook record.",
          "description": "Add a location to a notebook record.\n\nAssociates a geographic location with the notebook record, indicating\nwhere the documented event or data collection took place.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "location",
              "type": "",
              "default": null,
              "description": "The location object (ICmLocation) to add."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or location is None.",
            "FP_ParameterError: If the record or location doesn't exist."
          ],
          "example": "            >>> # Add single location\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> if location:\n            ...     project.DataNotebook.AddLocation(record, location)\n\n            >>> # Add multiple locations\n            >>> locations = [\"Village A\", \"Village B\", \"Recording Site\"]\n            >>> for name in locations:\n            ...     loc = project.Location.Find(name)\n            ...     if loc:\n            ...         project.DataNotebook.AddLocation(record, loc)\n\n            >>> # Create and add new location\n            >>> new_location = project.Location.Create(\"New Site\", \"en\")\n            >>> project.Location.SetCoordinates(new_location, -1.23, -70.45)\n            >>> project.DataNotebook.AddLocation(record, new_location)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddMediaFile",
          "signature": "AddMediaFile(record_or_hvo, media_file)",
          "summary": "Add a media file to a notebook record.",
          "description": "Add a media file to a notebook record.\n\nAttaches a media file (audio, video, or image) to the notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "media_file",
              "type": "",
              "default": null,
              "description": "The media file object (ICmFile) to attach."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or media_file is None.",
            "FP_ParameterError: If the record or media file doesn't exist."
          ],
          "example": "            >>> # Add existing media file\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> media = project.Media.Find(\"interview1.wav\")\n            >>> if media:\n            ...     project.DataNotebook.AddMediaFile(record, media)\n\n            >>> # Create and add new media file\n            >>> new_media = project.Media.Create(\"/path/to/recording.wav\")\n            >>> project.DataNotebook.AddMediaFile(record, new_media)\n\n            >>> # Add multiple media files\n            >>> media_files = [\"audio.wav\", \"photo1.jpg\", \"photo2.jpg\"]\n            >>> for filename in media_files:\n            ...     media = project.Media.Find(filename)\n            ...     if media:\n            ...         project.DataNotebook.AddMediaFile(record, media)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddParticipant",
          "signature": "AddParticipant(record_or_hvo, person)",
          "summary": "Add a participant to a notebook record.",
          "description": "Add a participant to a notebook record.\n\nAssociates a person (consultant/speaker/informant) with the notebook\nrecord as a participant in the documented event.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "person",
              "type": "",
              "default": null,
              "description": "The person object (ICmPerson) to add as a participant."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or person is None.",
            "FP_ParameterError: If the record or person doesn't exist."
          ],
          "example": "            >>> # Add single participant\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> speaker = project.Person.Find(\"Speaker A\")\n            >>> if speaker:\n            ...     project.DataNotebook.AddParticipant(record, speaker)\n\n            >>> # Add multiple participants\n            >>> participants = [\"Speaker A\", \"Speaker B\", \"Interpreter C\"]\n            >>> for name in participants:\n            ...     person = project.Person.Find(name)\n            ...     if person:\n            ...         project.DataNotebook.AddParticipant(record, person)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddResearcher",
          "signature": "AddResearcher(record_or_hvo, person)",
          "summary": "Add a researcher to a notebook record.",
          "description": "Add a researcher to a notebook record.\n\nAssociates a person (researcher/fieldworker) with the notebook record.\nThe same researcher can be added to multiple records.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "person",
              "type": "",
              "default": null,
              "description": "The person object (ICmPerson) to add as a researcher."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or person is None.",
            "FP_ParameterError: If the record or person doesn't exist."
          ],
          "example": "            >>> # Add single researcher\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> researcher = project.Person.Find(\"John Doe\")\n            >>> if researcher:\n            ...     project.DataNotebook.AddResearcher(record, researcher)\n\n            >>> # Add multiple researchers\n            >>> researchers = [\"John Doe\", \"Jane Smith\", \"Maria Garcia\"]\n            >>> for name in researchers:\n            ...     person = project.Person.Find(name)\n            ...     if person:\n            ...         project.DataNotebook.AddResearcher(record, person)\n\n            >>> # Create and add new researcher\n            >>> new_researcher = project.Person.Create(\"Alice Johnson\")\n            >>> project.DataNotebook.AddResearcher(record, new_researcher)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddSource",
          "signature": "AddSource(record_or_hvo, source)",
          "summary": "Add a bibliographic source/reference to a notebook record.",
          "description": "Add a bibliographic source/reference to a notebook record.\n\nAssociates a source or bibliographic reference with the notebook record,\nindicating which publications or materials are relevant to the documented\ndata.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "source",
              "type": "",
              "default": null,
              "description": "The source/reference object to add."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or source is None.",
            "FP_ParameterError: If the record or source doesn't exist."
          ],
          "example": "            >>> # Add single source\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> source = project.Bibliography.Find(\"Smith 2020\")\n            >>> if source:\n            ...     project.DataNotebook.AddSource(record, source)\n\n            >>> # Add multiple sources\n            >>> sources = [\"Smith 2020\", \"Johnson & Garcia 2018\"]\n            >>> for name in sources:\n            ...     src = project.Bibliography.Find(name)\n            ...     if src:\n            ...         project.DataNotebook.AddSource(record, src)\n\n            >>> # Create and add new source\n            >>> new_source = project.Bibliography.Create(\"Doe 2024\")\n            >>> project.DataNotebook.AddSource(record, new_source)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two notebook records and return detailed differences.",
          "description": "Compare two notebook records and return detailed differences.",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null
            },
            {
              "name": "item2",
              "type": "",
              "default": null
            },
            {
              "name": "ops1",
              "type": "",
              "default": null
            },
            {
              "name": "ops2",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(title, content=None, wsHandle=None)",
          "summary": "Create a new research notebook record.",
          "description": "Create a new research notebook record.\n\nCreates a top-level notebook record with the specified title and optional\ncontent. Use CreateSubRecord() to create hierarchical sub-records.\n",
          "parameters": [
            {
              "name": "title",
              "type": "str",
              "default": null,
              "description": "The title/heading of the notebook record."
            },
            {
              "name": "content",
              "type": "str, optional",
              "default": null,
              "description": "The main content/body text of the record. Defaults to None (empty content)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "IRnGenericRec: The newly created notebook record object. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If title is None.",
            "FP_ParameterError: If title is empty."
          ],
          "example": "            >>> # Create a basic record\n            >>> record = project.DataNotebook.Create(\n            ...     \"Interview with Speaker A\",\n            ...     \"Notes from interview about kinship terms\"\n            ... )\n            >>> print(project.DataNotebook.GetTitle(record))\n            Interview with Speaker A\n\n            >>> # Create with specific writing system\n            >>> record = project.DataNotebook.Create(\n            ...     \"Entrevista con Hablante A\",\n            ...     content=\"Notas sobre terminologa de parentesco\",\n            ...     wsHandle=project.WSHandle('es')\n            ... )\n\n            >>> # Create and configure\n            >>> record = project.DataNotebook.Create(\"Field Observation\")\n            >>> project.DataNotebook.SetDateOfEvent(record, \"2024-01-15\")\n            >>> project.DataNotebook.SetStatus(record, \"Draft\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateSubRecord",
          "signature": "CreateSubRecord(parent_record_or_hvo, title, content=None, wsHandle=None)",
          "summary": "Create a new sub-record under a parent notebook record.",
          "description": "Create a new sub-record under a parent notebook record.\n\nCreates a child record in the hierarchical structure. Sub-records\ninherit the context of their parent but can have their own properties,\nlinks, and media.\n",
          "parameters": [
            {
              "name": "parent_record_or_hvo",
              "type": "",
              "default": null,
              "description": "The parent record (IRnGenericRec) or its HVO."
            },
            {
              "name": "title",
              "type": "str",
              "default": null,
              "description": "The title of the new sub-record."
            },
            {
              "name": "content",
              "type": "str, optional",
              "default": null,
              "description": "The content of the sub-record. Defaults to None."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "IRnGenericRec: The newly created sub-record object. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If parent_record_or_hvo or title is None.",
            "FP_ParameterError: If parent doesn't exist or title is empty."
          ],
          "example": "            >>> # Create hierarchical structure\n            >>> parent = project.DataNotebook.Create(\"Interview with Speaker A\")\n            >>> sub1 = project.DataNotebook.CreateSubRecord(\n            ...     parent,\n            ...     \"Kinship Terminology\",\n            ...     \"Discussion of family relationship terms\"\n            ... )\n            >>> sub2 = project.DataNotebook.CreateSubRecord(\n            ...     parent,\n            ...     \"Color Terms\",\n            ...     \"Basic color terminology elicitation\"\n            ... )\n            >>> # Create nested sub-records\n            >>> subsub = project.DataNotebook.CreateSubRecord(\n            ...     sub1,\n            ...     \"Parent Terms\",\n            ...     \"Terms for mother and father\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(record_or_hvo)",
          "summary": "Delete a notebook record from the project.",
          "description": "Delete a notebook record from the project.\n\nDeletes the specified notebook record and all its sub-records. This\noperation also removes all links to texts, researchers, participants,\nand media files.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> # Delete by object\n            >>> record = project.DataNotebook.Find(\"Old Interview Notes\")\n            >>> if record:\n            ...     project.DataNotebook.Delete(record)\n            ...     print(\"Record deleted\")\n\n            >>> # Delete by HVO\n            >>> project.DataNotebook.Delete(12345)\n\n            >>> # Delete with confirmation\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> if record:\n            ...     title = project.DataNotebook.GetTitle(record)\n            ...     # Confirm deletion\n            ...     if confirm_delete(title):\n            ...         project.DataNotebook.Delete(record)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(record_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a notebook record, creating a new copy with a new GUID.",
          "description": "Duplicate a notebook record, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The IRnGenericRec object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source record. If False, insert at end of parent's records list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (sub-records). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "IRnGenericRec: The newly created duplicate record with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo is None."
          ],
          "example": "            >>> # Shallow duplicate (no sub-records)\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> dup = project.DataNotebook.Duplicate(record)\n            >>> print(f\"Original: {project.DataNotebook.GetGuid(record)}\")\n            >>> print(f\"Duplicate: {project.DataNotebook.GetGuid(dup)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n\n            >>> # Deep duplicate (includes all sub-records)\n            >>> deep_dup = project.DataNotebook.Duplicate(record, deep=True)\n            >>> print(f\"Sub-records: {len(project.DataNotebook.GetSubRecords(deep_dup))}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(title, wsHandle=None)",
          "summary": "Check if a notebook record with the given title exists.",
          "description": "Check if a notebook record with the given title exists.\n",
          "parameters": [
            {
              "name": "title",
              "type": "str",
              "default": null,
              "description": "The title to search for (case-sensitive)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "bool: True if a record with this title exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If title is None."
          ],
          "example": "            >>> # Check before creating\n            >>> if not project.DataNotebook.Exists(\"Interview 1\"):\n            ...     record = project.DataNotebook.Create(\"Interview 1\")\n            ... else:\n            ...     print(\"Record already exists\")\n            Record already exists\n\n            >>> # Check multiple writing systems\n            >>> exists_en = project.DataNotebook.Exists(\"Interview\", \"en\")\n            >>> exists_es = project.DataNotebook.Exists(\"Entrevista\", \"es\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(title, wsHandle=None)",
          "summary": "Find a notebook record by its title.",
          "description": "Find a notebook record by its title.\n\nSearches for the first record that exactly matches the given title\nin the specified writing system.\n",
          "parameters": [
            {
              "name": "title",
              "type": "str",
              "default": null,
              "description": "The title to search for (case-sensitive)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "IRnGenericRec: The matching notebook record object, or None if not found. ",
          "raises": [
            "FP_NullParameterError: If title is None."
          ],
          "example": "            >>> # Find and display record\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> if record:\n            ...     content = project.DataNotebook.GetContent(record)\n            ...     date = project.DataNotebook.GetDateOfEvent(record)\n            ...     print(f\"{content} - {date}\")\n            ... else:\n            ...     print(\"Record not found\")\n\n            >>> # Find in specific writing system\n            >>> record = project.DataNotebook.Find(\n            ...     \"Entrevista 1\",\n            ...     wsHandle=project.WSHandle('es')\n            ... )\n\n            >>> # Find and update\n            >>> record = project.DataNotebook.Find(\"Old Title\")\n            >>> if record:\n            ...     project.DataNotebook.SetTitle(record, \"New Title\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByDate",
          "signature": "FindByDate(start_date=None, end_date=None)",
          "summary": "Find notebook records by date range.",
          "description": "Find notebook records by date range.\n\nSearches for records whose DateOfEvent falls within the specified range.\n",
          "parameters": [
            {
              "name": "start_date",
              "type": "",
              "default": null,
              "description": "Start date (DateTime or string \"YYYY-MM-DD\"). None means no start limit."
            },
            {
              "name": "end_date",
              "type": "",
              "default": null,
              "description": "End date (DateTime or string \"YYYY-MM-DD\"). None means no end limit."
            }
          ],
          "returns": "list: List of IRnGenericRec objects matching the date criteria. ",
          "raises": [],
          "example": "            >>> # Find records from specific date range\n            >>> records = project.DataNotebook.FindByDate(\"2024-01-01\", \"2024-12-31\")\n            >>> print(f\"Found {len(records)} records in 2024\")\n            >>> for record in records:\n            ...     title = project.DataNotebook.GetTitle(record)\n            ...     date = project.DataNotebook.GetDateOfEvent(record)\n            ...     print(f\"{title} - {date}\")\n\n            >>> # Find records after a certain date\n            >>> recent = project.DataNotebook.FindByDate(start_date=\"2024-06-01\")\n\n            >>> # Find records before a certain date\n            >>> old = project.DataNotebook.FindByDate(end_date=\"2023-12-31\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByResearcher",
          "signature": "FindByResearcher(person)",
          "summary": "Find all notebook records associated with a specific researcher.",
          "description": "Find all notebook records associated with a specific researcher.\n",
          "parameters": [
            {
              "name": "person",
              "type": "",
              "default": null,
              "description": "The person object (ICmPerson) or person name (str) to search for."
            }
          ],
          "returns": "list: List of IRnGenericRec objects that have this researcher. ",
          "raises": [
            "FP_NullParameterError: If person is None."
          ],
          "example": "            >>> # Find by person object\n            >>> researcher = project.Person.Find(\"John Doe\")\n            >>> if researcher:\n            ...     records = project.DataNotebook.FindByResearcher(researcher)\n            ...     print(f\"John Doe worked on {len(records)} records\")\n            ...     for record in records:\n            ...         title = project.DataNotebook.GetTitle(record)\n            ...         print(f\"  - {title}\")\n\n            >>> # Find by name\n            >>> records = project.DataNotebook.FindByResearcher(\"Jane Smith\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByType",
          "signature": "FindByType(record_type)",
          "summary": "Find all notebook records of a specific type.",
          "description": "Find all notebook records of a specific type.\n",
          "parameters": [
            {
              "name": "record_type",
              "type": "",
              "default": null,
              "description": "The record type (ICmPossibility object or type name string)."
            }
          ],
          "returns": "list: List of IRnGenericRec objects with this type. ",
          "raises": [
            "FP_NullParameterError: If record_type is None."
          ],
          "example": "            >>> # Find by type name\n            >>> interviews = project.DataNotebook.FindByType(\"Interview\")\n            >>> print(f\"Found {len(interviews)} interview records\")\n            >>> for record in interviews:\n            ...     title = project.DataNotebook.GetTitle(record)\n            ...     date = project.DataNotebook.GetDateOfEvent(record)\n            ...     print(f\"{title} - {date}\")\n\n            >>> # Find by type object\n            >>> types = project.DataNotebook.GetAllRecordTypes()\n            >>> obs_type = next((t for t in types if \"Observation\" in str(t.Name)), None)\n            >>> if obs_type:\n            ...     observations = project.DataNotebook.FindByType(obs_type)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindRecordTypeByName",
          "signature": "FindRecordTypeByName(type_name, wsHandle=None)",
          "summary": "Find a record type by its name.",
          "description": "Find a record type by its name.\n",
          "parameters": [
            {
              "name": "type_name",
              "type": "str",
              "default": null,
              "description": "The name of the record type to find."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmPossibility: The matching record type, or None if not found. ",
          "raises": [
            "FP_NullParameterError: If type_name is None."
          ],
          "example": "            >>> # Find and set record type\n            >>> record = project.DataNotebook.Create(\"Interview Notes\")\n            >>> interview_type = project.DataNotebook.FindRecordTypeByName(\"Interview\")\n            >>> if interview_type:\n            ...     project.DataNotebook.SetRecordType(record, interview_type)\n            ... else:\n            ...     print(\"Type not found\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindStatusByName",
          "signature": "FindStatusByName(status_name, wsHandle=None)",
          "summary": "Find a status by its name.",
          "description": "Find a status by its name.\n",
          "parameters": [
            {
              "name": "status_name",
              "type": "str",
              "default": null,
              "description": "The name of the status to find."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmPossibility: The matching status object, or None if not found. ",
          "raises": [
            "FP_NullParameterError: If status_name is None."
          ],
          "example": "            >>> # Find and set status\n            >>> record = project.DataNotebook.Create(\"New Record\")\n            >>> draft_status = project.DataNotebook.FindStatusByName(\"Draft\")\n            >>> if draft_status:\n            ...     project.DataNotebook.SetStatus(record, draft_status)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all research notebook records in the project.",
          "description": "Get all research notebook records in the project.\n\nReturns all top-level notebook records. Use GetSubRecords() to navigate\nthe hierarchical structure of records and their sub-records.\n",
          "parameters": [],
          "returns": "IRnGenericRec: Each notebook record object. ",
          "raises": [],
          "example": "            >>> for record in project.DataNotebook.GetAll():\n            ...     title = project.DataNotebook.GetTitle(record)\n            ...     date = project.DataNotebook.GetDateCreated(record)\n            ...     status = project.DataNotebook.GetStatus(record)\n            ...     print(f\"{title} - {date} - {status}\")\n            Interview with Speaker A - 2024-01-15 - Reviewed\n            Field Observation Notes - 2024-01-20 - Draft\n            Elicitation Session 3 - 2024-02-01 - Approved\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllRecordTypes",
          "signature": "GetAllRecordTypes()",
          "summary": "Get all available notebook record types in the project.",
          "description": "Get all available notebook record types in the project.\n\nReturns all record type possibilities that can be assigned to notebook\nrecords. These types are used to categorize different kinds of research\nactivities and observations.\n",
          "parameters": [],
          "returns": "list: List of ICmPossibility objects representing record types. ",
          "raises": [],
          "example": "            >>> # List all record types\n            >>> for rec_type in project.DataNotebook.GetAllRecordTypes():\n            ...     name = ITsString(\n            ...         rec_type.Name.get_String(project.project.DefaultAnalWs)\n            ...     ).Text\n            ...     print(f\"Type: {name}\")\n            Type: Interview\n            Type: Observation\n            Type: Elicitation Session\n            Type: Literature Notes\n            Type: Methodology\n\n            >>> # Find specific type\n            >>> types = project.DataNotebook.GetAllRecordTypes()\n            >>> interview = next((t for t in types if \"Interview\" in str(t.Name)), None)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllStatuses",
          "signature": "GetAllStatuses()",
          "summary": "Get all available status values for notebook records.",
          "description": "Get all available status values for notebook records.\n\nReturns all status possibilities that can be assigned to notebook\nrecords for tracking workflow and review stages.\n",
          "parameters": [],
          "returns": "list: List of ICmPossibility objects representing status values. ",
          "raises": [],
          "example": "            >>> # List all statuses\n            >>> for status in project.DataNotebook.GetAllStatuses():\n            ...     name = ITsString(\n            ...         status.Name.get_String(project.project.DefaultAnalWs)\n            ...     ).Text\n            ...     print(f\"Status: {name}\")\n            Status: Draft\n            Status: In Review\n            Status: Reviewed\n            Status: Approved\n            Status: Published\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetConfidence",
          "signature": "GetConfidence(record_or_hvo)",
          "summary": "Get the confidence level of a notebook record.",
          "description": "Get the confidence level of a notebook record.\n\nConfidence indicates how certain or reliable the information in the\nrecord is considered to be.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "ICmPossibility: The confidence level object, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> confidence = project.DataNotebook.GetConfidence(record)\n            >>> if confidence:\n            ...     conf_name = ITsString(\n            ...         confidence.Name.get_String(project.project.DefaultAnalWs)\n            ...     ).Text\n            ...     print(f\"Confidence: {conf_name}\")\n            ... else:\n            ...     print(\"No confidence level set\")\n            Confidence: High\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetContent",
          "signature": "GetContent(record_or_hvo, wsHandle=None)",
          "summary": "Get the content/body text of a notebook record.",
          "description": "Get the content/body text of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The content text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> content = project.DataNotebook.GetContent(record)\n            >>> print(content)\n            Detailed notes from interview about kinship terminology.\n            Speaker provided examples of terms for siblings and cousins.\n\n            >>> # Get content with specific length limit\n            >>> content = project.DataNotebook.GetContent(record)\n            >>> summary = content[:100] + \"...\" if len(content) > 100 else content\n            >>> print(summary)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(record_or_hvo)",
          "summary": "Get the creation date of a notebook record.",
          "description": "Get the creation date of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "DateTime: The creation date, or None if not available. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> created = project.DataNotebook.GetDateCreated(record)\n            >>> if created:\n            ...     print(f\"Created: {created.ToString('yyyy-MM-dd HH:mm:ss')}\")\n            Created: 2024-01-15 14:30:00\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified(record_or_hvo)",
          "summary": "Get the last modification date of a notebook record.",
          "description": "Get the last modification date of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "DateTime: The last modification date, or None if not available. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> modified = project.DataNotebook.GetDateModified(record)\n            >>> if modified:\n            ...     print(f\"Modified: {modified.ToString('yyyy-MM-dd HH:mm:ss')}\")\n            Modified: 2024-01-20 09:15:00\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateOfEvent",
          "signature": "GetDateOfEvent(record_or_hvo)",
          "summary": "Get the event date of a notebook record.",
          "description": "Get the event date of a notebook record.\n\nThe event date represents when the documented event/observation occurred,\nwhich may differ from the creation or modification dates of the record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "DateTime: The event date, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> event_date = project.DataNotebook.GetDateOfEvent(record)\n            >>> if event_date:\n            ...     print(f\"Event: {event_date.ToString('yyyy-MM-dd')}\")\n            ... else:\n            ...     print(\"Event date not set\")\n            Event: 2024-01-15\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(record_or_hvo)",
          "summary": "Get the GUID (globally unique identifier) of a notebook record.",
          "description": "Get the GUID (globally unique identifier) of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "Guid: The GUID of the record. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> guid = project.DataNotebook.GetGuid(record)\n            >>> print(f\"GUID: {guid}\")\n            GUID: 12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLocations",
          "signature": "GetLocations(record_or_hvo)",
          "summary": "Get all locations associated with a notebook record.",
          "description": "Get all locations associated with a notebook record.\n\nLocations are places (ICmLocation objects) where the documented\nevent or data collection occurred.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "list: List of ICmLocation objects representing locations. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> locations = project.DataNotebook.GetLocations(record)\n            >>> print(f\"Locations ({len(locations)}):\")\n            >>> for location in locations:\n            ...     name = project.Location.GetName(location)\n            ...     coords = project.Location.GetCoordinates(location)\n            ...     print(f\"  - {name}: {coords}\")\n            Locations (2):\n              - Barasana Village: (-1.2345, -70.6789)\n              - Papur River Area: (1.1234, -70.5678)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMediaFiles",
          "signature": "GetMediaFiles(record_or_hvo)",
          "summary": "Get all media files attached to a notebook record.",
          "description": "Get all media files attached to a notebook record.\n\nRetrieves all ICmFile objects (audio, video, images) that are attached\nto this notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "list: List of ICmFile objects representing media files. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> media_files = project.DataNotebook.GetMediaFiles(record)\n            >>> print(f\"Media files ({len(media_files)}):\")\n            >>> for media in media_files:\n            ...     path = project.Media.GetInternalPath(media)\n            ...     print(f\"  - {path}\")\n            Media files (2):\n              - audio/interview1.wav\n              - images/notes_photo.jpg\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParentRecord",
          "signature": "GetParentRecord(record_or_hvo)",
          "summary": "Get the parent record of a sub-record.",
          "description": "Get the parent record of a sub-record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The sub-record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "IRnGenericRec: The parent record object, or None if this is a top-level record. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> # Navigate up the hierarchy\n            >>> subrecord = project.DataNotebook.Find(\"Kinship Terms Section\")\n            >>> parent = project.DataNotebook.GetParentRecord(subrecord)\n            >>> if parent:\n            ...     parent_title = project.DataNotebook.GetTitle(parent)\n            ...     print(f\"Parent: {parent_title}\")\n            ... else:\n            ...     print(\"This is a top-level record\")\n            Parent: Interview 1\n\n            >>> # Get full path to root\n            >>> def get_path(rec):\n            ...     path = []\n            ...     current = rec\n            ...     while current:\n            ...         path.insert(0, project.DataNotebook.GetTitle(current))\n            ...         current = project.DataNotebook.GetParentRecord(current)\n            ...     return \" > \".join(path)\n            >>> print(get_path(subrecord))\n            Interview 1 > Kinship Terms Section\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParticipants",
          "signature": "GetParticipants(record_or_hvo)",
          "summary": "Get all participants associated with a notebook record.",
          "description": "Get all participants associated with a notebook record.\n\nParticipants are people (ICmPerson objects) who participated in the\nrecorded event (e.g., consultants, speakers, informants).\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "list: List of ICmPerson objects representing participants. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> participants = project.DataNotebook.GetParticipants(record)\n            >>> print(f\"Participants ({len(participants)}):\")\n            >>> for person in participants:\n            ...     name = project.Person.GetName(person)\n            ...     print(f\"  - {name}\")\n            Participants (3):\n              - Speaker A\n              - Speaker B\n              - Interpreter C\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRecordType",
          "signature": "GetRecordType(record_or_hvo)",
          "summary": "Get the type/category of a notebook record.",
          "description": "Get the type/category of a notebook record.\n\nRecord types categorize notebook records (e.g., \"Interview\", \"Observation\",\n\"Elicitation Session\", \"Literature Notes\"). Types are defined as\npossibilities in the project's notebook record type list.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "ICmPossibility: The record type object, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> rec_type = project.DataNotebook.GetRecordType(record)\n            >>> if rec_type:\n            ...     type_name = ITsString(\n            ...         rec_type.Name.get_String(project.project.DefaultAnalWs)\n            ...     ).Text\n            ...     print(f\"Type: {type_name}\")\n            ... else:\n            ...     print(\"No type set\")\n            Type: Interview\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetResearchers",
          "signature": "GetResearchers(record_or_hvo)",
          "summary": "Get all researchers associated with a notebook record.",
          "description": "Get all researchers associated with a notebook record.\n\nResearchers are people (ICmPerson objects) who conducted the fieldwork\nor created the observations documented in the record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "list: List of ICmPerson objects representing researchers. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> researchers = project.DataNotebook.GetResearchers(record)\n            >>> print(f\"Researchers ({len(researchers)}):\")\n            >>> for person in researchers:\n            ...     name = project.Person.GetName(person)\n            ...     print(f\"  - {name}\")\n            Researchers (2):\n              - John Doe\n              - Jane Smith\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSources",
          "signature": "GetSources(record_or_hvo)",
          "summary": "Get all bibliographic sources associated with a notebook record.",
          "description": "Get all bibliographic sources associated with a notebook record.\n\nSources are references or publications (typically ICmPossibility objects\nfrom the project's bibliography) that are cited or related to the\nnotebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "list: List of source/reference objects. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> sources = project.DataNotebook.GetSources(record)\n            >>> print(f\"Sources ({len(sources)}):\")\n            >>> for source in sources:\n            ...     # Display source information\n            ...     print(f\"  - {source}\")\n            Sources (2):\n              - Smith 2020\n              - Johnson & Garcia 2018\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetStatus",
          "signature": "GetStatus(record_or_hvo)",
          "summary": "Get the status of a notebook record.",
          "description": "Get the status of a notebook record.\n\nStatus indicates the review state or workflow stage of the record\n(e.g., \"Draft\", \"Reviewed\", \"Approved\", \"Published\").\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "ICmPossibility: The status object, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> status = project.DataNotebook.GetStatus(record)\n            >>> if status:\n            ...     status_name = ITsString(\n            ...         status.Name.get_String(project.project.DefaultAnalWs)\n            ...     ).Text\n            ...     print(f\"Status: {status_name}\")\n            ... else:\n            ...     print(\"No status set\")\n            Status: Reviewed\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubRecords",
          "signature": "GetSubRecords(record_or_hvo)",
          "summary": "Get all direct sub-records of a notebook record.",
          "description": "Get all direct sub-records of a notebook record.\n\nNotebook records support hierarchical organization where records can\ncontain sub-records. This method returns only direct children, not\nall descendants.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The parent record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "list: List of IRnGenericRec objects that are sub-records. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> # Get and display sub-records\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> subs = project.DataNotebook.GetSubRecords(record)\n            >>> print(f\"Found {len(subs)} sub-records:\")\n            >>> for sub in subs:\n            ...     title = project.DataNotebook.GetTitle(sub)\n            ...     print(f\"  - {title}\")\n            Found 3 sub-records:\n              - Kinship Terms Section\n              - Color Terms Section\n              - Grammar Notes\n\n            >>> # Recursive display of hierarchy\n            >>> def show_hierarchy(rec, indent=0):\n            ...     title = project.DataNotebook.GetTitle(rec)\n            ...     print(\"  \" * indent + title)\n            ...     for sub in project.DataNotebook.GetSubRecords(rec):\n            ...         show_hierarchy(sub, indent + 1)\n            >>> show_hierarchy(record)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTexts",
          "signature": "GetTexts(record_or_hvo)",
          "summary": "Get all texts linked to a notebook record.",
          "description": "Get all texts linked to a notebook record.\n\nRetrieves all IText objects that are linked to this notebook record.\nTexts might be recordings, transcriptions, or other textual data that\nthe notebook record references or documents.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            }
          ],
          "returns": "list: List of IText objects linked to the record. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> texts = project.DataNotebook.GetTexts(record)\n            >>> print(f\"Linked texts ({len(texts)}):\")\n            >>> for text in texts:\n            ...     title = project.Texts.GetTitle(text)\n            ...     print(f\"  - {title}\")\n            Linked texts (2):\n              - Interview Recording 1\n              - Interview Transcription 1\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTitle",
          "signature": "GetTitle(record_or_hvo, wsHandle=None)",
          "summary": "Get the title of a notebook record.",
          "description": "Get the title of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The title text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If record_or_hvo is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> title = project.DataNotebook.GetTitle(record)\n            >>> print(title)\n            Interview 1\n\n            >>> # Get title in multiple languages\n            >>> title_en = project.DataNotebook.GetTitle(record, \"en\")\n            >>> title_es = project.DataNotebook.GetTitle(record, \"es\")\n            >>> print(f\"EN: {title_en}, ES: {title_es}\")\n            EN: Interview 1, ES: Entrevista 1\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "LinkToText",
          "signature": "LinkToText(record_or_hvo, text)",
          "summary": "Link a notebook record to a text.",
          "description": "Link a notebook record to a text.\n\nCreates a connection between a notebook record and a text object,\nindicating that the record documents or relates to that text.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "text",
              "type": "",
              "default": null,
              "description": "The text object (IText) to link to."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or text is None.",
            "FP_ParameterError: If the record or text doesn't exist."
          ],
          "example": "            >>> # Link record to text\n            >>> record = project.DataNotebook.Find(\"Interview Notes\")\n            >>> text = project.Texts.Find(\"Interview Recording 1\")\n            >>> if text:\n            ...     project.DataNotebook.LinkToText(record, text)\n\n            >>> # Link to multiple texts\n            >>> text_titles = [\"Recording 1\", \"Recording 2\", \"Transcription 1\"]\n            >>> for title in text_titles:\n            ...     text = project.Texts.Find(title)\n            ...     if text:\n            ...         project.DataNotebook.LinkToText(record, text)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveLocation",
          "signature": "RemoveLocation(record_or_hvo, location)",
          "summary": "Remove a location from a notebook record.",
          "description": "Remove a location from a notebook record.\n\nRemoves the association between a location and a notebook record. The\nlocation object itself is not deleted.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "location",
              "type": "",
              "default": null,
              "description": "The location object (ICmLocation) to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or location is None.",
            "FP_ParameterError: If the record or location doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> location = project.Location.Find(\"Old Site\")\n            >>> project.DataNotebook.RemoveLocation(record, location)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveMediaFile",
          "signature": "RemoveMediaFile(record_or_hvo, media_file)",
          "summary": "Remove a media file from a notebook record.",
          "description": "Remove a media file from a notebook record.\n\nDetaches a media file from the notebook record. The media file itself\nis not deleted from the project.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "media_file",
              "type": "",
              "default": null,
              "description": "The media file object (ICmFile) to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or media_file is None.",
            "FP_ParameterError: If the record or media file doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> media = project.Media.Find(\"old_recording.wav\")\n            >>> if media:\n            ...     project.DataNotebook.RemoveMediaFile(record, media)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveParticipant",
          "signature": "RemoveParticipant(record_or_hvo, person)",
          "summary": "Remove a participant from a notebook record.",
          "description": "Remove a participant from a notebook record.\n\nRemoves the association between a person and a notebook record. The\nperson object itself is not deleted.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "person",
              "type": "",
              "default": null,
              "description": "The person object (ICmPerson) to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or person is None.",
            "FP_ParameterError: If the record or person doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> speaker = project.Person.Find(\"Speaker A\")\n            >>> project.DataNotebook.RemoveParticipant(record, speaker)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveResearcher",
          "signature": "RemoveResearcher(record_or_hvo, person)",
          "summary": "Remove a researcher from a notebook record.",
          "description": "Remove a researcher from a notebook record.\n\nRemoves the association between a person and a notebook record. The\nperson object itself is not deleted.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "person",
              "type": "",
              "default": null,
              "description": "The person object (ICmPerson) to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or person is None.",
            "FP_ParameterError: If the record or person doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> researcher = project.Person.Find(\"John Doe\")\n            >>> project.DataNotebook.RemoveResearcher(record, researcher)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveSource",
          "signature": "RemoveSource(record_or_hvo, source)",
          "summary": "Remove a bibliographic source/reference from a notebook record.",
          "description": "Remove a bibliographic source/reference from a notebook record.\n\nRemoves the association between a source and a notebook record. The\nsource object itself is not deleted.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "source",
              "type": "",
              "default": null,
              "description": "The source/reference object to remove."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or source is None.",
            "FP_ParameterError: If the record or source doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> source = project.Bibliography.Find(\"Old Reference\")\n            >>> project.DataNotebook.RemoveSource(record, source)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetConfidence",
          "signature": "SetConfidence(record_or_hvo, confidence)",
          "summary": "Set the confidence level of a notebook record.",
          "description": "Set the confidence level of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "confidence",
              "type": "",
              "default": null,
              "description": "The confidence level (ICmPossibility object or name string)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or confidence is None.",
            "FP_ParameterError: If the record or confidence level doesn't exist."
          ],
          "example": "            >>> # Set confidence by name\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> project.DataNotebook.SetConfidence(record, \"High\")\n\n            >>> # Set confidence by object\n            >>> conf_levels = project.Confidence.GetAll()\n            >>> high = next((c for c in conf_levels if \"High\" in str(c.Name)), None)\n            >>> if high:\n            ...     project.DataNotebook.SetConfidence(record, high)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetContent",
          "signature": "SetContent(record_or_hvo, content, wsHandle=None)",
          "summary": "Set the content/body text of a notebook record.",
          "description": "Set the content/body text of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "content",
              "type": "str",
              "default": null,
              "description": "The new content text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or content is None.",
            "FP_ParameterError: If the record doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> project.DataNotebook.SetContent(\n            ...     record,\n            ...     \"Detailed notes from interview about kinship terminology. \"\n            ...     \"Speaker provided examples of terms for siblings and cousins.\"\n            ... )\n\n            >>> # Update content incrementally\n            >>> existing = project.DataNotebook.GetContent(record)\n            >>> new_content = existing + \"\\n\\nAdditional observations...\"\n            >>> project.DataNotebook.SetContent(record, new_content)\n\n            >>> # Set in multiple languages\n            >>> project.DataNotebook.SetContent(record, \"English notes\", \"en\")\n            >>> project.DataNotebook.SetContent(record, \"Notas en espaol\", \"es\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDateOfEvent",
          "signature": "SetDateOfEvent(record_or_hvo, date)",
          "summary": "Set the event date of a notebook record.",
          "description": "Set the event date of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "date",
              "type": "",
              "default": null,
              "description": "The date to set (DateTime object or string in format \"YYYY-MM-DD\" or \"YYYY-MM-DD HH:MM:SS\")."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or date is None.",
            "FP_ParameterError: If the record doesn't exist or date format is invalid."
          ],
          "example": "            >>> # Set with DateTime object\n            >>> from System import DateTime\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> project.DataNotebook.SetDateOfEvent(record, DateTime.Now)\n\n            >>> # Set with string\n            >>> project.DataNotebook.SetDateOfEvent(record, \"2024-01-15\")\n            >>> project.DataNotebook.SetDateOfEvent(record, \"2024-01-15 14:30:00\")\n\n            >>> # Set date from user input\n            >>> date_str = \"2024-01-15\"\n            >>> project.DataNotebook.SetDateOfEvent(record, date_str)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetRecordType",
          "signature": "SetRecordType(record_or_hvo, record_type)",
          "summary": "Set the type/category of a notebook record.",
          "description": "Set the type/category of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "record_type",
              "type": "",
              "default": null,
              "description": "The type to set (ICmPossibility object from record types list)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or record_type is None.",
            "FP_ParameterError: If the record or type doesn't exist."
          ],
          "example": "            >>> # Set record type\n            >>> record = project.DataNotebook.Find(\"Field Notes 1\")\n            >>> types = project.DataNotebook.GetAllRecordTypes()\n            >>> interview_type = next(\n            ...     (t for t in types if \"Interview\" in str(t.Name)), None\n            ... )\n            >>> if interview_type:\n            ...     project.DataNotebook.SetRecordType(record, interview_type)\n\n            >>> # Find type by name and set\n            >>> record = project.DataNotebook.Create(\"New Observation\")\n            >>> obs_type = project.DataNotebook.FindRecordTypeByName(\"Observation\")\n            >>> if obs_type:\n            ...     project.DataNotebook.SetRecordType(record, obs_type)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetStatus",
          "signature": "SetStatus(record_or_hvo, status)",
          "summary": "Set the status of a notebook record.",
          "description": "Set the status of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "status",
              "type": "",
              "default": null,
              "description": "The status to set (ICmPossibility object or status name string)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or status is None.",
            "FP_ParameterError: If the record or status doesn't exist."
          ],
          "example": "            >>> # Set status by name\n            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> project.DataNotebook.SetStatus(record, \"Reviewed\")\n\n            >>> # Set status by object\n            >>> statuses = project.DataNotebook.GetAllStatuses()\n            >>> approved = next((s for s in statuses if \"Approved\" in str(s.Name)), None)\n            >>> if approved:\n            ...     project.DataNotebook.SetStatus(record, approved)\n\n            >>> # Workflow example\n            >>> record = project.DataNotebook.Create(\"New Interview\")\n            >>> project.DataNotebook.SetStatus(record, \"Draft\")\n            >>> # ... after review ...\n            >>> project.DataNotebook.SetStatus(record, \"Reviewed\")\n            >>> # ... after approval ...\n            >>> project.DataNotebook.SetStatus(record, \"Approved\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetTitle",
          "signature": "SetTitle(record_or_hvo, title, wsHandle=None)",
          "summary": "Set the title of a notebook record.",
          "description": "Set the title of a notebook record.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "title",
              "type": "str",
              "default": null,
              "description": "The new title text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or title is None.",
            "FP_ParameterError: If the record doesn't exist or title is empty."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview 1\")\n            >>> project.DataNotebook.SetTitle(record, \"Interview with Speaker A\")\n            >>> print(project.DataNotebook.GetTitle(record))\n            Interview with Speaker A\n\n            >>> # Set in multiple languages\n            >>> project.DataNotebook.SetTitle(record, \"Interview 1\", \"en\")\n            >>> project.DataNotebook.SetTitle(record, \"Entrevista 1\", \"es\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "UnlinkFromText",
          "signature": "UnlinkFromText(record_or_hvo, text)",
          "summary": "Unlink a notebook record from a text.",
          "description": "Unlink a notebook record from a text.\n\nRemoves the connection between a notebook record and a text object.\nThe text itself is not deleted.\n",
          "parameters": [
            {
              "name": "record_or_hvo",
              "type": "",
              "default": null,
              "description": "The notebook record object (IRnGenericRec) or its HVO."
            },
            {
              "name": "text",
              "type": "",
              "default": null,
              "description": "The text object (IText) to unlink from."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If record_or_hvo or text is None.",
            "FP_ParameterError: If the record or text doesn't exist."
          ],
          "example": "            >>> record = project.DataNotebook.Find(\"Interview Notes\")\n            >>> text = project.Texts.Find(\"Recording 1\")\n            >>> if text:\n            ...     project.DataNotebook.UnlinkFromText(record, text)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize DataNotebookOperations with a FLExProject instance.",
          "description": "Initialize DataNotebookOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "notebook",
        "operations"
      ]
    },
    "LocationOperations": {
      "name": "LocationOperations",
      "type": "class",
      "namespace": "FlexLibs2.Notebook.LocationOperations",
      "source_file": "Notebook/LocationOperations",
      "category": "notebook",
      "summary": "This class provides operations for managing geographic locations in a\nFieldWorks project.",
      "description": "This class provides operations for managing geographic locations in a\nFieldWorks project.\n\nLocations in FLEx represent geographic places where linguistic data was\ncollected, where speakers live, or where languages are spoken. Locations\nsupport hierarchical organization (regions, subregions, cities), geographic\ncoordinates, elevation data, and descriptive information.\n\nThis class should be accessed via FLExProject.Location property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all locations\nfor location in project.Location.GetAll():\nname = project.Location.GetName(location)\ncoords = project.Location.GetCoordinates(location)\nprint(f\"{name}: {coords}\")\n\n# Create a new location\nvillage = project.Location.Create(\"Barasana Village\", \"en\")\nproject.Location.SetCoordinates(village, -1.2345, -70.6789)\nproject.Location.SetElevation(village, 150)\n\n# Create hierarchical locations\nregion = project.Location.Create(\"Vaups Region\", \"en\")\nsubregion = project.Location.CreateSublocation(\nregion, \"Papur River Area\", \"en\")\n\n# Find locations by coordinates\nnearby = project.Location.FindByCoordinates(-1.23, -70.67, radius_km=50)\nprint(f\"Found {len(nearby)} locations within 50 km\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two locations and return detailed differences.",
          "description": "Compare two locations and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First location"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second location"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Operations for item1's project (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Operations for item2's project (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict)",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, wsHandle=None, alias=None)",
          "summary": "Create a new top-level location.",
          "description": "Create a new top-level location.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the new location."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            },
            {
              "name": "alias",
              "type": "str",
              "default": null,
              "description": "Optional alias/abbreviation for the location."
            }
          ],
          "returns": "ICmLocation: The newly created location object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> # Create a simple location\n            >>> village = project.Location.Create(\"Barasana Village\", \"en\")\n            >>> print(project.Location.GetName(village))\n            Barasana Village\n\n            >>> # Create with alias\n            >>> region = project.Location.Create(\"Vaups Department\", \"en\",\n            ...                                   alias=\"VAU\")\n            >>> print(project.Location.GetAlias(region))\n            VAU\n\n            >>> # Add coordinates and elevation\n            >>> project.Location.SetCoordinates(village, -1.2345, -70.6789)\n            >>> project.Location.SetElevation(village, 150)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateSublocation",
          "signature": "CreateSublocation(parent_location_or_hvo, name, wsHandle=None, alias=None)",
          "summary": "Create a new sublocation under a parent location.",
          "description": "Create a new sublocation under a parent location.\n",
          "parameters": [
            {
              "name": "parent_location_or_hvo",
              "type": "",
              "default": null,
              "description": "The parent ICmLocation object or HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the new sublocation."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            },
            {
              "name": "alias",
              "type": "str",
              "default": null,
              "description": "Optional alias/abbreviation."
            }
          ],
          "returns": "ICmLocation: The newly created sublocation object. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If parent_location_or_hvo or name is None.",
            "FP_ParameterError: If name is empty or parent doesn't exist."
          ],
          "example": "            >>> # Create hierarchical locations\n            >>> country = project.Location.Create(\"Colombia\", \"en\")\n            >>> department = project.Location.CreateSublocation(\n            ...     country, \"Vaups Department\", \"en\", alias=\"VAU\")\n            >>> municipality = project.Location.CreateSublocation(\n            ...     department, \"Mit\", \"en\")\n\n            >>> # Verify hierarchy\n            >>> parent = project.Location.GetRegion(municipality)\n            >>> print(project.Location.GetName(parent))\n            Vaups Department\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(location_or_hvo)",
          "summary": "Delete a location from the project.",
          "description": "Delete a location from the project.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If location_or_hvo is None."
          ],
          "example": "            >>> # Delete a location\n            >>> location = project.Location.Find(\"Old Village\")\n            >>> if location:\n            ...     project.Location.Delete(location)\n\n            >>> # Delete by HVO\n            >>> project.Location.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - Deletion is permanent and cannot be undone\n            - Deletes all sublocations recursively\n            - Any references to this location will be removed\n            - Data collected at this location will lose location reference\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(location_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a location, creating a new copy with a new GUID.",
          "description": "Duplicate a location, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmLocation object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source location. If False, insert at end of parent's sublocations list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (sublocations). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "ICmLocation: The newly created duplicate location with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If location_or_hvo is None."
          ],
          "example": "            >>> # Shallow duplicate (no sublocations)\n            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> dup = project.Location.Duplicate(location)\n            >>> print(f\"Original: {project.Location.GetGuid(location)}\")\n            >>> print(f\"Duplicate: {project.Location.GetGuid(dup)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n\n            >>> # Deep duplicate (includes all sublocations)\n            >>> region = project.Location.Find(\"Vaups Department\")\n            >>> deep_dup = project.Location.Duplicate(region, deep=True)\n            >>> print(f\"Sublocations: {len(project.Location.GetSublocations(deep_dup))}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name)",
          "summary": "Check if a location with the given name exists.",
          "description": "Check if a location with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The location name to check."
            }
          ],
          "returns": "bool: True if location exists, False otherwise. ",
          "raises": [],
          "example": "            >>> if project.Location.Exists(\"Barasana Village\"):\n            ...     print(\"Village location exists\")\n            Village location exists\n\n            >>> if not project.Location.Exists(\"Unknown Place\"):\n            ...     location = project.Location.Create(\"Unknown Place\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find a location by its name.",
          "description": "Find a location by its name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The location name to search for (case-insensitive)."
            }
          ],
          "returns": "ICmLocation or None: The location object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> # Find by name\n            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> if location:\n            ...     coords = project.Location.GetCoordinates(location)\n            ...     print(f\"Found at: {coords}\")\n            Found at: (-1.2345, -70.6789)\n\n            >>> # Case-insensitive search\n            >>> location = project.Location.Find(\"barasana village\")\n            >>> print(location is not None)\n            True\n\n            >>> # Not found\n            >>> missing = project.Location.Find(\"Nonexistent Place\")\n            >>> print(missing)\n            None\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByCoordinates",
          "signature": "FindByCoordinates(latitude, longitude, radius_km=10)",
          "summary": "Find locations near the specified coordinates.",
          "description": "Find locations near the specified coordinates.\n",
          "parameters": [
            {
              "name": "latitude",
              "type": "float",
              "default": null,
              "description": "Target latitude in decimal degrees."
            },
            {
              "name": "longitude",
              "type": "float",
              "default": null,
              "description": "Target longitude in decimal degrees."
            },
            {
              "name": "radius_km",
              "type": "float",
              "default": 10,
              "description": "Search radius in kilometers. Defaults to 10 km."
            }
          ],
          "returns": "list: List of (ICmLocation, distance_km) tuples sorted by distance, where distance_km is the distance in kilometers from the target. ",
          "raises": [
            "FP_NullParameterError: If latitude or longitude is None.",
            "FP_ParameterError: If coordinates or radius are invalid."
          ],
          "example": "            >>> # Find locations within 50 km of a point\n            >>> nearby = project.Location.FindByCoordinates(-1.23, -70.67, radius_km=50)\n            >>> for location, distance in nearby:\n            ...     name = project.Location.GetName(location)\n            ...     print(f\"{name}: {distance:.1f} km away\")\n            Barasana Village: 2.3 km away\n            Neighboring Village: 15.7 km away\n            Mit: 45.2 km away\n\n            >>> # Find exact location (very small radius)\n            >>> exact = project.Location.FindByCoordinates(\n            ...     -1.2345, -70.6789, radius_km=0.1)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAlias",
          "signature": "GetAlias(location_or_hvo, wsHandle=None)",
          "summary": "Get the alias/abbreviation of a location.",
          "description": "Get the alias/abbreviation of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The location alias, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Vaups Department\")\n            >>> alias = project.Location.GetAlias(location)\n            >>> print(alias)\n            VAU\n\n            >>> # Common use case: display alias when available\n            >>> name = project.Location.GetName(location)\n            >>> alias = project.Location.GetAlias(location)\n            >>> display = f\"{name} ({alias})\" if alias else name\n            >>> print(display)\n            Vaups Department (VAU)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(flat=True)",
          "summary": "Get all locations in the project.",
          "description": "Get all locations in the project.\n",
          "parameters": [
            {
              "name": "flat",
              "type": "bool",
              "default": true,
              "description": "If True, returns a flat list of all locations including sublocations. If False, returns only top-level locations (use GetSublocations to navigate hierarchy). Defaults to True."
            }
          ],
          "returns": "list: List of ICmLocation objects. ",
          "raises": [],
          "example": "            >>> # Get all locations in a flat list\n            >>> for location in project.Location.GetAll(flat=True):\n            ...     name = project.Location.GetName(location)\n            ...     coords = project.Location.GetCoordinates(location)\n            ...     print(f\"{name}: {coords}\")\n            Colombia: (4.5709, -74.2973)\n            Vaups Department: (1.2500, -70.5000)\n            Barasana Village: (-1.2345, -70.6789)\n            ...\n\n            >>> # Get only top-level locations\n            >>> top_level = project.Location.GetAll(flat=False)\n            >>> for location in top_level:\n            ...     name = project.Location.GetName(location)\n            ...     subs = project.Location.GetSublocations(location)\n            ...     print(f\"{name} ({len(subs)} sublocations)\")\n            Colombia (5 sublocations)\n            Brazil (3 sublocations)\n            ...\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCoordinates",
          "signature": "GetCoordinates(location_or_hvo)",
          "summary": "Get the geographic coordinates (latitude, longitude) of a location.",
          "description": "Get the geographic coordinates (latitude, longitude) of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            }
          ],
          "returns": "tuple or None: A tuple of (latitude, longitude) as floats in decimal degrees, or None if coordinates are not set. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> coords = project.Location.GetCoordinates(location)\n            >>> if coords:\n            ...     lat, lon = coords\n            ...     print(f\"Latitude: {lat}, Longitude: {lon}\")\n            Latitude: -1.2345, Longitude: -70.6789\n\n            >>> # Check if coordinates are set\n            >>> if project.Location.GetCoordinates(location):\n            ...     print(\"Location has coordinates\")\n            ... else:\n            ...     print(\"Location coordinates not set\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(location_or_hvo)",
          "summary": "Get the creation date of a location.",
          "description": "Get the creation date of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            }
          ],
          "returns": "System.DateTime or None: The creation date/time, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> date = project.Location.GetDateCreated(location)\n            >>> if date:\n            ...     print(f\"Created: {date}\")\n            Created: 11/23/2025 10:30:45 AM\n\n            >>> # Sort locations by creation date\n            >>> locations = project.Location.GetAll()\n            >>> sorted_locs = sorted(locations,\n            ...     key=lambda l: project.Location.GetDateCreated(l) or DateTime.MinValue)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified(location_or_hvo)",
          "summary": "Get the last modification date of a location.",
          "description": "Get the last modification date of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            }
          ],
          "returns": "System.DateTime or None: The modification date/time, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> modified = project.Location.GetDateModified(location)\n            >>> if modified:\n            ...     print(f\"Last modified: {modified}\")\n            Last modified: 11/23/2025 2:15:30 PM\n\n            >>> # Find recently modified locations\n            >>> from System import DateTime\n            >>> one_week_ago = DateTime.Now.AddDays(-7)\n            >>> locations = project.Location.GetAll()\n            >>> recent = [l for l in locations\n            ...     if project.Location.GetDateModified(l) and\n            ...        project.Location.GetDateModified(l) > one_week_ago]\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(location_or_hvo, wsHandle=None)",
          "summary": "Get the description of a location.",
          "description": "Get the description of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The location description, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> desc = project.Location.GetDescription(location)\n            >>> print(desc)\n            Small village on the Papur River, accessible by boat.\n            Primary language: Barasana. Population approximately 200.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetElevation",
          "signature": "GetElevation(location_or_hvo)",
          "summary": "Get the elevation of a location in meters above sea level.",
          "description": "Get the elevation of a location in meters above sea level.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            }
          ],
          "returns": "int or None: Elevation in meters, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> elevation = project.Location.GetElevation(location)\n            >>> if elevation is not None:\n            ...     print(f\"Elevation: {elevation} meters above sea level\")\n            Elevation: 150 meters above sea level\n\n            >>> # Check if elevation is set\n            >>> if project.Location.GetElevation(location) is None:\n            ...     print(\"Elevation not recorded\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(location_or_hvo)",
          "summary": "Get the GUID (Globally Unique Identifier) of a location.",
          "description": "Get the GUID (Globally Unique Identifier) of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            }
          ],
          "returns": "System.Guid: The location's GUID. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> guid = project.Location.GetGuid(location)\n            >>> print(guid)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\n            >>> # Use GUID to retrieve location later\n            >>> location2 = project.Object(guid)\n            >>> print(project.Location.GetName(location2))\n            Barasana Village\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(location_or_hvo, wsHandle=None)",
          "summary": "Get the name of a location.",
          "description": "Get the name of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The location name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> name = project.Location.GetName(location)\n            >>> print(name)\n            Barasana Village\n\n            >>> # Get name in specific writing system\n            >>> name_es = project.Location.GetName(location,\n            ...                                     project.WSHandle('es'))\n            >>> print(name_es)\n            Pueblo Barasana\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetNearby",
          "signature": "GetNearby(location_or_hvo, radius_km=50)",
          "summary": "Get all locations near a given location.",
          "description": "Get all locations near a given location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            },
            {
              "name": "radius_km",
              "type": "float",
              "default": 50,
              "description": "Search radius in kilometers. Defaults to 50 km."
            }
          ],
          "returns": "list: List of (ICmLocation, distance_km) tuples sorted by distance, excluding the reference location itself. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist, has no coordinates,",
            "or radius is invalid."
          ],
          "example": "            >>> # Find locations near a village\n            >>> village = project.Location.Find(\"Barasana Village\")\n            >>> nearby = project.Location.GetNearby(village, radius_km=30)\n            >>> for location, distance in nearby:\n            ...     name = project.Location.GetName(location)\n            ...     print(f\"{name}: {distance:.1f} km away\")\n            Neighboring Village: 15.7 km away\n            Another Village: 22.3 km away\n\n            >>> # Find all locations in the same area (larger radius)\n            >>> regional = project.Location.GetNearby(village, radius_km=200)\n            >>> print(f\"Found {len(regional)} locations in the region\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRegion",
          "signature": "GetRegion(location_or_hvo)",
          "summary": "Get the parent region of a location.",
          "description": "Get the parent region of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            }
          ],
          "returns": "ICmLocation or None: The parent location, or None if top-level. ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> # Get parent region\n            >>> village = project.Location.Find(\"Barasana Village\")\n            >>> region = project.Location.GetRegion(village)\n            >>> if region:\n            ...     region_name = project.Location.GetName(region)\n            ...     print(f\"Part of: {region_name}\")\n            Part of: Papur River Area\n\n            >>> # Top-level locations have no parent\n            >>> country = project.Location.Find(\"Colombia\")\n            >>> parent = project.Location.GetRegion(country)\n            >>> print(parent)\n            None\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSublocations",
          "signature": "GetSublocations(location_or_hvo)",
          "summary": "Get all direct child sublocations of a location.",
          "description": "Get all direct child sublocations of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            }
          ],
          "returns": "list: List of ICmLocation child objects (empty list if none). ",
          "raises": [
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> # Get sublocations of a region\n            >>> region = project.Location.Find(\"Vaups Department\")\n            >>> sublocations = project.Location.GetSublocations(region)\n            >>> for subloc in sublocations:\n            ...     name = project.Location.GetName(subloc)\n            ...     coords = project.Location.GetCoordinates(subloc)\n            ...     print(f\"{name}: {coords}\")\n            Mit: (1.2534, -70.2342)\n            Carur: (0.8756, -71.2934)\n            Papur River Area: (1.1234, -70.5678)\n            ...\n\n            >>> # Check if location has sublocations\n            >>> if project.Location.GetSublocations(region):\n            ...     print(\"Region has sublocations\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmLocation object"
            }
          ],
          "returns": "dict: Dictionary of syncable properties",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAlias",
          "signature": "SetAlias(location_or_hvo, alias, wsHandle=None)",
          "summary": "Set the alias/abbreviation of a location.",
          "description": "Set the alias/abbreviation of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            },
            {
              "name": "alias",
              "type": "str",
              "default": null,
              "description": "The new alias."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If location_or_hvo or alias is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Vaups Department\")\n            >>> project.Location.SetAlias(location, \"VAU\")\n            >>> print(project.Location.GetAlias(location))\n            VAU\n\n            >>> # Clear alias\n            >>> project.Location.SetAlias(location, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetCoordinates",
          "signature": "SetCoordinates(location_or_hvo, latitude, longitude)",
          "summary": "Set the geographic coordinates of a location.",
          "description": "Set the geographic coordinates of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            },
            {
              "name": "latitude",
              "type": "float",
              "default": null,
              "description": "Latitude in decimal degrees (-90 to +90)."
            },
            {
              "name": "longitude",
              "type": "float",
              "default": null,
              "description": "Longitude in decimal degrees (-180 to +180)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If location_or_hvo, latitude, or longitude is None.",
            "FP_ParameterError: If location doesn't exist or coordinates are invalid."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> # Set coordinates (latitude, longitude in decimal degrees)\n            >>> project.Location.SetCoordinates(location, -1.2345, -70.6789)\n            >>> coords = project.Location.GetCoordinates(location)\n            >>> print(coords)\n            (-1.2345, -70.6789)\n\n            >>> # Set coordinates for a city\n            >>> bogota = project.Location.Create(\"Bogot\", \"en\")\n            >>> project.Location.SetCoordinates(bogota, 4.7110, -74.0721)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(location_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of a location.",
          "description": "Set the description of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If location_or_hvo or description is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> desc = (\"Small village on the Papur River.\\n\"\n            ...         \"Accessible by boat from Mit.\\n\"\n            ...         \"Primary language: Barasana.\")\n            >>> project.Location.SetDescription(location, desc)\n\n            >>> # Multilingual descriptions\n            >>> project.Location.SetDescription(location, desc_en, \"en\")\n            >>> project.Location.SetDescription(location, desc_es, \"es\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetElevation",
          "signature": "SetElevation(location_or_hvo, elevation)",
          "summary": "Set the elevation of a location in meters above sea level.",
          "description": "Set the elevation of a location in meters above sea level.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            },
            {
              "name": "elevation",
              "type": "int",
              "default": null,
              "description": "Elevation in meters above sea level."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If location_or_hvo or elevation is None.",
            "FP_ParameterError: If location doesn't exist or elevation is invalid."
          ],
          "example": "            >>> location = project.Location.Find(\"Barasana Village\")\n            >>> # Set elevation (150 meters above sea level)\n            >>> project.Location.SetElevation(location, 150)\n            >>> print(project.Location.GetElevation(location))\n            150\n\n            >>> # Below sea level location\n            >>> dead_sea = project.Location.Create(\"Dead Sea Shore\", \"en\")\n            >>> project.Location.SetElevation(dead_sea, -430)\n\n            >>> # Mountain village\n            >>> mountain = project.Location.Create(\"Cusco\", \"en\")\n            >>> project.Location.SetElevation(mountain, 3400)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(location_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a location.",
          "description": "Set the name of a location.\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If location_or_hvo or name is None.",
            "FP_ParameterError: If location doesn't exist."
          ],
          "example": "            >>> location = project.Location.Find(\"Old Name\")\n            >>> project.Location.SetName(location, \"New Name\")\n            >>> print(project.Location.GetName(location))\n            New Name\n\n            >>> # Set name in multiple writing systems\n            >>> project.Location.SetName(location, \"Village\", \"en\")\n            >>> project.Location.SetName(location, \"Pueblo\", \"es\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetRegion",
          "signature": "SetRegion(location_or_hvo, parent_location_or_hvo)",
          "summary": "Set the parent region of a location (move it in the hierarchy).",
          "description": "Set the parent region of a location (move it in the hierarchy).\n",
          "parameters": [
            {
              "name": "location_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmLocation object or its HVO to move."
            },
            {
              "name": "parent_location_or_hvo",
              "type": "",
              "default": null,
              "description": "The new parent ICmLocation object or HVO, or None to make it top-level."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If location_or_hvo is None.",
            "FP_ParameterError: If trying to make a location its own parent,",
            "or creating circular hierarchy."
          ],
          "example": "            >>> # Move a location to a different region\n            >>> village = project.Location.Find(\"Barasana Village\")\n            >>> new_region = project.Location.Find(\"Vaups Department\")\n            >>> project.Location.SetRegion(village, new_region)\n\n            >>> # Make a location top-level\n            >>> project.Location.SetRegion(village, None)\n\n        Warning:\n            - Cannot make a location its own parent\n            - Cannot create circular hierarchies (A  B  A)\n            - Check for circular references before moving\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize LocationOperations with a FLExProject instance.",
          "description": "Initialize LocationOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ],
      "tags": [
        "notebook",
        "operations"
      ]
    },
    "NoteOperations": {
      "name": "NoteOperations",
      "type": "class",
      "namespace": "FlexLibs2.Notebook.NoteOperations",
      "source_file": "Notebook/NoteOperations",
      "category": "notebook",
      "summary": "This class provides operations for managing notes and comments in a\nFieldWorks project.",
      "description": "This class provides operations for managing notes and comments in a\nFieldWorks project.\n\nNotes in FLEx are annotations that can be attached to various objects\nincluding lexical entries, senses, texts, paragraphs, and more. Notes\nsupport threading (replies), categorization, metadata tracking, and\nmulti-lingual content.\n\nThis class should be accessed via FLExProject.Note property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a lexical entry\nentry = project.LexEntry.Find(\"run\")\n\n# Get all notes for the entry\nfor note in project.Note.GetAll(entry):\ncontent = project.Note.GetContent(note)\ndate = project.Note.GetDateCreated(note)\nprint(f\"Note: {content} (created {date})\")\n\n# Create a new note\nnote = project.Note.Create(entry, \"Review etymology\", \"en\")\n\n# Set note type\nproject.Note.SetNoteType(note, \"To Do\")\n\n# Add a reply\nreply = project.Note.AddReply(note, \"Checked - looks correct\", \"en\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddReply",
          "signature": "AddReply(parent_note, content, wsHandle=None)",
          "summary": "Add a reply to an existing note (threaded discussion).",
          "description": "Add a reply to an existing note (threaded discussion).\n",
          "parameters": [
            {
              "name": "parent_note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) to reply to."
            },
            {
              "name": "content",
              "type": "str",
              "default": null,
              "description": "The reply text content."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmBaseAnnotation: The newly created reply note. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If parent_note or content is None.",
            "FP_ParameterError: If content is empty."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> note = project.Note.Create(entry, \"Is this etymology correct?\")\n            >>> project.Note.SetAuthor(note, \"John\")\n            >>>\n            >>> # Add a reply\n            >>> reply = project.Note.AddReply(note, \"Yes, verified in source\")\n            >>> project.Note.SetAuthor(reply, \"Jane\")\n            >>>\n            >>> # Add a nested reply\n            >>> nested = project.Note.AddReply(reply, \"Thanks for checking!\")\n            >>> project.Note.SetAuthor(nested, \"John\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two notes and return detailed differences.",
          "description": "Compare two notes and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First note (from source project)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second note (from target project)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Operations instance for item1's project (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Operations instance for item2's project (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) where differences_dict contains 'properties' dict with changed property details ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(note1, note2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, details in diffs['properties'].items():\n            ...         print(f\"{prop}: {details['source']} -> {details['target']}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(owner_object, content, wsHandle=None)",
          "summary": "Create a new note attached to an object.",
          "description": "Create a new note attached to an object.\n",
          "parameters": [
            {
              "name": "owner_object",
              "type": "",
              "default": null,
              "description": "The object to attach the note to (entry, sense, etc.)."
            },
            {
              "name": "content",
              "type": "str",
              "default": null,
              "description": "The text content of the note."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmBaseAnnotation: The newly created note object. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If owner_object or content is None.",
            "FP_ParameterError: If content is empty."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> note = project.Note.Create(entry, \"Check etymology\", \"en\")\n            >>> print(project.Note.GetContent(note))\n            Check etymology\n\n            >>> # Create with specific writing system\n            >>> sense = entry.SensesOS[0]\n            >>> note = project.Note.Create(sense, \" vrifier\",\n            ...                             project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(note)",
          "summary": "Delete a note.",
          "description": "Delete a note.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If note is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"obsolete\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> if notes:\n            ...     project.Note.Delete(notes[0])\n\n        Warning:\n            - This is a destructive operation\n            - All replies to the note will also be deleted\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a note, creating a new copy with a new GUID.",
          "description": "Duplicate a note, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source note. If False, insert at end of owner's annotation list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate owned objects (replies). If False (default), only copy simple properties and references."
            }
          ],
          "returns": "ICmBaseAnnotation: The newly created duplicate note with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> if notes:\n            ...     # Shallow duplicate (no replies)\n            ...     dup = project.Note.Duplicate(notes[0])\n            ...     print(f\"Original: {project.Note.GetGuid(notes[0])}\")\n            ...     print(f\"Duplicate: {project.Note.GetGuid(dup)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n            ...\n            ...     # Deep duplicate (includes all replies)\n            ...     deep_dup = project.Note.Duplicate(notes[0], deep=True)\n            ...     print(f\"Replies: {len(list(project.Note.GetReplies(deep_dup)))}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(owner_object)",
          "summary": "Get all notes attached to an object.",
          "description": "Get all notes attached to an object.\n",
          "parameters": [
            {
              "name": "owner_object",
              "type": "",
              "default": null,
              "description": "The object whose notes to retrieve. Can be an ILexEntry, ILexSense, IText, IStPara, or any annotatable object."
            }
          ],
          "returns": "ICmBaseAnnotation: Each note/annotation attached to the object. ",
          "raises": [
            "FP_NullParameterError: If owner_object is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> for note in project.Note.GetAll(entry):\n            ...     content = project.Note.GetContent(note)\n            ...     print(f\"Note: {content}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAuthor",
          "signature": "GetAuthor(note)",
          "summary": "Get the author of a note.",
          "description": "Get the author of a note.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            }
          ],
          "returns": "str: The author name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If note is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> if notes:\n            ...     author = project.Note.GetAuthor(notes[0])\n            ...     if author:\n            ...         print(f\"Author: {author}\")\n            Author: John Smith\n\n            >>> # Filter notes by author\n            >>> john_notes = [n for n in notes\n            ...     if project.Note.GetAuthor(n) == \"John Smith\"]\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetContent",
          "signature": "GetContent(note, wsHandle=None)",
          "summary": "Get the text content of a note.",
          "description": "Get the text content of a note.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The note content, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If note is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> if notes:\n            ...     content = project.Note.GetContent(notes[0])\n            ...     print(content)\n            Check etymology source\n\n            >>> # Get in specific writing system\n            >>> content_fr = project.Note.GetContent(notes[0],\n            ...                                       project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(note)",
          "summary": "Get the creation date of a note.",
          "description": "Get the creation date of a note.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            }
          ],
          "returns": "System.DateTime: The creation date/time, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If note is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> if notes:\n            ...     date = project.Note.GetDateCreated(notes[0])\n            ...     print(f\"Created: {date}\")\n            Created: 11/23/2025 10:30:45 AM\n\n            >>> # Sort notes by creation date\n            >>> sorted_notes = sorted(notes,\n            ...     key=lambda n: project.Note.GetDateCreated(n) or DateTime.MinValue)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified(note)",
          "summary": "Get the last modification date of a note.",
          "description": "Get the last modification date of a note.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            }
          ],
          "returns": "System.DateTime: The modification date/time, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If note is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> if notes:\n            ...     modified = project.Note.GetDateModified(notes[0])\n            ...     if modified:\n            ...         print(f\"Last modified: {modified}\")\n            Last modified: 11/23/2025 2:15:30 PM\n\n            >>> # Find recently modified notes\n            >>> from System import DateTime\n            >>> one_week_ago = DateTime.Now.AddDays(-7)\n            >>> recent = [n for n in notes\n            ...     if project.Note.GetDateModified(n) and\n            ...        project.Note.GetDateModified(n) > one_week_ago]\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(note)",
          "summary": "Get the GUID of a note.",
          "description": "Get the GUID of a note.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            }
          ],
          "returns": "System.Guid: The GUID of the note. ",
          "raises": [
            "FP_NullParameterError: If note is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> note = project.Note.Create(entry, \"Important note\")\n            >>> guid = project.Note.GetGuid(note)\n            >>> print(f\"Note GUID: {guid}\")\n            Note GUID: 12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetNoteType",
          "signature": "GetNoteType(note)",
          "summary": "Get the note type/category.",
          "description": "Get the note type/category.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            }
          ],
          "returns": "ICmAnnotationDefn: The annotation definition (note type), or None. ",
          "raises": [
            "FP_NullParameterError: If note is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> if notes:\n            ...     note_type = project.Note.GetNoteType(notes[0])\n            ...     if note_type:\n            ...         # Get the name of the note type\n            ...         ws = project.project.DefaultAnalWs\n            ...         type_name = ITsString(note_type.Name.get_String(ws)).Text\n            ...         print(f\"Note type: {type_name}\")\n            Note type: To Do\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwner",
          "signature": "GetOwner(note)",
          "summary": "Get the owner object that the note is attached to.",
          "description": "Get the owner object that the note is attached to.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            }
          ],
          "returns": "object: The owner object (ILexEntry, ILexSense, etc.), or None. ",
          "raises": [
            "FP_NullParameterError: If note is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> note = project.Note.Create(entry, \"Check this\")\n            >>> owner = project.Note.GetOwner(note)\n            >>> print(owner == entry)\n            True\n\n            >>> # Get headword of entry that owns the note\n            >>> if hasattr(owner, 'LexemeFormOA'):\n            ...     headword = project.LexEntry.GetHeadword(owner)\n            ...     print(f\"Note on entry: {headword}\")\n            Note on entry: run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetReplies",
          "signature": "GetReplies(note)",
          "summary": "Get all reply notes (threaded discussion) for a note.",
          "description": "Get all reply notes (threaded discussion) for a note.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            }
          ],
          "returns": "ICmBaseAnnotation: Each reply note. ",
          "raises": [
            "FP_NullParameterError: If note is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> if notes:\n            ...     parent = notes[0]\n            ...     print(f\"Parent: {project.Note.GetContent(parent)}\")\n            ...     for reply in project.Note.GetReplies(parent):\n            ...         content = project.Note.GetContent(reply)\n            ...         author = project.Note.GetAuthor(reply)\n            ...         print(f\"  Reply by {author}: {content}\")\n            Parent: Check etymology\n              Reply by Jane: Looks correct to me\n              Reply by John: Agreed, verified in source\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.\n\nReturns all syncable properties of a note including MultiString fields\nand reference properties.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object"
            }
          ],
          "returns": "dict: Dictionary of syncable properties ",
          "raises": [],
          "example": "            >>> props = project.Note.GetSyncableProperties(note)\n            >>> print(props)\n            {'Comment': 'Check this', 'Source': 'John', 'AnnotationType': '...'}",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Reorder",
          "signature": "Reorder(owner_object, note_list)",
          "summary": "Reorder notes for an object.",
          "description": "Reorder notes for an object.\n",
          "parameters": [
            {
              "name": "owner_object",
              "type": "",
              "default": null,
              "description": "The object whose notes to reorder."
            },
            {
              "name": "note_list",
              "type": "list",
              "default": null,
              "description": "List of note objects in desired order."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If owner_object or note_list is None.",
            "FP_ParameterError: If note_list contains notes not owned by object."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> # Reverse the order\n            >>> notes.reverse()\n            >>> project.Note.Reorder(entry, notes)\n\n            >>> # Sort by date created\n            >>> notes.sort(key=lambda n: project.Note.GetDateCreated(n))\n            >>> project.Note.Reorder(entry, notes)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAuthor",
          "signature": "SetAuthor(note, author_name)",
          "summary": "Set the author of a note.",
          "description": "Set the author of a note.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            },
            {
              "name": "author_name",
              "type": "str",
              "default": null,
              "description": "The author name to set."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If note or author_name is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> note = project.Note.Create(entry, \"Review needed\")\n            >>> project.Note.SetAuthor(note, \"John Smith\")\n            >>> print(project.Note.GetAuthor(note))\n            John Smith\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetContent",
          "signature": "SetContent(note, text, wsHandle=None)",
          "summary": "Set the text content of a note.",
          "description": "Set the text content of a note.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new note content."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If note or text is None."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> notes = list(project.Note.GetAll(entry))\n            >>> if notes:\n            ...     project.Note.SetContent(notes[0], \"Etymology verified\")\n            ...     print(project.Note.GetContent(notes[0]))\n            Etymology verified\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetNoteType",
          "signature": "SetNoteType(note, note_type)",
          "summary": "Set the note type/category.",
          "description": "Set the note type/category.\n",
          "parameters": [
            {
              "name": "note",
              "type": "",
              "default": null,
              "description": "The ICmBaseAnnotation (note) object."
            },
            {
              "name": "note_type",
              "type": "",
              "default": null,
              "description": "Either a string name or ICmAnnotationDefn object."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If note is None.",
            "FP_ParameterError: If note_type string not found."
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> note = project.Note.Create(entry, \"Check this later\")\n            >>> project.Note.SetNoteType(note, \"To Do\")\n\n            >>> # Using annotation definition object\n            >>> anno_defn = project.Note.GetNoteType(existing_note)\n            >>> if anno_defn:\n            ...     project.Note.SetNoteType(new_note, anno_defn)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize NoteOperations with a FLExProject instance.",
          "description": "Initialize NoteOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "notebook",
        "operations"
      ]
    },
    "PersonOperations": {
      "name": "PersonOperations",
      "type": "class",
      "namespace": "FlexLibs2.Notebook.PersonOperations",
      "source_file": "Notebook/PersonOperations",
      "category": "notebook",
      "summary": "This class provides operations for managing people (consultants, speakers,\nresearchers) in a FieldWorks project.",
      "description": "This class provides operations for managing people (consultants, speakers,\nresearchers) in a FieldWorks project.\n\nPeople are stored as ICmPerson objects and can represent consultants,\nnative speakers, researchers, or any other individuals associated with\nthe linguistic data collection and analysis.\n\nThis class should be accessed via FLExProject.Person property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all people\nfor person in project.Person.GetAll():\nname = project.Person.GetName(person)\nprint(name)\n\n# Create a new person\nperson = project.Person.Create(\"John Smith\")\n\n# Set properties\nproject.Person.SetEmail(person, \"john.smith@example.com\")\nproject.Person.SetDateOfBirth(person, \"1985-03-15\")\nproject.Person.SetGender(person, \"Male\")\n\n# Add contact information\nproject.Person.SetPhone(person, \"+1-555-123-4567\")\nproject.Person.SetAddress(person, \"123 Main St, City, Country\")\n\n# Add notes\nproject.Person.AddNote(person, \"Primary consultant for dialect study\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddLanguage",
          "signature": "AddLanguage(person_or_hvo, language)",
          "summary": "Add a language to a person's known languages.",
          "description": "Add a language to a person's known languages.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "language",
              "type": "",
              "default": null,
              "description": "ICmPossibility object representing the language"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or language is None",
            "FP_ParameterError: If language is not a valid ICmPossibility"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> # Get language from project's languages list\n            >>> languages_list = project.lp.LanguagesOA\n            >>> if languages_list:\n            ...     spanish = languages_list.PossibilitiesOS[0]\n            ...     project.Person.AddLanguage(person, spanish)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddNote",
          "signature": "AddNote(person_or_hvo, note, wsHandle=None)",
          "summary": "Add a note to a person (appends to existing notes).",
          "description": "Add a note to a person (appends to existing notes).\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "note",
              "type": "str",
              "default": null,
              "description": "Note text to add"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or note is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> project.Person.AddNote(person, \"Primary consultant\")\n            >>> project.Person.AddNote(person, \"Available weekdays\")\n            >>> print(project.Person.GetNotes(person))\n            Primary consultant\n            Available weekdays\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddPosition",
          "signature": "AddPosition(person_or_hvo, position)",
          "summary": "Add a position/role to a person.",
          "description": "Add a position/role to a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "position",
              "type": "",
              "default": null,
              "description": "ICmPossibility object representing the position"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or position is None",
            "FP_ParameterError: If position is not a valid ICmPossibility"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> # Get position from project's positions list\n            >>> positions_list = project.lp.PositionsOA\n            >>> if positions_list:\n            ...     consultant_pos = positions_list.PossibilitiesOS[0]\n            ...     project.Person.AddPosition(person, consultant_pos)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "AddResidence",
          "signature": "AddResidence(person_or_hvo, location)",
          "summary": "Add a place of residence to a person.",
          "description": "Add a place of residence to a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "location",
              "type": "",
              "default": null,
              "description": "ICmLocation object representing the residence"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or location is None",
            "FP_ParameterError: If location is not a valid ICmLocation"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> # Assuming location was created elsewhere\n            >>> # location = ...\n            >>> # project.Person.AddResidence(person, location)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two persons and return detailed differences.",
          "description": "Compare two persons and return detailed differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First person (from source project)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second person (from target project)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Operations instance for item1's project (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Operations instance for item2's project (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) where differences_dict contains 'properties' dict with changed property details ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(person1, person2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, details in diffs['properties'].items():\n            ...         print(f\"{prop}: {details['source']} -> {details['target']}\")",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, wsHandle=None)",
          "summary": "Create a new person in the FLEx project.",
          "description": "Create a new person in the FLEx project.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The full name of the person"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "ICmPerson: The newly created person object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> # Create a basic person\n            >>> person = project.Person.Create(\"John Smith\")\n            >>> print(project.Person.GetName(person))\n            John Smith\n\n            >>> # Create with specific writing system\n            >>> person = project.Person.Create(\"Mara Garca\",\n            ...                                 project.WSHandle('es'))\n\n            >>> # Create and set additional properties\n            >>> consultant = project.Person.Create(\"Ahmed Hassan\")\n            >>> project.Person.SetEmail(consultant, \"ahmed@example.com\")\n            >>> project.Person.SetGender(consultant, \"Male\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(person_or_hvo)",
          "summary": "Delete a person from the FLEx project.",
          "description": "Delete a person from the FLEx project.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO (database ID)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo is None",
            "FP_ParameterError: If person doesn't exist"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> if person:\n            ...     project.Person.Delete(person)\n\n            >>> # Delete by HVO\n            >>> project.Person.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - All associated data (positions, notes, etc.) will be deleted\n            - References from texts or lexical entries may become invalid\n            - Cannot be undone\n            - Person will be removed from all linked records\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(person_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a person, creating a new copy with a new GUID.",
          "description": "Duplicate a person, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPerson object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source person. If False, insert at end of people collection."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "Reserved for future use (persons have no owned objects). Currently has no effect."
            }
          ],
          "returns": "ICmPerson: The newly created duplicate person with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If person_or_hvo is None."
          ],
          "example": "            >>> # Duplicate a person\n            >>> person = project.Person.Find(\"John Smith\")\n            >>> dup = project.Person.Duplicate(person)\n            >>> print(f\"Original: {project.Person.GetGuid(person)}\")\n            >>> print(f\"Duplicate: {project.Person.GetGuid(dup)}\")\n            Original: 12345678-1234-1234-1234-123456789abc\n            Duplicate: 87654321-4321-4321-4321-cba987654321\n\n            >>> # Verify properties copied\n            >>> print(project.Person.GetEmail(dup))\n            john.smith@example.com\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name, wsHandle=None)",
          "summary": "Check if a person with the given name exists.",
          "description": "Check if a person with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "bool: True if a person exists with this name, False otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> if not project.Person.Exists(\"John Smith\"):\n            ...     person = project.Person.Create(\"John Smith\")\n\n            >>> # Check in specific writing system\n            >>> if project.Person.Exists(\"Mara Garca\", project.WSHandle('es')):\n            ...     print(\"Spanish name exists\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name, wsHandle=None)",
          "summary": "Find a person by name.",
          "description": "Find a person by name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "ICmPerson or None: The person object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> if person:\n            ...     email = project.Person.GetEmail(person)\n            ...     print(f\"Found: {email}\")\n            Found: john.smith@example.com\n\n            >>> # Search in specific writing system\n            >>> person = project.Person.Find(\"Mara Garca\",\n            ...                               project.WSHandle('es'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAddress",
          "signature": "GetAddress(person_or_hvo, wsHandle=None)",
          "summary": "Get the address of a person.",
          "description": "Get the address of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: Address (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> address = project.Person.GetAddress(person)\n            >>> print(address)\n            123 Main St, City, Country\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all people in the project.",
          "description": "Get all people in the project.\n\nThis method returns an iterator over all ICmPerson objects in the\nproject database, allowing iteration over all registered people.\n",
          "parameters": [],
          "returns": "ICmPerson: Each person object in the project ",
          "raises": [],
          "example": "            >>> for person in project.Person.GetAll():\n            ...     name = project.Person.GetName(person)\n            ...     email = project.Person.GetEmail(person)\n            ...     print(f\"{name}: {email}\")\n            John Smith: john.smith@example.com\n            Maria Garcia: maria.garcia@example.com\n            Ahmed Hassan: ahmed.hassan@example.com\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(person_or_hvo)",
          "summary": "Get the creation date of a person record.",
          "description": "Get the creation date of a person record.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            }
          ],
          "returns": "System.DateTime: The date and time the person record was created ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> created = project.Person.GetDateCreated(person)\n            >>> print(f\"Created: {created}\")\n            Created: 2025-01-15 14:30:22\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified(person_or_hvo)",
          "summary": "Get the last modification date of a person record.",
          "description": "Get the last modification date of a person record.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            }
          ],
          "returns": "System.DateTime: The date and time the person record was last modified ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> modified = project.Person.GetDateModified(person)\n            >>> print(f\"Last modified: {modified}\")\n            Last modified: 2025-01-20 09:15:43\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateOfBirth",
          "signature": "GetDateOfBirth(person_or_hvo)",
          "summary": "Get the date of birth of a person.",
          "description": "Get the date of birth of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            }
          ],
          "returns": "str: Date of birth as string (empty if not set) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> dob = project.Person.GetDateOfBirth(person)\n            >>> print(dob)\n            1985-03-15\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEducation",
          "signature": "GetEducation(person_or_hvo, wsHandle=None)",
          "summary": "Get the education information of a person.",
          "description": "Get the education information of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: Education information (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> education = project.Person.GetEducation(person)\n            >>> print(education)\n            PhD Linguistics, University of Example, 2010\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEmail",
          "signature": "GetEmail(person_or_hvo, wsHandle=None)",
          "summary": "Get the email address of a person.",
          "description": "Get the email address of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: Email address (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> email = project.Person.GetEmail(person)\n            >>> print(email)\n            john.smith@example.com\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGender",
          "signature": "GetGender(person_or_hvo, wsHandle=None)",
          "summary": "Get the gender of a person.",
          "description": "Get the gender of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The gender (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> gender = project.Person.GetGender(person)\n            >>> print(gender)\n            Male\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(person_or_hvo)",
          "summary": "Get the GUID (Globally Unique Identifier) of a person.",
          "description": "Get the GUID (Globally Unique Identifier) of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            }
          ],
          "returns": "System.Guid: The person's GUID ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> guid = project.Person.GetGuid(person)\n            >>> print(guid)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\n            >>> # Use GUID to retrieve person later\n            >>> person2 = project.Object(guid)\n            >>> print(project.Person.GetName(person2))\n            John Smith\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLanguages",
          "signature": "GetLanguages(person_or_hvo)",
          "summary": "Get the languages known by a person.",
          "description": "Get the languages known by a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            }
          ],
          "returns": "list: List of ICmPossibility objects representing languages (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> languages = project.Person.GetLanguages(person)\n            >>> for lang in languages:\n            ...     name = ITsString(lang.Name.BestAnalysisAlternative).Text\n            ...     print(f\"Language: {name}\")\n            Language: English\n            Language: Spanish\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(person_or_hvo, wsHandle=None)",
          "summary": "Get the name of a person.",
          "description": "Get the name of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The person's name (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> name = project.Person.GetName(person)\n            >>> print(name)\n            John Smith\n\n            >>> # Get in specific writing system\n            >>> name_es = project.Person.GetName(person, project.WSHandle('es'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetNotes",
          "signature": "GetNotes(person_or_hvo, wsHandle=None)",
          "summary": "Get the notes for a person.",
          "description": "Get the notes for a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: Notes text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> notes = project.Person.GetNotes(person)\n            >>> print(notes)\n            Primary consultant for dialect study. Available weekdays.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPhone",
          "signature": "GetPhone(person_or_hvo, wsHandle=None)",
          "summary": "Get the phone number of a person.",
          "description": "Get the phone number of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: Phone number (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> phone = project.Person.GetPhone(person)\n            >>> print(phone)\n            +1-555-123-4567\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPositions",
          "signature": "GetPositions(person_or_hvo)",
          "summary": "Get the positions/roles associated with a person.",
          "description": "Get the positions/roles associated with a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            }
          ],
          "returns": "list: List of ICmPossibility objects representing positions (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> positions = project.Person.GetPositions(person)\n            >>> for pos in positions:\n            ...     name = ITsString(pos.Name.BestAnalysisAlternative).Text\n            ...     print(f\"Position: {name}\")\n            Position: Consultant\n            Position: Native Speaker\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetResidences",
          "signature": "GetResidences(person_or_hvo)",
          "summary": "Get the places of residence for a person.",
          "description": "Get the places of residence for a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            }
          ],
          "returns": "list: List of ICmLocation objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If person_or_hvo is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> residences = project.Person.GetResidences(person)\n            >>> for loc in residences:\n            ...     name = ITsString(loc.Name.BestAnalysisAlternative).Text\n            ...     print(f\"Residence: {name}\")\n            Residence: New York, USA\n            Residence: London, UK\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.\n\nReturns all syncable properties of a person including MultiString fields\nand reference collections (as GUIDs).\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmPerson object"
            }
          ],
          "returns": "dict: Dictionary of syncable properties ",
          "raises": [],
          "example": "            >>> props = project.Person.GetSyncableProperties(person)\n            >>> print(props)\n            {'Name': 'John Smith', 'Gender': 'Male', 'Email': 'john@...', ...}",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetAddress",
          "signature": "SetAddress(person_or_hvo, address, wsHandle=None)",
          "summary": "Set the address of a person.",
          "description": "Set the address of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "address",
              "type": "str",
              "default": null,
              "description": "Address to set"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or address is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> project.Person.SetAddress(person,\n            ...     \"123 Main St\\nCity, State 12345\\nCountry\")\n\n            >>> # Clear address\n            >>> project.Person.SetAddress(person, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDateOfBirth",
          "signature": "SetDateOfBirth(person_or_hvo, date_str)",
          "summary": "Set the date of birth of a person.",
          "description": "Set the date of birth of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "date_str",
              "type": "str",
              "default": null,
              "description": "Date of birth as string (e.g., \"1985-03-15\")"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or date_str is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> project.Person.SetDateOfBirth(person, \"1985-03-15\")\n\n            >>> # Clear date\n            >>> project.Person.SetDateOfBirth(person, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetEducation",
          "signature": "SetEducation(person_or_hvo, education, wsHandle=None)",
          "summary": "Set the education information of a person.",
          "description": "Set the education information of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "education",
              "type": "str",
              "default": null,
              "description": "Education information to set"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or education is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> project.Person.SetEducation(person,\n            ...     \"PhD Linguistics, University of Example, 2010\\n\"\n            ...     \"MA Anthropology, State University, 2005\")\n\n            >>> # Clear education\n            >>> project.Person.SetEducation(person, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetEmail",
          "signature": "SetEmail(person_or_hvo, email, wsHandle=None)",
          "summary": "Set the email address of a person.",
          "description": "Set the email address of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "email",
              "type": "str",
              "default": null,
              "description": "Email address to set"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or email is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> project.Person.SetEmail(person, \"john.smith@example.com\")\n\n            >>> # Multiple emails\n            >>> project.Person.SetEmail(person,\n            ...     \"john.smith@example.com, j.smith@work.org\")\n\n            >>> # Clear email\n            >>> project.Person.SetEmail(person, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetGender",
          "signature": "SetGender(person_or_hvo, gender, wsHandle=None)",
          "summary": "Set the gender of a person.",
          "description": "Set the gender of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "gender",
              "type": "str",
              "default": null,
              "description": "The gender to set"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or gender is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> project.Person.SetGender(person, \"Male\")\n\n            >>> # Clear gender\n            >>> project.Person.SetGender(person, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(person_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a person.",
          "description": "Set the name of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> project.Person.SetName(person, \"John Robert Smith\")\n            >>> print(project.Person.GetName(person))\n            John Robert Smith\n\n            >>> # Set in specific writing system\n            >>> project.Person.SetName(person, \"Juan Smith\",\n            ...                         project.WSHandle('es'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetPhone",
          "signature": "SetPhone(person_or_hvo, phone, wsHandle=None)",
          "summary": "Set the phone number of a person.",
          "description": "Set the phone number of a person.\n",
          "parameters": [
            {
              "name": "person_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPerson object or its HVO"
            },
            {
              "name": "phone",
              "type": "str",
              "default": null,
              "description": "Phone number to set"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If person_or_hvo or phone is None"
          ],
          "example": "            >>> person = project.Person.Find(\"John Smith\")\n            >>> project.Person.SetPhone(person, \"+1-555-123-4567\")\n\n            >>> # Multiple numbers\n            >>> project.Person.SetPhone(person,\n            ...     \"Mobile: +1-555-123-4567, Office: +1-555-890-1234\")\n\n            >>> # Clear phone\n            >>> project.Person.SetPhone(person, \"\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize PersonOperations with a FLExProject instance.",
          "description": "Initialize PersonOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "notebook",
        "operations"
      ]
    },
    "ReversalIndexEntryOperations": {
      "name": "ReversalIndexEntryOperations",
      "type": "class",
      "namespace": "FlexLibs2.Reversal.ReversalIndexEntryOperations",
      "source_file": "Reversal/ReversalIndexEntryOperations",
      "category": "reversal",
      "summary": "This class provides operations for managing reversal index entries in a FieldWorks project.",
      "description": "This class provides operations for managing reversal index entries in a FieldWorks project.\n\nReversal index entries are the individual entries within a reversal index. Each entry\nhas a form (the reverse headword) and links to one or more lexical senses. Entries can\nbe organized hierarchically with subentries.\n\nReversal entries enable users to look up words in the analysis language and find\ncorresponding vernacular entries.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get reversal index\nen_ws = project.WSHandle('en')\nidx = project.ReversalIndexes.FindByWritingSystem(en_ws)\n\n# Create reversal entry\nentry = project.ReversalEntries.Create(idx, \"run\")\n\n# Link to lexical sense\nlex_entry = list(project.LexiconAllEntries())[0]\nsense = list(lex_entry.SensesOS)[0]\nproject.ReversalEntries.AddSense(entry, sense)\n\n# Get all entries\nfor rev_entry in project.ReversalEntries.GetAll(idx):\nform = project.ReversalEntries.GetForm(rev_entry)\nprint(f\"Reversal: {form}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddSense",
          "signature": "AddSense(entry_or_hvo, sense)",
          "summary": "Link a lexical sense to this reversal entry.",
          "description": "Link a lexical sense to this reversal entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndexEntry object or its HVO"
            },
            {
              "name": "sense",
              "type": "",
              "default": null,
              "description": "ILexSense object to link"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or sense is None"
          ],
          "example": "            >>> entry = project.ReversalEntries.Find(idx, \"run\")\n            >>> lex_entry = project.LexEntry.Find(\"hlauka\")\n            >>> sense = list(lex_entry.SensesOS)[0]\n            >>> project.ReversalEntries.AddSense(entry, sense)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(index_or_hvo, form, sense=None, wsHandle=None)",
          "summary": "Create a new reversal index entry.",
          "description": "Create a new reversal index entry.\n",
          "parameters": [
            {
              "name": "index_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndex object or its HVO"
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The reversal form (headword in analysis language)"
            },
            {
              "name": "sense",
              "type": "",
              "default": null,
              "description": "Optional ILexSense object to link to"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to index's WS."
            }
          ],
          "returns": "IReversalIndexEntry: The newly created reversal entry ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If index_or_hvo or form is None",
            "FP_ParameterError: If form is empty"
          ],
          "example": "            >>> idx = project.ReversalIndexes.Find(\"English\")\n            >>> entry = project.ReversalEntries.Create(idx, \"run\")\n            >>> print(project.ReversalEntries.GetForm(entry))\n            run\n\n            >>> # Create with linked sense\n            >>> lex_entry = project.LexEntry.Find(\"hlauka\")\n            >>> sense = list(lex_entry.SensesOS)[0]\n            >>> entry = project.ReversalEntries.Create(idx, \"run\", sense)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(entry_or_hvo)",
          "summary": "Delete a reversal index entry.",
          "description": "Delete a reversal index entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndexEntry object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.ReversalEntries.Find(idx, \"obsolete\")\n            >>> if entry:\n            ...     project.ReversalEntries.Delete(entry)\n\n        Warning:\n            - This is a destructive operation\n            - All subentries will be deleted\n            - Links to lexical senses will be removed\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(index_or_hvo, form, wsHandle=None)",
          "summary": "Find a reversal entry by its form.",
          "description": "Find a reversal entry by its form.\n",
          "parameters": [
            {
              "name": "index_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndex object or its HVO"
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The reversal form to search for"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to index's WS."
            }
          ],
          "returns": "IReversalIndexEntry or None: The entry object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If index_or_hvo or form is None"
          ],
          "example": "            >>> idx = project.ReversalIndexes.Find(\"English\")\n            >>> entry = project.ReversalEntries.Find(idx, \"run\")\n            >>> if entry:\n            ...     senses = list(project.ReversalEntries.GetSenses(entry))\n            ...     print(f\"Found 'run' with {len(senses)} senses\")\n            Found 'run' with 3 senses\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByHvo",
          "signature": "FindByHvo(hvo)",
          "summary": "Find a reversal entry by its HVO (database ID).",
          "description": "Find a reversal entry by its HVO (database ID).\n",
          "parameters": [
            {
              "name": "hvo",
              "type": "int",
              "default": null,
              "description": "The HVO of the reversal entry"
            }
          ],
          "returns": "IReversalIndexEntry or None: The entry object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If hvo is None"
          ],
          "example": "            >>> entry = project.ReversalEntries.FindByHvo(12345)\n            >>> if entry:\n            ...     form = project.ReversalEntries.GetForm(entry)\n            ...     print(f\"Found entry: {form}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(index_or_hvo)",
          "summary": "Get all reversal entries in a reversal index.",
          "description": "Get all reversal entries in a reversal index.\n",
          "parameters": [
            {
              "name": "index_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndex object or its HVO"
            }
          ],
          "returns": "IReversalIndexEntry: Each reversal entry in the index ",
          "raises": [
            "FP_NullParameterError: If index_or_hvo is None"
          ],
          "example": "            >>> idx = project.ReversalIndexes.Find(\"English\")\n            >>> for entry in project.ReversalEntries.GetAll(idx):\n            ...     form = project.ReversalEntries.GetForm(entry)\n            ...     sense_count = len(list(project.ReversalEntries.GetSenses(entry)))\n            ...     print(f\"{form}: {sense_count} senses\")\n            run: 3 senses\n            walk: 2 senses\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(entry_or_hvo, wsHandle=None)",
          "summary": "Get the reversal form of a reversal entry.",
          "description": "Get the reversal form of a reversal entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndexEntry object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to entry's index WS."
            }
          ],
          "returns": "str: The reversal form text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.ReversalEntries.Find(idx, \"run\")\n            >>> form = project.ReversalEntries.GetForm(entry)\n            >>> print(form)\n            run\n\n        See Also:\n            SetForm, Find",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSenses",
          "signature": "GetSenses(entry_or_hvo)",
          "summary": "Get all lexical senses linked to this reversal entry.",
          "description": "Get all lexical senses linked to this reversal entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndexEntry object or its HVO"
            }
          ],
          "returns": "list: List of ILexSense objects ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.ReversalEntries.Find(idx, \"run\")\n            >>> senses = project.ReversalEntries.GetSenses(entry)\n            >>> for sense in senses:\n            ...     gloss = project.Senses.GetGloss(sense)\n            ...     print(f\"Linked sense: {gloss}\")\n            Linked sense: to move rapidly\n            Linked sense: to flow\n            Linked sense: to operate\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSubentries",
          "signature": "GetSubentries(entry_or_hvo)",
          "summary": "Get all subentries of a reversal entry.",
          "description": "Get all subentries of a reversal entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndexEntry object or its HVO"
            }
          ],
          "returns": "list: List of IReversalIndexEntry objects (subentries) ",
          "raises": [
            "FP_NullParameterError: If entry_or_hvo is None"
          ],
          "example": "            >>> entry = project.ReversalEntries.Find(idx, \"run\")\n            >>> subentries = project.ReversalEntries.GetSubentries(entry)\n            >>> for sub in subentries:\n            ...     form = project.ReversalEntries.GetForm(sub)\n            ...     print(f\"Subentry: {form}\")\n            Subentry: run away\n            Subentry: run out\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveSense",
          "signature": "RemoveSense(entry_or_hvo, sense)",
          "summary": "Unlink a lexical sense from this reversal entry.",
          "description": "Unlink a lexical sense from this reversal entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndexEntry object or its HVO"
            },
            {
              "name": "sense",
              "type": "",
              "default": null,
              "description": "ILexSense object to unlink"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or sense is None"
          ],
          "example": "            >>> entry = project.ReversalEntries.Find(idx, \"run\")\n            >>> sense = list(project.ReversalEntries.GetSenses(entry))[0]\n            >>> project.ReversalEntries.RemoveSense(entry, sense)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetForm",
          "signature": "SetForm(entry_or_hvo, text, wsHandle=None)",
          "summary": "Set the reversal form of a reversal entry.",
          "description": "Set the reversal form of a reversal entry.\n",
          "parameters": [
            {
              "name": "entry_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndexEntry object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new reversal form text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to entry's index WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If entry_or_hvo or text is None",
            "FP_ParameterError: If text is empty"
          ],
          "example": "            >>> entry = project.ReversalEntries.Find(idx, \"run\")\n            >>> project.ReversalEntries.SetForm(entry, \"running\")\n            >>> print(project.ReversalEntries.GetForm(entry))\n            running\n\n        See Also:\n            GetForm",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ReversalIndexEntryOperations with a FLExProject instance.",
          "description": "Initialize ReversalIndexEntryOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "reversal",
        "operations"
      ]
    },
    "ReversalIndexOperations": {
      "name": "ReversalIndexOperations",
      "type": "class",
      "namespace": "FlexLibs2.Reversal.ReversalIndexOperations",
      "source_file": "Reversal/ReversalIndexOperations",
      "category": "reversal",
      "summary": "This class provides operations for managing reversal indexes in a FieldWorks project.",
      "description": "This class provides operations for managing reversal indexes in a FieldWorks project.\n\nReversal indexes provide reverse dictionaries for analysis languages (e.g., English\nto vernacular). Each index is tied to a specific writing system and contains reversal\nentries that link back to lexical senses.\n\nThis is a core dictionary feature with LIFT import/export capabilities (753 occurrences\nin codebase).\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Create a reversal index\nen_ws = project.WSHandle('en')\nrev_index = project.ReversalIndexes.Create(\"English\", en_ws)\n\n# Get all reversal indexes\nfor idx in project.ReversalIndexes.GetAll():\nname = project.ReversalIndexes.GetName(idx)\nprint(f\"Reversal Index: {name}\")\n\n# Find by writing system\nidx = project.ReversalIndexes.FindByWritingSystem(en_ws)\n\n# Get entries\nentries = project.ReversalIndexes.GetEntries(idx)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(name, writing_system)",
          "summary": "Create a new reversal index for an analysis writing system.",
          "description": "Create a new reversal index for an analysis writing system.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "Name for the reversal index (e.g., \"English\", \"French\")"
            },
            {
              "name": "writing_system",
              "type": "",
              "default": null,
              "description": "Writing system handle (must be analysis WS)"
            }
          ],
          "returns": "IReversalIndex: The newly created reversal index ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If name or writing_system is None",
            "FP_ParameterError: If name is empty or index already exists for WS"
          ],
          "example": "            >>> # Create English reversal index\n            >>> en_ws = project.WSHandle('en')\n            >>> rev_index = project.ReversalIndexes.Create(\"English\", en_ws)\n            >>> print(project.ReversalIndexes.GetName(rev_index))\n            English\n\n            >>> # Create French reversal index\n            >>> fr_ws = project.WSHandle('fr')\n            >>> rev_index = project.ReversalIndexes.Create(\"French\", fr_ws)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(index_or_hvo)",
          "summary": "Delete a reversal index from the project.",
          "description": "Delete a reversal index from the project.\n",
          "parameters": [
            {
              "name": "index_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndex object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If index_or_hvo is None",
            "FP_ParameterError: If index doesn't exist"
          ],
          "example": "            >>> idx = project.ReversalIndexes.Find(\"French\")\n            >>> if idx:\n            ...     project.ReversalIndexes.Delete(idx)\n\n        Warning:\n            - This is a destructive operation\n            - All reversal entries in the index will be deleted\n            - Links to lexical senses will be removed\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ExportToLIFT",
          "signature": "ExportToLIFT(index_or_hvo, path)",
          "summary": "Export a reversal index to LIFT format.",
          "description": "Export a reversal index to LIFT format.\n",
          "parameters": [
            {
              "name": "index_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndex object or its HVO"
            },
            {
              "name": "path",
              "type": "str",
              "default": null,
              "description": "File path for the exported LIFT file"
            }
          ],
          "returns": "",
          "raises": [
            "FP_NullParameterError: If index_or_hvo or path is None",
            "FP_ParameterError: If path is invalid or index has no entries"
          ],
          "example": "            >>> idx = project.ReversalIndexes.Find(\"English\")\n            >>> project.ReversalIndexes.ExportToLIFT(idx, \"english_reversal.lift\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find a reversal index by its name.",
          "description": "Find a reversal index by its name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The reversal index name to search for"
            }
          ],
          "returns": "IReversalIndex or None: The index object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> idx = project.ReversalIndexes.Find(\"English\")\n            >>> if idx:\n            ...     entries = list(project.ReversalIndexes.GetEntries(idx))\n            ...     print(f\"English index has {len(entries)} entries\")\n            English index has 250 entries\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByWritingSystem",
          "signature": "FindByWritingSystem(ws)",
          "summary": "Find a reversal index by its writing system.",
          "description": "Find a reversal index by its writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "Writing system handle or string identifier"
            }
          ],
          "returns": "IReversalIndex or None: The index object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If ws is None"
          ],
          "example": "            >>> en_ws = project.WSHandle('en')\n            >>> idx = project.ReversalIndexes.FindByWritingSystem(en_ws)\n            >>> if idx:\n            ...     name = project.ReversalIndexes.GetName(idx)\n            ...     print(f\"Found reversal index: {name}\")\n            Found reversal index: English\n\n            >>> # Can also use string identifier\n            >>> idx = project.ReversalIndexes.FindByWritingSystem('en')\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all reversal indexes in the project.",
          "description": "Get all reversal indexes in the project.\n",
          "parameters": [],
          "returns": "IReversalIndex: Each reversal index object in the project ",
          "raises": [],
          "example": "            >>> for idx in project.ReversalIndexes.GetAll():\n            ...     name = project.ReversalIndexes.GetName(idx)\n            ...     ws = project.ReversalIndexes.GetWritingSystem(idx)\n            ...     entry_count = len(list(project.ReversalIndexes.GetEntries(idx)))\n            ...     print(f\"{name} ({ws}): {entry_count} entries\")\n            English (en): 250 entries\n            French (fr): 120 entries\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEntries",
          "signature": "GetEntries(index_or_hvo)",
          "summary": "Get all reversal entries in a reversal index.",
          "description": "Get all reversal entries in a reversal index.\n",
          "parameters": [
            {
              "name": "index_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndex object or its HVO"
            }
          ],
          "returns": "IReversalIndexEntry: Each reversal entry in the index ",
          "raises": [
            "FP_NullParameterError: If index_or_hvo is None"
          ],
          "example": "            >>> idx = project.ReversalIndexes.Find(\"English\")\n            >>> for entry in project.ReversalIndexes.GetEntries(idx):\n            ...     form = project.ReversalEntries.GetForm(entry)\n            ...     senses = project.ReversalEntries.GetSenses(entry)\n            ...     print(f\"{form}: {len(list(senses))} senses\")\n            run: 3 senses\n            walk: 2 senses\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(index_or_hvo, wsHandle=None)",
          "summary": "Get the name of a reversal index.",
          "description": "Get the name of a reversal index.\n",
          "parameters": [
            {
              "name": "index_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndex object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The index name (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If index_or_hvo is None"
          ],
          "example": "            >>> idx = project.ReversalIndexes.FindByWritingSystem('en')\n            >>> name = project.ReversalIndexes.GetName(idx)\n            >>> print(name)\n            English\n\n        See Also:\n            SetName, Find",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetWritingSystem",
          "signature": "GetWritingSystem(index_or_hvo)",
          "summary": "Get the writing system of a reversal index.",
          "description": "Get the writing system of a reversal index.\n",
          "parameters": [
            {
              "name": "index_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndex object or its HVO"
            }
          ],
          "returns": "str: The writing system identifier (e.g., 'en', 'fr') ",
          "raises": [
            "FP_NullParameterError: If index_or_hvo is None"
          ],
          "example": "            >>> idx = project.ReversalIndexes.Find(\"English\")\n            >>> ws = project.ReversalIndexes.GetWritingSystem(idx)\n            >>> print(ws)\n            en\n\n        See Also:\n            FindByWritingSystem",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(index_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a reversal index.",
          "description": "Set the name of a reversal index.\n",
          "parameters": [
            {
              "name": "index_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IReversalIndex object or its HVO"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new index name"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If index_or_hvo or name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> idx = project.ReversalIndexes.FindByWritingSystem('en')\n            >>> project.ReversalIndexes.SetName(idx, \"English Reversal\")\n            >>> print(project.ReversalIndexes.GetName(idx))\n            English Reversal\n\n        See Also:\n            GetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ReversalIndexOperations with a FLExProject instance.",
          "description": "Initialize ReversalIndexOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "reversal",
        "operations"
      ]
    },
    "ScrAnnotationsOperations": {
      "name": "ScrAnnotationsOperations",
      "type": "class",
      "namespace": "FlexLibs2.Scripture.ScrAnnotationsOperations",
      "source_file": "Scripture/ScrAnnotationsOperations",
      "category": "scripture",
      "summary": "This class provides operations for managing Scripture book annotations in a\nFieldWorks project.",
      "description": "This class provides operations for managing Scripture book annotations in a\nFieldWorks project.\n\nScripture book annotations are containers for notes (translator notes,\nconsultant notes, etc.) associated with a Scripture book.\n\nThis class should be accessed via FLExProject.ScrAnnotations property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a book\ngenesis = project.ScrBooks.Find(1)\n\n# Create annotations container\nannotations = project.ScrAnnotations.Create(genesis, \"note\")\n\n# Get annotations for a book\nannotations = project.ScrAnnotations.GetForBook(genesis)\n\n# Get notes in annotations\nnotes = project.ScrAnnotations.GetNotes(annotations)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(book_or_hvo, type='note')",
          "summary": "Create a new Scripture book annotations container.",
          "description": "Create a new Scripture book annotations container.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            },
            {
              "name": "type",
              "type": "str, optional",
              "default": "note",
              "description": "Annotation type. Defaults to \"note\"."
            }
          ],
          "returns": "IScrBookAnnotations: The newly created annotations object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If book_or_hvo is None",
            "FP_ParameterError: If book doesn't exist or annotations already exist"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> annotations = project.ScrAnnotations.Create(genesis)\n\n            >>> # Create consultant notes container\n            >>> annotations = project.ScrAnnotations.Create(\n            ...     genesis,\n            ...     \"consultant_note\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(annotations_or_hvo)",
          "summary": "Delete a Scripture book annotations container from the FLEx project.",
          "description": "Delete a Scripture book annotations container from the FLEx project.\n",
          "parameters": [
            {
              "name": "annotations_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBookAnnotations object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If annotations_or_hvo is None",
            "FP_ParameterError: If annotations doesn't exist"
          ],
          "example": "            >>> annotations = project.ScrAnnotations.GetForBook(genesis)\n            >>> if annotations:\n            ...     project.ScrAnnotations.Delete(annotations)\n\n        Warning:\n            - This is a destructive operation\n            - All notes in the container will be deleted\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForBook",
          "signature": "GetForBook(book_or_hvo)",
          "summary": "Get the annotations container for a Scripture book.",
          "description": "Get the annotations container for a Scripture book.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            }
          ],
          "returns": "IScrBookAnnotations or None: The annotations object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If book_or_hvo is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> annotations = project.ScrAnnotations.GetForBook(genesis)\n            >>> if annotations:\n            ...     notes = project.ScrAnnotations.GetNotes(annotations)\n            ...     print(f\"Book has {len(notes)} notes\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetNotes",
          "signature": "GetNotes(annotations_or_hvo)",
          "summary": "Get all notes in a Scripture book annotations container.",
          "description": "Get all notes in a Scripture book annotations container.\n",
          "parameters": [
            {
              "name": "annotations_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBookAnnotations object or its HVO"
            }
          ],
          "returns": "list: List of IScrScriptureNote objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If annotations_or_hvo is None"
          ],
          "example": "            >>> annotations = project.ScrAnnotations.GetForBook(genesis)\n            >>> if annotations:\n            ...     notes = project.ScrAnnotations.GetNotes(annotations)\n            ...     for note in notes:\n            ...         text = project.ScrNotes.GetText(note)\n            ...         print(f\"Note: {text}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ScrAnnotationsOperations with a FLExProject instance.",
          "description": "Initialize ScrAnnotationsOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrBookAnnotationsFactory",
        "IScrScriptureNote"
      ],
      "tags": [
        "scripture",
        "operations"
      ]
    },
    "ScrBookOperations": {
      "name": "ScrBookOperations",
      "type": "class",
      "namespace": "FlexLibs2.Scripture.ScrBookOperations",
      "source_file": "Scripture/ScrBookOperations",
      "category": "scripture",
      "summary": "This class provides operations for managing Scripture books in a\nFieldWorks project.",
      "description": "This class provides operations for managing Scripture books in a\nFieldWorks project.\n\nScripture books represent individual books of the Bible (Genesis, Matthew,\netc.) identified by canonical numbers (1-66 for standard Protestant canon).\nEach book contains sections with headings and paragraph content.\n\nThis class should be accessed via FLExProject.ScrBooks property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all Scripture books\nfor book in project.ScrBooks.GetAll():\ntitle = project.ScrBooks.GetTitle(book)\nprint(f\"Book: {title}\")\n\n# Create a new book (Genesis = 1)\ngenesis = project.ScrBooks.Create(1, \"Genesis\")\n\n# Find book by canonical number\nmatthew = project.ScrBooks.Find(40)  # Matthew = 40\n\n# Get sections in a book\nsections = project.ScrBooks.GetSections(genesis)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(canonical_num, title=None)",
          "summary": "Create a new Scripture book with the specified canonical number.",
          "description": "Create a new Scripture book with the specified canonical number.\n",
          "parameters": [
            {
              "name": "canonical_num",
              "type": "int",
              "default": null,
              "description": "The canonical book number (1-66 for Protestant canon) 1=Genesis, 2=Exodus, ... 40=Matthew, 41=Mark, ... 66=Revelation"
            },
            {
              "name": "title",
              "type": "str, optional",
              "default": null,
              "description": "Book title. If None, uses default title for the canonical number."
            }
          ],
          "returns": "IScrBook: The newly created Scripture book object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If canonical_num is None",
            "FP_ParameterError: If canonical_num is invalid or book already exists"
          ],
          "example": "            >>> # Create Genesis\n            >>> genesis = project.ScrBooks.Create(1, \"Genesis\")\n            >>> print(project.ScrBooks.GetTitle(genesis))\n            Genesis\n\n            >>> # Create Matthew (canonical number 40)\n            >>> matthew = project.ScrBooks.Create(40, \"Matthew\")\n\n            >>> # Create with default title\n            >>> exodus = project.ScrBooks.Create(2)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(book_or_hvo)",
          "summary": "Delete a Scripture book from the FLEx project.",
          "description": "Delete a Scripture book from the FLEx project.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO (database ID)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If book_or_hvo is None",
            "FP_ParameterError: If book doesn't exist"
          ],
          "example": "            >>> book = project.ScrBooks.Find(1)  # Genesis\n            >>> if book:\n            ...     project.ScrBooks.Delete(book)\n\n            >>> # Delete by HVO\n            >>> project.ScrBooks.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - All sections and paragraphs will be deleted\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(canonical_num)",
          "summary": "Find a Scripture book by its canonical number.",
          "description": "Find a Scripture book by its canonical number.\n",
          "parameters": [
            {
              "name": "canonical_num",
              "type": "int",
              "default": null,
              "description": "The canonical book number (1-66)"
            }
          ],
          "returns": "IScrBook or None: The book object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If canonical_num is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> if genesis:\n            ...     title = project.ScrBooks.GetTitle(genesis)\n            ...     print(f\"Found: {title}\")\n            Found: Genesis\n\n            >>> # Find Matthew (canonical number 40)\n            >>> matthew = project.ScrBooks.Find(40)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByName",
          "signature": "FindByName(name)",
          "summary": "Find a Scripture book by its title/name.",
          "description": "Find a Scripture book by its title/name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The book title to search for (case-insensitive)"
            }
          ],
          "returns": "IScrBook or None: The book object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.FindByName(\"Genesis\")\n            >>> if genesis:\n            ...     num = project.ScrBooks.GetCanonicalNum(genesis)\n            ...     print(f\"Canonical number: {num}\")\n            Canonical number: 1\n\n            >>> # Case-insensitive search\n            >>> matthew = project.ScrBooks.FindByName(\"matthew\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all Scripture books in the project.",
          "description": "Get all Scripture books in the project.\n\nThis method returns an iterator over all IScrBook objects in the\nproject, allowing iteration over all Scripture books.\n",
          "parameters": [],
          "returns": "IScrBook: Each Scripture book object in the project ",
          "raises": [],
          "example": "            >>> for book in project.ScrBooks.GetAll():\n            ...     title = project.ScrBooks.GetTitle(book)\n            ...     num = project.ScrBooks.GetCanonicalNum(book)\n            ...     print(f\"{num}: {title}\")\n            1: Genesis\n            2: Exodus\n            40: Matthew\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCanonicalNum",
          "signature": "GetCanonicalNum(book_or_hvo)",
          "summary": "Get the canonical number of a Scripture book.",
          "description": "Get the canonical number of a Scripture book.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            }
          ],
          "returns": "int: The canonical book number (1-66) ",
          "raises": [
            "FP_NullParameterError: If book_or_hvo is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> num = project.ScrBooks.GetCanonicalNum(genesis)\n            >>> print(num)\n            1\n\n            >>> matthew = project.ScrBooks.FindByName(\"Matthew\")\n            >>> print(project.ScrBooks.GetCanonicalNum(matthew))\n            40\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSections",
          "signature": "GetSections(book_or_hvo)",
          "summary": "Get all sections in a Scripture book.",
          "description": "Get all sections in a Scripture book.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            }
          ],
          "returns": "list: List of IScrSection objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If book_or_hvo is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> sections = project.ScrBooks.GetSections(genesis)\n            >>> for section in sections:\n            ...     heading = project.ScrSections.GetHeading(section)\n            ...     print(f\"Section: {heading}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetTitle",
          "signature": "GetTitle(book_or_hvo, wsHandle=None)",
          "summary": "Get the title of a Scripture book.",
          "description": "Get the title of a Scripture book.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The book title (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If book_or_hvo is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> title = project.ScrBooks.GetTitle(genesis)\n            >>> print(title)\n            Genesis\n\n            >>> # Get in specific writing system\n            >>> title_fr = project.ScrBooks.GetTitle(genesis,\n            ...                                       project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetTitle",
          "signature": "SetTitle(book_or_hvo, title, wsHandle=None)",
          "summary": "Set the title of a Scripture book.",
          "description": "Set the title of a Scripture book.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            },
            {
              "name": "title",
              "type": "str",
              "default": null,
              "description": "The new book title"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If book_or_hvo or title is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> project.ScrBooks.SetTitle(genesis, \"Genesis\")\n\n            >>> # Set in specific writing system\n            >>> project.ScrBooks.SetTitle(genesis, \"Gense\",\n            ...                            project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ScrBookOperations with a FLExProject instance.",
          "description": "Initialize ScrBookOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "scripture",
        "operations"
      ]
    },
    "ScrDraftOperations": {
      "name": "ScrDraftOperations",
      "type": "class",
      "namespace": "FlexLibs2.Scripture.ScrDraftOperations",
      "source_file": "Scripture/ScrDraftOperations",
      "category": "scripture",
      "summary": "This class provides operations for managing Scripture drafts/versions in a\nFieldWorks project.",
      "description": "This class provides operations for managing Scripture drafts/versions in a\nFieldWorks project.\n\nScripture drafts are saved versions of the Scripture text, allowing tracking\nof different translation drafts, consultant checks, or archived versions.\n\nThis class should be accessed via FLExProject.ScrDrafts property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all drafts\nfor draft in project.ScrDrafts.GetAll():\ndesc = project.ScrDrafts.GetDescription(draft)\nprint(f\"Draft: {desc}\")\n\n# Create a new draft\ndraft = project.ScrDrafts.Create(\"First Draft - January 2025\", \"saved_version\")\n\n# Find draft by description\ndraft = project.ScrDrafts.Find(\"First Draft\")\n\n# Get books in draft\nbooks = project.ScrDrafts.GetBooks(draft)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(description, type='saved_version')",
          "summary": "Create a new Scripture draft/version.",
          "description": "Create a new Scripture draft/version.\n",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "Description of the draft (e.g., \"First Draft - Jan 2025\")"
            },
            {
              "name": "type",
              "type": "str, optional",
              "default": "saved_version",
              "description": "Draft type. Defaults to \"saved_version\"."
            }
          ],
          "returns": "IScrDraft: The newly created draft object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If description is None",
            "FP_ParameterError: If description is empty or Scripture not enabled"
          ],
          "example": "            >>> # Create a saved version\n            >>> draft = project.ScrDrafts.Create(\"First Draft - January 2025\")\n\n            >>> # Create a consultant check draft\n            >>> check = project.ScrDrafts.Create(\n            ...     \"Consultant Review - February 2025\",\n            ...     \"consultant_check\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(draft_or_hvo)",
          "summary": "Delete a Scripture draft from the FLEx project.",
          "description": "Delete a Scripture draft from the FLEx project.\n",
          "parameters": [
            {
              "name": "draft_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrDraft object or its HVO (database ID)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If draft_or_hvo is None",
            "FP_ParameterError: If draft doesn't exist"
          ],
          "example": "            >>> draft = project.ScrDrafts.Find(\"Old Draft\")\n            >>> if draft:\n            ...     project.ScrDrafts.Delete(draft)\n\n            >>> # Delete by HVO\n            >>> project.ScrDrafts.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - All books and content in the draft will be deleted\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(description)",
          "summary": "Find a Scripture draft by its description.",
          "description": "Find a Scripture draft by its description.\n",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The draft description to search for (case-insensitive)"
            }
          ],
          "returns": "IScrDraft or None: The draft object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If description is None"
          ],
          "example": "            >>> draft = project.ScrDrafts.Find(\"First Draft\")\n            >>> if draft:\n            ...     desc = project.ScrDrafts.GetDescription(draft)\n            ...     print(f\"Found: {desc}\")\n            Found: First Draft - January 2025\n\n            >>> # Case-insensitive search\n            >>> draft = project.ScrDrafts.Find(\"first draft\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all Scripture drafts in the project.",
          "description": "Get all Scripture drafts in the project.\n\nThis method returns an iterator over all IScrDraft objects in the\nproject, allowing iteration over all saved Scripture versions.\n",
          "parameters": [],
          "returns": "IScrDraft: Each Scripture draft object in the project ",
          "raises": [],
          "example": "            >>> for draft in project.ScrDrafts.GetAll():\n            ...     desc = project.ScrDrafts.GetDescription(draft)\n            ...     print(f\"Draft: {desc}\")\n            Draft: First Draft - January 2025\n            Draft: Consultant Check - February 2025\n            Draft: Final Version - March 2025\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBooks",
          "signature": "GetBooks(draft_or_hvo)",
          "summary": "Get all books in a Scripture draft.",
          "description": "Get all books in a Scripture draft.\n",
          "parameters": [
            {
              "name": "draft_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrDraft object or its HVO"
            }
          ],
          "returns": "list: List of IScrBook objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If draft_or_hvo is None"
          ],
          "example": "            >>> draft = project.ScrDrafts.Find(\"First Draft\")\n            >>> books = project.ScrDrafts.GetBooks(draft)\n            >>> for book in books:\n            ...     title = project.ScrBooks.GetTitle(book)\n            ...     print(f\"Book: {title}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(draft_or_hvo)",
          "summary": "Get the description of a Scripture draft.",
          "description": "Get the description of a Scripture draft.\n",
          "parameters": [
            {
              "name": "draft_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrDraft object or its HVO"
            }
          ],
          "returns": "str: The draft description (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If draft_or_hvo is None"
          ],
          "example": "            >>> draft = project.ScrDrafts.Find(\"First Draft\")\n            >>> desc = project.ScrDrafts.GetDescription(draft)\n            >>> print(desc)\n            First Draft - January 2025\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(draft_or_hvo, text)",
          "summary": "Set the description of a Scripture draft.",
          "description": "Set the description of a Scripture draft.\n",
          "parameters": [
            {
              "name": "draft_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrDraft object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new draft description"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If draft_or_hvo or text is None"
          ],
          "example": "            >>> draft = project.ScrDrafts.Find(\"First Draft\")\n            >>> project.ScrDrafts.SetDescription(\n            ...     draft,\n            ...     \"First Draft - Revised January 2025\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ScrDraftOperations with a FLExProject instance.",
          "description": "Initialize ScrDraftOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IScrDraft",
        "IScrDraftFactory",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "scripture",
        "operations"
      ]
    },
    "ScrNoteOperations": {
      "name": "ScrNoteOperations",
      "type": "class",
      "namespace": "FlexLibs2.Scripture.ScrNoteOperations",
      "source_file": "Scripture/ScrNoteOperations",
      "category": "scripture",
      "summary": "This class provides operations for managing Scripture notes in a\nFieldWorks project.",
      "description": "This class provides operations for managing Scripture notes in a\nFieldWorks project.\n\nScripture notes are annotations attached to specific paragraphs or\nlocations in Scripture text. They can be translator notes, consultant\nnotes, checking questions, etc.\n\nThis class should be accessed via FLExProject.ScrNotes property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a book\ngenesis = project.ScrBooks.Find(1)\n\n# Get a paragraph\nsection = project.ScrSections.Find(genesis, 0)\npara = project.ScrTxtParas.Find(section, 0)\n\n# Create a note\nnote = project.ScrNotes.Create(\ngenesis,\npara,\n\"Check: Is 'beginning' the best translation?\",\n\"translator_note\"\n)\n\n# Get all notes for a book\nnotes = project.ScrNotes.GetAll(genesis)\n\n# Get note text\ntext = project.ScrNotes.GetText(note)\n\n# Resolve a note\nproject.ScrNotes.Resolve(note)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(book_or_hvo, paragraph_or_hvo, text, type='translator_note')",
          "summary": "Create a new Scripture note attached to a paragraph.",
          "description": "Create a new Scripture note attached to a paragraph.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            },
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrTxtPara object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The note text content"
            },
            {
              "name": "type",
              "type": "str, optional",
              "default": "translator_note",
              "description": "Note type. Defaults to \"translator_note\"."
            }
          ],
          "returns": "IScrScriptureNote: The newly created note object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If any parameter is None",
            "FP_ParameterError: If book or paragraph doesn't exist"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> section = project.ScrSections.Find(genesis, 0)\n            >>> para = project.ScrTxtParas.Find(section, 0)\n            >>> note = project.ScrNotes.Create(\n            ...     genesis,\n            ...     para,\n            ...     \"Check: Is 'beginning' the best translation?\"\n            ... )\n\n            >>> # Create consultant note\n            >>> note = project.ScrNotes.Create(\n            ...     genesis,\n            ...     para,\n            ...     \"Good translation. Consider alternate word order.\",\n            ...     \"consultant_note\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(note_or_hvo)",
          "summary": "Delete a Scripture note from the FLEx project.",
          "description": "Delete a Scripture note from the FLEx project.\n",
          "parameters": [
            {
              "name": "note_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrScriptureNote object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If note_or_hvo is None",
            "FP_ParameterError: If note doesn't exist"
          ],
          "example": "            >>> note = project.ScrNotes.Find(genesis, 0)\n            >>> if note:\n            ...     project.ScrNotes.Delete(note)\n\n        Warning:\n            - This is a destructive operation\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(book_or_hvo, index)",
          "summary": "Find a Scripture note by index within a book.",
          "description": "Find a Scripture note by index within a book.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "The zero-based index of the note in the book"
            }
          ],
          "returns": "IScrScriptureNote or None: The note object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If book_or_hvo or index is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> # Get first note\n            >>> note = project.ScrNotes.Find(genesis, 0)\n            >>> if note:\n            ...     text = project.ScrNotes.GetText(note)\n            ...     print(f\"Note: {text}\")\n\n            >>> # Get third note\n            >>> note3 = project.ScrNotes.Find(genesis, 2)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(book_or_hvo)",
          "summary": "Get all Scripture notes in a book.",
          "description": "Get all Scripture notes in a book.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            }
          ],
          "returns": "list: List of IScrScriptureNote objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If book_or_hvo is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> notes = project.ScrNotes.GetAll(genesis)\n            >>> for i, note in enumerate(notes):\n            ...     text = project.ScrNotes.GetText(note)\n            ...     resolved = project.ScrNotes.IsResolved(note)\n            ...     status = \"Resolved\" if resolved else \"Open\"\n            ...     print(f\"{i+1}. [{status}] {text}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetText",
          "signature": "GetText(note_or_hvo, wsHandle=None)",
          "summary": "Get the text content of a Scripture note.",
          "description": "Get the text content of a Scripture note.\n",
          "parameters": [
            {
              "name": "note_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrScriptureNote object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The note text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If note_or_hvo is None"
          ],
          "example": "            >>> note = project.ScrNotes.Find(genesis, 0)\n            >>> text = project.ScrNotes.GetText(note)\n            >>> print(text)\n            Check: Is 'beginning' the best translation?\n\n            >>> # Get in specific writing system\n            >>> text_fr = project.ScrNotes.GetText(note,\n            ...                                     project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetType",
          "signature": "GetType(note_or_hvo)",
          "summary": "Get the type of a Scripture note.",
          "description": "Get the type of a Scripture note.\n",
          "parameters": [
            {
              "name": "note_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrScriptureNote object or its HVO"
            }
          ],
          "returns": "str: The note type (empty string if not determinable) ",
          "raises": [
            "FP_NullParameterError: If note_or_hvo is None"
          ],
          "example": "            >>> note = project.ScrNotes.Find(genesis, 0)\n            >>> note_type = project.ScrNotes.GetType(note)\n            >>> print(note_type)\n            translator_note\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsResolved",
          "signature": "IsResolved(note_or_hvo)",
          "summary": "Check if a Scripture note is marked as resolved.",
          "description": "Check if a Scripture note is marked as resolved.\n",
          "parameters": [
            {
              "name": "note_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrScriptureNote object or its HVO"
            }
          ],
          "returns": "bool: True if note is resolved, False otherwise ",
          "raises": [
            "FP_NullParameterError: If note_or_hvo is None"
          ],
          "example": "            >>> note = project.ScrNotes.Find(genesis, 0)\n            >>> if project.ScrNotes.IsResolved(note):\n            ...     print(\"Note is resolved\")\n            ... else:\n            ...     print(\"Note is still open\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Resolve",
          "signature": "Resolve(note_or_hvo)",
          "summary": "Mark a Scripture note as resolved.",
          "description": "Mark a Scripture note as resolved.\n",
          "parameters": [
            {
              "name": "note_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrScriptureNote object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If note_or_hvo is None"
          ],
          "example": "            >>> note = project.ScrNotes.Find(genesis, 0)\n            >>> # Check if already resolved\n            >>> if not project.ScrNotes.IsResolved(note):\n            ...     project.ScrNotes.Resolve(note)\n            ...     print(\"Note resolved\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetText",
          "signature": "SetText(note_or_hvo, text, wsHandle=None)",
          "summary": "Set the text content of a Scripture note.",
          "description": "Set the text content of a Scripture note.\n",
          "parameters": [
            {
              "name": "note_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrScriptureNote object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new note text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If note_or_hvo or text is None"
          ],
          "example": "            >>> note = project.ScrNotes.Find(genesis, 0)\n            >>> project.ScrNotes.SetText(\n            ...     note,\n            ...     \"Updated: Consider using 'origin' instead of 'beginning'\"\n            ... )\n\n            >>> # Set in specific writing system\n            >>> project.ScrNotes.SetText(\n            ...     note,\n            ...     \"Vrifier: Utiliser 'commencement' ou 'origine'?\",\n            ...     project.WSHandle('fr')\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ScrNoteOperations with a FLExProject instance.",
          "description": "Initialize ScrNoteOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ],
      "tags": [
        "scripture",
        "operations"
      ]
    },
    "ScrSectionOperations": {
      "name": "ScrSectionOperations",
      "type": "class",
      "namespace": "FlexLibs2.Scripture.ScrSectionOperations",
      "source_file": "Scripture/ScrSectionOperations",
      "category": "scripture",
      "summary": "This class provides operations for managing Scripture sections in a\nFieldWorks project.",
      "description": "This class provides operations for managing Scripture sections in a\nFieldWorks project.\n\nScripture sections are subdivisions of books, each with a heading and\ncontent paragraphs. Sections organize Scripture text into logical units.\n\nThis class should be accessed via FLExProject.ScrSections property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a book\ngenesis = project.ScrBooks.Find(1)\n\n# Create a section\nsection = project.ScrSections.Create(genesis, \"Creation\", \"In the beginning...\")\n\n# Get all sections in a book\nsections = project.ScrSections.GetAll(genesis)\n\n# Get section heading and content\nheading = project.ScrSections.GetHeading(section)\nparas = project.ScrSections.GetContent(section)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(book_or_hvo, heading='', content='')",
          "summary": "Create a new Scripture section with heading and/or content.",
          "description": "Create a new Scripture section with heading and/or content.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            },
            {
              "name": "heading",
              "type": "str, optional",
              "default": "",
              "description": "Section heading text"
            },
            {
              "name": "content",
              "type": "str, optional",
              "default": "",
              "description": "Initial paragraph content text"
            }
          ],
          "returns": "IScrSection: The newly created section object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If book_or_hvo is None",
            "FP_ParameterError: If book doesn't exist"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> section = project.ScrSections.Create(\n            ...     genesis,\n            ...     \"The Creation\",\n            ...     \"In the beginning God created the heavens and the earth.\"\n            ... )\n\n            >>> # Create section with heading only\n            >>> section2 = project.ScrSections.Create(genesis, \"The Fall\")\n\n            >>> # Create empty section\n            >>> section3 = project.ScrSections.Create(genesis)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(section_or_hvo)",
          "summary": "Delete a Scripture section from the FLEx project.",
          "description": "Delete a Scripture section from the FLEx project.\n",
          "parameters": [
            {
              "name": "section_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrSection object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If section_or_hvo is None",
            "FP_ParameterError: If section doesn't exist"
          ],
          "example": "            >>> section = project.ScrSections.Find(genesis, 0)\n            >>> if section:\n            ...     project.ScrSections.Delete(section)\n\n        Warning:\n            - This is a destructive operation\n            - All paragraphs and content will be deleted\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(book_or_hvo, index)",
          "summary": "Find a Scripture section by index within a book.",
          "description": "Find a Scripture section by index within a book.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "The zero-based index of the section in the book"
            }
          ],
          "returns": "IScrSection or None: The section object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If book_or_hvo or index is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> # Get first section\n            >>> section = project.ScrSections.Find(genesis, 0)\n            >>> if section:\n            ...     heading = project.ScrSections.GetHeading(section)\n            ...     print(f\"Section: {heading}\")\n\n            >>> # Get third section\n            >>> section3 = project.ScrSections.Find(genesis, 2)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(book_or_hvo)",
          "summary": "Get all Scripture sections in a book.",
          "description": "Get all Scripture sections in a book.\n",
          "parameters": [
            {
              "name": "book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO"
            }
          ],
          "returns": "list: List of IScrSection objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If book_or_hvo is None"
          ],
          "example": "            >>> genesis = project.ScrBooks.Find(1)\n            >>> sections = project.ScrSections.GetAll(genesis)\n            >>> for i, section in enumerate(sections):\n            ...     heading = project.ScrSections.GetHeading(section)\n            ...     print(f\"{i+1}. {heading}\")\n            1. The Creation\n            2. The Fall\n            3. Cain and Abel\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetContent",
          "signature": "GetContent(section_or_hvo)",
          "summary": "Get all content paragraphs in a Scripture section.",
          "description": "Get all content paragraphs in a Scripture section.\n",
          "parameters": [
            {
              "name": "section_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrSection object or its HVO"
            }
          ],
          "returns": "list: List of IScrTxtPara objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If section_or_hvo is None"
          ],
          "example": "            >>> section = project.ScrSections.Find(genesis, 0)\n            >>> paras = project.ScrSections.GetContent(section)\n            >>> for para in paras:\n            ...     text = project.ScrTxtParas.GetText(para)\n            ...     print(f\"Paragraph: {text}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetHeading",
          "signature": "GetHeading(section_or_hvo, wsHandle=None)",
          "summary": "Get the heading of a Scripture section.",
          "description": "Get the heading of a Scripture section.\n",
          "parameters": [
            {
              "name": "section_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrSection object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The section heading (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If section_or_hvo is None"
          ],
          "example": "            >>> section = project.ScrSections.Find(genesis, 0)\n            >>> heading = project.ScrSections.GetHeading(section)\n            >>> print(heading)\n            The Creation\n\n            >>> # Get in specific writing system\n            >>> heading_fr = project.ScrSections.GetHeading(section,\n            ...                                              project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MoveTo",
          "signature": "MoveTo(section_or_hvo, target_book_or_hvo, index)",
          "summary": "Move a section to a different position or book.",
          "description": "Move a section to a different position or book.\n",
          "parameters": [
            {
              "name": "section_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrSection object or its HVO"
            },
            {
              "name": "target_book_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrBook object or its HVO (destination)"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "The zero-based index position in the target book"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If any parameter is None",
            "FP_ParameterError: If index is out of range"
          ],
          "example": "            >>> section = project.ScrSections.Find(genesis, 2)\n            >>> # Move to first position in same book\n            >>> project.ScrSections.MoveTo(section, genesis, 0)\n\n            >>> # Move to different book\n            >>> exodus = project.ScrBooks.Find(2)\n            >>> project.ScrSections.MoveTo(section, exodus, 0)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetHeading",
          "signature": "SetHeading(section_or_hvo, text, wsHandle=None)",
          "summary": "Set the heading of a Scripture section.",
          "description": "Set the heading of a Scripture section.\n",
          "parameters": [
            {
              "name": "section_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrSection object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new heading text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If section_or_hvo or text is None"
          ],
          "example": "            >>> section = project.ScrSections.Find(genesis, 0)\n            >>> project.ScrSections.SetHeading(section, \"The Creation Story\")\n\n            >>> # Set in specific writing system\n            >>> project.ScrSections.SetHeading(section, \"La Cration\",\n            ...                                 project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ScrSectionOperations with a FLExProject instance.",
          "description": "Initialize ScrSectionOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ],
      "tags": [
        "scripture",
        "operations"
      ]
    },
    "ScrTxtParaOperations": {
      "name": "ScrTxtParaOperations",
      "type": "class",
      "namespace": "FlexLibs2.Scripture.ScrTxtParaOperations",
      "source_file": "Scripture/ScrTxtParaOperations",
      "category": "scripture",
      "summary": "This class provides operations for managing Scripture text paragraphs in a\nFieldWorks project.",
      "description": "This class provides operations for managing Scripture text paragraphs in a\nFieldWorks project.\n\nScripture paragraphs are the basic text units within sections, each with\ntext content and a paragraph style (Normal, Poetry, Quote, etc.).\n\nThis class should be accessed via FLExProject.ScrTxtParas property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get a section\ngenesis = project.ScrBooks.Find(1)\nsection = project.ScrSections.Find(genesis, 0)\n\n# Create a paragraph\npara = project.ScrTxtParas.Create(\nsection,\n\"In the beginning God created the heavens and the earth.\",\n\"Normal\"\n)\n\n# Get paragraph text\ntext = project.ScrTxtParas.GetText(para)\n\n# Set paragraph style\nproject.ScrTxtParas.SetStyleName(para, \"Poetry\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(section_or_hvo, text, style_name='Normal')",
          "summary": "Create a new Scripture paragraph in a section.",
          "description": "Create a new Scripture paragraph in a section.\n",
          "parameters": [
            {
              "name": "section_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrSection object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The paragraph text content"
            },
            {
              "name": "style_name",
              "type": "str, optional",
              "default": "Normal",
              "description": "Paragraph style name. Defaults to \"Normal\". Common styles: \"Normal\", \"Poetry\", \"Quote\", \"List Item\""
            }
          ],
          "returns": "IScrTxtPara: The newly created paragraph object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If section_or_hvo or text is None",
            "FP_ParameterError: If section doesn't exist or style not found"
          ],
          "example": "            >>> section = project.ScrSections.Find(genesis, 0)\n            >>> para = project.ScrTxtParas.Create(\n            ...     section,\n            ...     \"In the beginning God created the heavens and the earth.\"\n            ... )\n\n            >>> # Create poetry paragraph\n            >>> para2 = project.ScrTxtParas.Create(\n            ...     section,\n            ...     \"The LORD is my shepherd\",\n            ...     \"Poetry\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(para_or_hvo)",
          "summary": "Delete a Scripture paragraph from the FLEx project.",
          "description": "Delete a Scripture paragraph from the FLEx project.\n",
          "parameters": [
            {
              "name": "para_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrTxtPara object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If para_or_hvo is None",
            "FP_ParameterError: If paragraph doesn't exist"
          ],
          "example": "            >>> para = project.ScrTxtParas.Find(section, 0)\n            >>> if para:\n            ...     project.ScrTxtParas.Delete(para)\n\n        Warning:\n            - This is a destructive operation\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(section_or_hvo, index)",
          "summary": "Find a Scripture paragraph by index within a section.",
          "description": "Find a Scripture paragraph by index within a section.\n",
          "parameters": [
            {
              "name": "section_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrSection object or its HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "The zero-based index of the paragraph in the section"
            }
          ],
          "returns": "IScrTxtPara or None: The paragraph object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If section_or_hvo or index is None"
          ],
          "example": "            >>> section = project.ScrSections.Find(genesis, 0)\n            >>> # Get first paragraph\n            >>> para = project.ScrTxtParas.Find(section, 0)\n            >>> if para:\n            ...     text = project.ScrTxtParas.GetText(para)\n            ...     print(f\"Paragraph: {text}\")\n\n            >>> # Get third paragraph\n            >>> para3 = project.ScrTxtParas.Find(section, 2)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(section_or_hvo)",
          "summary": "Get all Scripture paragraphs in a section.",
          "description": "Get all Scripture paragraphs in a section.\n",
          "parameters": [
            {
              "name": "section_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrSection object or its HVO"
            }
          ],
          "returns": "list: List of IScrTxtPara objects (empty list if none) ",
          "raises": [
            "FP_NullParameterError: If section_or_hvo is None"
          ],
          "example": "            >>> section = project.ScrSections.Find(genesis, 0)\n            >>> paras = project.ScrTxtParas.GetAll(section)\n            >>> for i, para in enumerate(paras):\n            ...     text = project.ScrTxtParas.GetText(para)\n            ...     print(f\"{i+1}. {text}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetStyleName",
          "signature": "GetStyleName(para_or_hvo)",
          "summary": "Get the style name of a Scripture paragraph.",
          "description": "Get the style name of a Scripture paragraph.\n",
          "parameters": [
            {
              "name": "para_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrTxtPara object or its HVO"
            }
          ],
          "returns": "str: The paragraph style name (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If para_or_hvo is None"
          ],
          "example": "            >>> para = project.ScrTxtParas.Find(section, 0)\n            >>> style = project.ScrTxtParas.GetStyleName(para)\n            >>> print(style)\n            Normal\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetText",
          "signature": "GetText(para_or_hvo, wsHandle=None)",
          "summary": "Get the text content of a Scripture paragraph.",
          "description": "Get the text content of a Scripture paragraph.\n",
          "parameters": [
            {
              "name": "para_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrTxtPara object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The paragraph text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If para_or_hvo is None"
          ],
          "example": "            >>> para = project.ScrTxtParas.Find(section, 0)\n            >>> text = project.ScrTxtParas.GetText(para)\n            >>> print(text)\n            In the beginning God created the heavens and the earth.\n\n            >>> # Get in specific writing system\n            >>> text_fr = project.ScrTxtParas.GetText(para,\n            ...                                        project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetStyleName",
          "signature": "SetStyleName(para_or_hvo, style_name)",
          "summary": "Set the style name of a Scripture paragraph.",
          "description": "Set the style name of a Scripture paragraph.\n",
          "parameters": [
            {
              "name": "para_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrTxtPara object or its HVO"
            },
            {
              "name": "style_name",
              "type": "str",
              "default": null,
              "description": "The paragraph style name Common styles: \"Normal\", \"Poetry\", \"Quote\", \"List Item\""
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If para_or_hvo or style_name is None",
            "FP_ParameterError: If style not found"
          ],
          "example": "            >>> para = project.ScrTxtParas.Find(section, 0)\n            >>> project.ScrTxtParas.SetStyleName(para, \"Poetry\")\n\n            >>> # Check new style\n            >>> print(project.ScrTxtParas.GetStyleName(para))\n            Poetry\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetText",
          "signature": "SetText(para_or_hvo, text, wsHandle=None)",
          "summary": "Set the text content of a Scripture paragraph.",
          "description": "Set the text content of a Scripture paragraph.\n",
          "parameters": [
            {
              "name": "para_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IScrTxtPara object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new paragraph text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If para_or_hvo or text is None"
          ],
          "example": "            >>> para = project.ScrTxtParas.Find(section, 0)\n            >>> project.ScrTxtParas.SetText(\n            ...     para,\n            ...     \"In the beginning God created the heavens and the earth.\"\n            ... )\n\n            >>> # Set in specific writing system\n            >>> project.ScrTxtParas.SetText(\n            ...     para,\n            ...     \"Au commencement, Dieu cra les cieux et la terre.\",\n            ...     project.WSHandle('fr')\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ScrTxtParaOperations with a FLExProject instance.",
          "description": "Initialize ScrTxtParaOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ],
      "tags": [
        "scripture",
        "operations"
      ]
    },
    "FilterTypes": {
      "name": "FilterTypes",
      "type": "class",
      "namespace": "FlexLibs2.Shared.FilterOperations",
      "source_file": "Shared/FilterOperations",
      "category": "general",
      "summary": "Filter type constants for different object classes.",
      "description": "Filter type constants for different object classes.",
      "example": "",
      "base_classes": [],
      "methods": [],
      "properties": [],
      "lcm_dependencies": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "general"
      ]
    },
    "FilterOperations": {
      "name": "FilterOperations",
      "type": "class",
      "namespace": "FlexLibs2.Shared.FilterOperations",
      "source_file": "Shared/FilterOperations",
      "category": "general",
      "summary": "This class provides operations for managing saved filters and queries\nin a FieldWorks project.",
      "description": "This class provides operations for managing saved filters and queries\nin a FieldWorks project.\n\nFilters allow you to define reusable criteria for selecting and filtering\ndifferent types of objects (entries, wordforms, texts, etc.). Each filter\nhas a name, type, and criteria definition that can be applied to collections\nof objects.\n\nThis class should be accessed via FLExProject.Filter property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Create a new filter\nfilter_obj = project.Filter.Create(\n\"Verbs\",\nFilterTypes.LEXENTRY,\n{\"pos\": \"verb\"}\n)\n\n# Get all filters\nfor f in project.Filter.GetAll():\nname = project.Filter.GetName(f)\nprint(name)\n\n# Find a filter by name\nfilter_obj = project.Filter.Find(\"Verbs\")\n\n# Apply filter to entries\nentries = list(project.LexEntry.GetAll())\nmatching = project.Filter.ApplyFilter(filter_obj, entries)\n\n# Export filter definition\nproject.Filter.ExportFilter(filter_obj, \"/path/to/filter.json\")\n\nproject.CloseProject()\n",
      "example": "",
      "base_classes": [],
      "methods": [
        {
          "name": "ApplyFilter",
          "signature": "ApplyFilter(filter_obj, object_collection)",
          "summary": "Apply a filter to a collection of objects.",
          "description": "Apply a filter to a collection of objects.\n\nThis method evaluates each object in the collection against the\nfilter criteria and returns only those that match.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object to apply"
            },
            {
              "name": "object_collection",
              "type": "",
              "default": null,
              "description": "Iterable collection of objects to filter"
            }
          ],
          "returns": "list: Objects from the collection that match the filter criteria ",
          "raises": [
            "FP_NullParameterError: If filter_obj or object_collection is None",
            "FP_ParameterError: If filter_obj is invalid"
          ],
          "example": "            >>> # Filter lexical entries\n            >>> verb_filter = project.Filter.Find(\"Verbs\")\n            >>> all_entries = list(project.LexEntry.GetAll())\n            >>> verbs = project.Filter.ApplyFilter(verb_filter, all_entries)\n            >>> print(f\"Found {len(verbs)} verbs\")\n\n            >>> # Filter wordforms\n            >>> correct_filter = project.Filter.Find(\"Correct Wordforms\")\n            >>> all_wordforms = list(project.Wordforms.GetAll())\n            >>> correct_wfs = project.Filter.ApplyFilter(correct_filter, all_wordforms)\n\n            >>> # Chain filters\n            >>> filtered1 = project.Filter.ApplyFilter(filter1, all_entries)\n            >>> filtered2 = project.Filter.ApplyFilter(filter2, filtered1)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two filters for differences.",
          "description": "Compare two filters for differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First filter dict object (from project 1)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second filter dict object (from project 2)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional FilterOperations instance for project 1 (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional FilterOperations instance for project 2 (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) - is_different (bool): True if filters differ, False if identical - differences_dict (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(filter1, filter2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} != {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, filter_type, criteria)",
          "summary": "Create a new saved filter in the project.",
          "description": "Create a new saved filter in the project.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the filter"
            },
            {
              "name": "filter_type",
              "type": "str",
              "default": null,
              "description": "The type of filter (use FilterTypes constants)"
            },
            {
              "name": "criteria",
              "type": "dict",
              "default": null,
              "description": "The filter criteria as a dictionary"
            }
          ],
          "returns": "dict: The newly created filter object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If name, filter_type, or criteria is None",
            "FP_ParameterError: If name is empty or filter already exists"
          ],
          "example": "            >>> # Create a lexical entry filter\n            >>> verb_filter = project.Filter.Create(\n            ...     \"Verbs\",\n            ...     FilterTypes.LEXENTRY,\n            ...     {\"pos\": \"verb\", \"status\": \"approved\"}\n            ... )\n\n            >>> # Create a wordform filter\n            >>> correct_wf = project.Filter.Create(\n            ...     \"Correct Wordforms\",\n            ...     FilterTypes.WORDFORM,\n            ...     {\"spelling_status\": 2}  # 2 = CORRECT\n            ... )\n\n            >>> # Create a text filter\n            >>> genre_filter = project.Filter.Create(\n            ...     \"Narratives\",\n            ...     FilterTypes.TEXT,\n            ...     {\"genre\": \"narrative\"}\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(filter_obj)",
          "summary": "Delete a saved filter from the project.",
          "description": "Delete a saved filter from the project.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object to delete"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If filter_obj is None",
            "FP_ParameterError: If filter doesn't exist"
          ],
          "example": "            >>> filter_obj = project.Filter.Find(\"Old Filter\")\n            >>> if filter_obj:\n            ...     project.Filter.Delete(filter_obj)\n\n        Warning:\n            - This is a destructive operation\n            - Cannot be undone\n            - Filter is permanently removed from the project\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a filter, creating a new copy with a new GUID.",
          "description": "Duplicate a filter, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The filter dict object to duplicate (not HVO-based)."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "Not applicable for filters (ignored)."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "Not applicable for filters (ignored)."
            }
          ],
          "returns": "dict: The newly created duplicate filter with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> verb_filter = project.Filter.Find(\"Verbs\")\n            >>> if verb_filter:\n            ...     dup = project.Filter.Duplicate(verb_filter)\n            ...     project.Filter.SetName(dup, \"Verbs Copy\")\n            ...     print(f\"Duplicate: {project.Filter.GetName(dup)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name)",
          "summary": "Check if a filter with the given name exists.",
          "description": "Check if a filter with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The filter name to check"
            }
          ],
          "returns": "bool: True if a filter exists with this name, False otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> if not project.Filter.Exists(\"Verbs\"):\n            ...     verb_filter = project.Filter.Create(\n            ...         \"Verbs\",\n            ...         FilterTypes.LEXENTRY,\n            ...         {\"pos\": \"verb\"}\n            ...     )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ExportFilter",
          "signature": "ExportFilter(filter_obj, file_path)",
          "summary": "Export a filter definition to a JSON file.",
          "description": "Export a filter definition to a JSON file.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object to export"
            },
            {
              "name": "file_path",
              "type": "str",
              "default": null,
              "description": "Path to the output file"
            }
          ],
          "returns": "",
          "raises": [
            "FP_NullParameterError: If filter_obj or file_path is None",
            "FP_ParameterError: If filter_obj is invalid or export fails"
          ],
          "example": "            >>> filter_obj = project.Filter.Find(\"Verbs\")\n            >>> project.Filter.ExportFilter(filter_obj, \"/path/to/verbs.json\")\n\n            >>> # Export all filters\n            >>> for f in project.Filter.GetAll():\n            ...     name = project.Filter.GetName(f)\n            ...     file_name = f\"{name.replace(' ', '_')}.json\"\n            ...     project.Filter.ExportFilter(f, file_name)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name)",
          "summary": "Find a saved filter by name.",
          "description": "Find a saved filter by name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the filter to find"
            }
          ],
          "returns": "dict or None: The filter object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If name is None"
          ],
          "example": "            >>> verb_filter = project.Filter.Find(\"Verbs\")\n            >>> if verb_filter:\n            ...     criteria = project.Filter.GetCriteria(verb_filter)\n            ...     print(f\"Filter criteria: {criteria}\")\n            Filter criteria: {'pos': 'verb'}\n\n            >>> # Check if filter exists\n            >>> if project.Filter.Find(\"Nouns\") is None:\n            ...     print(\"Nouns filter not found\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all saved filters in the project.",
          "description": "Get all saved filters in the project.\n\nThis method returns all filter objects stored in the project,\nregardless of their type.\n",
          "parameters": [],
          "returns": "dict: Each filter object with keys: guid, name, filter_type, criteria ",
          "raises": [],
          "example": "            >>> for filter_obj in project.Filter.GetAll():\n            ...     name = filter_obj['name']\n            ...     filter_type = filter_obj['filter_type']\n            ...     print(f\"{name} ({filter_type})\")\n            Verbs (LexEntry)\n            Nouns (LexEntry)\n            Correct Wordforms (Wordform)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCriteria",
          "signature": "GetCriteria(filter_obj)",
          "summary": "Get the filter criteria definition.",
          "description": "Get the filter criteria definition.\n\nThe criteria is a dictionary that defines the filter conditions.\nThe structure depends on the filter type.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object"
            }
          ],
          "returns": "dict: The filter criteria ",
          "raises": [
            "FP_NullParameterError: If filter_obj is None",
            "FP_ParameterError: If filter_obj is invalid"
          ],
          "example": "            >>> verb_filter = project.Filter.Find(\"Verbs\")\n            >>> criteria = project.Filter.GetCriteria(verb_filter)\n            >>> print(criteria)\n            {'pos': 'verb', 'status': 'approved'}\n\n            >>> # Check specific criterion\n            >>> if criteria.get('pos') == 'verb':\n            ...     print(\"This is a verb filter\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(filter_obj)",
          "summary": "Get the creation date of a filter.",
          "description": "Get the creation date of a filter.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object"
            }
          ],
          "returns": "str: The date and time the filter was created (ISO format string) ",
          "raises": [
            "FP_NullParameterError: If filter_obj is None",
            "FP_ParameterError: If filter_obj is invalid"
          ],
          "example": "            >>> filter_obj = project.Filter.Find(\"Verbs\")\n            >>> created = project.Filter.GetDateCreated(filter_obj)\n            >>> print(f\"Created: {created}\")\n            Created: 2025-01-15 14:30:22\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified(filter_obj)",
          "summary": "Get the last modification date of a filter.",
          "description": "Get the last modification date of a filter.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object"
            }
          ],
          "returns": "str: The date and time the filter was last modified (ISO format string) ",
          "raises": [
            "FP_NullParameterError: If filter_obj is None",
            "FP_ParameterError: If filter_obj is invalid"
          ],
          "example": "            >>> filter_obj = project.Filter.Find(\"Verbs\")\n            >>> modified = project.Filter.GetDateModified(filter_obj)\n            >>> print(f\"Last modified: {modified}\")\n            Last modified: 2025-01-20 09:15:43\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFilterType",
          "signature": "GetFilterType(filter_obj)",
          "summary": "Get the filter type (entry/text/wordform/etc.",
          "description": "Get the filter type (entry/text/wordform/etc.).\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object"
            }
          ],
          "returns": "str: The filter type (from FilterTypes constants) ",
          "raises": [
            "FP_NullParameterError: If filter_obj is None",
            "FP_ParameterError: If filter_obj is invalid"
          ],
          "example": "            >>> filter_obj = project.Filter.Find(\"Verbs\")\n            >>> filter_type = project.Filter.GetFilterType(filter_obj)\n            >>> print(filter_type)\n            LexEntry\n\n            >>> # Check filter type before applying\n            >>> if filter_type == FilterTypes.LEXENTRY:\n            ...     entries = list(project.LexEntry.GetAll())\n            ...     matching = project.Filter.ApplyFilter(filter_obj, entries)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFiltersByType",
          "signature": "GetFiltersByType(filter_type)",
          "summary": "Get all filters of a specific type.",
          "description": "Get all filters of a specific type.\n",
          "parameters": [
            {
              "name": "filter_type",
              "type": "str",
              "default": null,
              "description": "The filter type to retrieve (from FilterTypes)"
            }
          ],
          "returns": "dict: Each filter object of the specified type ",
          "raises": [
            "FP_NullParameterError: If filter_type is None"
          ],
          "example": "            >>> # Get all lexical entry filters\n            >>> for f in project.Filter.GetFiltersByType(FilterTypes.LEXENTRY):\n            ...     name = project.Filter.GetName(f)\n            ...     print(name)\n            Verbs\n            Nouns\n            Adjectives\n\n            >>> # Count wordform filters\n            >>> wf_filters = list(project.Filter.GetFiltersByType(FilterTypes.WORDFORM))\n            >>> print(f\"Found {len(wf_filters)} wordform filters\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(filter_obj)",
          "summary": "Get the GUID of a filter.",
          "description": "Get the GUID of a filter.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object"
            }
          ],
          "returns": "str: The filter's GUID as a string ",
          "raises": [
            "FP_NullParameterError: If filter_obj is None",
            "FP_ParameterError: If filter_obj is invalid"
          ],
          "example": "            >>> filter_obj = project.Filter.Find(\"Verbs\")\n            >>> guid = project.Filter.GetGuid(filter_obj)\n            >>> print(guid)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMatchCount",
          "signature": "GetMatchCount(filter_obj, object_collection=None)",
          "summary": "Get the count of objects matching a filter.",
          "description": "Get the count of objects matching a filter.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object"
            },
            {
              "name": "object_collection",
              "type": "",
              "default": null,
              "description": "Optional collection to count in. If None, uses all objects of the appropriate type from the project."
            }
          ],
          "returns": "int: Number of objects matching the filter criteria ",
          "raises": [
            "FP_NullParameterError: If filter_obj is None",
            "FP_ParameterError: If filter_obj is invalid"
          ],
          "example": "            >>> verb_filter = project.Filter.Find(\"Verbs\")\n            >>> # Count all verbs in project\n            >>> count = project.Filter.GetMatchCount(verb_filter)\n            >>> print(f\"Found {count} verbs\")\n\n            >>> # Count verbs in specific collection\n            >>> recent_entries = get_recent_entries()\n            >>> recent_verb_count = project.Filter.GetMatchCount(\n            ...     verb_filter,\n            ...     recent_entries\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(filter_obj)",
          "summary": "Get the name of a filter.",
          "description": "Get the name of a filter.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object"
            }
          ],
          "returns": "str: The filter name ",
          "raises": [
            "FP_NullParameterError: If filter_obj is None",
            "FP_ParameterError: If filter_obj is invalid"
          ],
          "example": "            >>> for filter_obj in project.Filter.GetAll():\n            ...     name = project.Filter.GetName(filter_obj)\n            ...     print(name)\n            Verbs\n            Nouns\n            Adjectives\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a filter.",
          "description": "Get all syncable properties of a filter.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The filter dict object."
            }
          ],
          "returns": "dict: Dictionary of syncable properties with their values. ",
          "raises": [],
          "example": "            >>> props = project.Filter.GetSyncableProperties(filter_obj)\n            >>> print(props['name'])\n            'Verbs'\n            >>> print(props['filter_type'])\n            'LexEntry'\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ImportFilter",
          "signature": "ImportFilter(file_path, rename_if_exists=False)",
          "summary": "Import a filter definition from a JSON file.",
          "description": "Import a filter definition from a JSON file.\n",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "default": null,
              "description": "Path to the filter file to import"
            },
            {
              "name": "rename_if_exists",
              "type": "bool",
              "default": false,
              "description": "If True, rename the filter if name already exists. If False, raise error on name conflict."
            }
          ],
          "returns": "dict: The imported filter object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If file_path is None",
            "FP_ParameterError: If file doesn't exist, is invalid, or name conflicts"
          ],
          "example": "            >>> # Import a filter\n            >>> imported = project.Filter.ImportFilter(\"/path/to/verbs.json\")\n            >>> print(f\"Imported: {project.Filter.GetName(imported)}\")\n\n            >>> # Import with auto-rename on conflict\n            >>> imported = project.Filter.ImportFilter(\n            ...     \"/path/to/filter.json\",\n            ...     rename_if_exists=True\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetCriteria",
          "signature": "SetCriteria(filter_obj, criteria)",
          "summary": "Set the filter criteria definition.",
          "description": "Set the filter criteria definition.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object"
            },
            {
              "name": "criteria",
              "type": "dict",
              "default": null,
              "description": "The new filter criteria"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If filter_obj or criteria is None",
            "FP_ParameterError: If filter_obj is invalid"
          ],
          "example": "            >>> verb_filter = project.Filter.Find(\"Verbs\")\n            >>> # Update criteria to include transitivity\n            >>> new_criteria = {\n            ...     'pos': 'verb',\n            ...     'status': 'approved',\n            ...     'transitivity': 'transitive'\n            ... }\n            >>> project.Filter.SetCriteria(verb_filter, new_criteria)\n\n            >>> # Replace criteria completely\n            >>> project.Filter.SetCriteria(verb_filter, {'pos': 'noun'})\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(filter_obj, name)",
          "summary": "Set the name of a filter.",
          "description": "Set the name of a filter.\n",
          "parameters": [
            {
              "name": "filter_obj",
              "type": "dict",
              "default": null,
              "description": "The filter object"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name for the filter"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If filter_obj or name is None",
            "FP_ParameterError: If name is empty or filter is invalid"
          ],
          "example": "            >>> filter_obj = project.Filter.Find(\"Verbs\")\n            >>> project.Filter.SetName(filter_obj, \"All Verbs\")\n            >>> print(project.Filter.GetName(filter_obj))\n            All Verbs\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize FilterOperations with a FLExProject instance.",
          "description": "Initialize FilterOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "general",
        "operations"
      ]
    },
    "MediaType": {
      "name": "MediaType",
      "type": "class",
      "namespace": "FlexLibs2.Shared.MediaOperations",
      "source_file": "Shared/MediaOperations",
      "category": "general",
      "summary": "Media file type constants.",
      "description": "Media file type constants.",
      "example": "",
      "base_classes": [],
      "methods": [],
      "properties": [],
      "lcm_dependencies": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "general"
      ]
    },
    "MediaOperations": {
      "name": "MediaOperations",
      "type": "class",
      "namespace": "FlexLibs2.Shared.MediaOperations",
      "source_file": "Shared/MediaOperations",
      "category": "general",
      "summary": "Provides operations for managing media files in a FLEx project.",
      "description": "Provides operations for managing media files in a FLEx project.\n\nMedia files include audio recordings, videos, and images that can be\nattached to lexical entries, pronunciations, examples, and other objects.\nThis class handles both the database references (ICmFile) and file system\noperations for project media.\n\nThis class should be accessed via FLExProject.Media property.\n",
      "example": "        >>> project = FLExProject()\n        >>> project.OpenProject(\"MyProject\", writeEnabled=True)\n        >>> # Get all media files\n        >>> for media in project.Media.GetAll():\n        ...     path = project.Media.GetInternalPath(media)\n        ...     print(path)\n        >>> # Add a new media file\n        >>> media = project.Media.Create(\"/path/to/audio.wav\")\n        >>> # Check media type\n        >>> if project.Media.IsAudio(media):\n        ...     print(\"This is an audio file\")\n        >>> project.CloseProject()",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two media files for differences.",
          "description": "Compare two media files for differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First media object (from project 1)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second media object (from project 2)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional MediaOperations instance for project 1 (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional MediaOperations instance for project 2 (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) - is_different (bool): True if media files differ, False if identical - differences_dict (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(media1, media2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} != {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CopyToProject",
          "signature": "CopyToProject(external_path, internal_subdir='AudioVisual', label=None, wsHandle=None)",
          "summary": "Copy an external file into the project's LinkedFiles directory\nand create a media reference.",
          "description": "Copy an external file into the project's LinkedFiles directory\nand create a media reference.\n",
          "parameters": [
            {
              "name": "external_path",
              "type": "",
              "default": null,
              "description": "Path to the external file to import"
            },
            {
              "name": "internal_subdir",
              "type": "",
              "default": "AudioVisual",
              "description": "Subdirectory within LinkedFiles (default: \"AudioVisual\")"
            },
            {
              "name": "label",
              "type": "",
              "default": null,
              "description": "Optional descriptive label for the media file"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmFile: The created media file object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If external_path is None",
            "FP_ParameterError: If external_path is empty or file doesn't exist"
          ],
          "example": "            >>> # Import an external audio file\n            >>> media = project.Media.CopyToProject(\n            ...     \"/home/user/recordings/audio.wav\",\n            ...     internal_subdir=\"AudioVisual\",\n            ...     label=\"Speaker 1\"\n            ... )\n            >>> print(project.Media.GetInternalPath(media))\n            LinkedFiles/AudioVisual/audio.wav\n\n            >>> # Import an image\n            >>> photo = project.Media.CopyToProject(\n            ...     \"/home/user/photos/item.jpg\",\n            ...     internal_subdir=\"Pictures\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(file_path, label=None, wsHandle=None)",
          "summary": "Create a new media file reference in the FLEx project.",
          "description": "Create a new media file reference in the FLEx project.\n",
          "parameters": [
            {
              "name": "file_path",
              "type": "",
              "default": null,
              "description": "The file path (internal to project or external)"
            },
            {
              "name": "label",
              "type": "",
              "default": null,
              "description": "Optional descriptive label for the media file"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmFile: The newly created media file object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If file_path is None",
            "FP_ParameterError: If file_path is empty"
          ],
          "example": "            >>> # Create media file reference\n            >>> media = project.Media.Create(\"LinkedFiles/AudioVisual/audio.wav\")\n            >>> print(project.Media.GetInternalPath(media))\n            LinkedFiles/AudioVisual/audio.wav\n\n            >>> # Create with label\n            >>> media = project.Media.Create(\"audio/recording.wav\",\n            ...                               label=\"Speaker 1\")\n            >>> print(project.Media.GetLabel(media, \"en\"))\n            Speaker 1\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(media_or_hvo)",
          "summary": "Delete a media file reference from the FLEx project.",
          "description": "Delete a media file reference from the FLEx project.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO (database ID)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> if media:\n            ...     project.Media.Delete(media)\n\n            >>> # Delete by HVO\n            >>> project.Media.Delete(12345)\n\n        Warning:\n            - This is a destructive operation\n            - Removes the database reference only\n            - Does NOT delete the actual file from disk\n            - References from other objects will be removed\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a media file reference, creating a new reference to the same file.",
          "description": "Duplicate a media file reference, creating a new reference to the same file.\n\nThis method creates a copy of the media file reference (ICmFile object) in\nthe database. The duplicate points to the SAME physical file - the file\nitself is NOT duplicated on disk. Use copy_file=True to create a physical\ncopy of the file.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO (database ID)"
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "Not applicable for media files (they are not in a sequence). Parameter kept for consistency with other Duplicate() methods."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, the physical file is also copied with a new name. If False, only the database reference is duplicated (both references point to the same file)."
            }
          ],
          "returns": "ICmFile: The newly created duplicate media file reference ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If item_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> # Shallow duplicate (reference only, same file)\n            >>> media = project.Media.Find(\"audio.wav\")\n            >>> duplicate = project.Media.Duplicate(media, deep=False)\n            >>> print(project.Media.GetInternalPath(duplicate))\n            LinkedFiles/AudioVisual/audio.wav\n            >>> print(project.Media.GetLabel(duplicate, \"en\"))\n            Speaker 1 (copy)\n\n            >>> # Deep duplicate (copy the physical file too)\n            >>> duplicate = project.Media.Duplicate(media, deep=True)\n            >>> print(project.Media.GetInternalPath(duplicate))\n            LinkedFiles/AudioVisual/audio_copy.wav\n\n        Warning:\n            - With deep=False, both references point to the SAME file\n            - Deleting the file affects both references\n            - With deep=True, the file is physically copied (doubles disk space)\n            - The duplicate will have a \" (copy)\" suffix in the label\n            - insert_after parameter is ignored (media not in a sequence)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(filename)",
          "summary": "Check if a media file exists in the FLEx project.",
          "description": "Check if a media file exists in the FLEx project.\n",
          "parameters": [
            {
              "name": "filename",
              "type": "",
              "default": null,
              "description": "The filename or path to check"
            }
          ],
          "returns": "bool: True if the media file exists, False otherwise ",
          "raises": [],
          "example": "            >>> if project.Media.Exists(\"audio.wav\"):\n            ...     media = project.Media.Find(\"audio.wav\")\n            ... else:\n            ...     media = project.Media.Create(\"audio.wav\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(filename)",
          "summary": "Find a media file by its filename (internal path).",
          "description": "Find a media file by its filename (internal path).\n",
          "parameters": [
            {
              "name": "filename",
              "type": "",
              "default": null,
              "description": "The filename or path to search for (case-sensitive)"
            }
          ],
          "returns": "ICmFile or None: The media file object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If filename is None"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> if media:\n            ...     print(f\"Found: {project.Media.GetInternalPath(media)}\")\n            Found: LinkedFiles/AudioVisual/audio.wav\n\n            >>> # Search with full path\n            >>> media = project.Media.Find(\"LinkedFiles/AudioVisual/audio.wav\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Retrieve all media files in the FLEx project.",
          "description": "Retrieve all media files in the FLEx project.\n\nThis method returns an iterator over all ICmFile objects in the\nproject database, allowing iteration over the complete media inventory.\n",
          "parameters": [],
          "returns": "ICmFile: Each media file object in the project ",
          "raises": [],
          "example": "            >>> for media in project.Media.GetAll():\n            ...     path = project.Media.GetInternalPath(media)\n            ...     label = project.Media.GetLabel(media, \"en\")\n            ...     print(f\"{label}: {path}\")\n            Recording1: audio/recording1.wav\n            Video1: videos/intro.mp4\n            Photo1: images/photo1.jpg\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllByType",
          "signature": "GetAllByType(media_type)",
          "summary": "Get all media files of a specific type.",
          "description": "Get all media files of a specific type.\n",
          "parameters": [
            {
              "name": "media_type",
              "type": "",
              "default": null,
              "description": "Media type constant (MediaType.AUDIO, VIDEO, IMAGE)"
            }
          ],
          "returns": "ICmFile: Each media file of the specified type ",
          "raises": [
            "FP_ParameterError: If media_type is invalid"
          ],
          "example": "            >>> # Get all audio files\n            >>> for media in project.Media.GetAllByType(MediaType.AUDIO):\n            ...     path = project.Media.GetInternalPath(media)\n            ...     print(f\"Audio: {path}\")\n            Audio: audio1.wav\n            Audio: audio2.mp3\n\n            >>> # Count videos\n            >>> video_count = sum(1 for _ in project.Media.GetAllByType(MediaType.VIDEO))\n            >>> print(f\"Total videos: {video_count}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetExternalPath",
          "signature": "GetExternalPath(media_or_hvo)",
          "summary": "Get the external (absolute) path of a media file.",
          "description": "Get the external (absolute) path of a media file.\n\nThis resolves the internal path to an absolute file system path,\nrelative to the project's LinkedFiles directory if needed.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "str: The absolute file path (may not exist on disk) ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> path = project.Media.GetExternalPath(media)\n            >>> print(path)\n            C:/Users/Me/Documents/FieldWorks/Projects/MyProject/LinkedFiles/AudioVisual/audio.wav\n\n            >>> # Check if file exists on disk\n            >>> import os\n            >>> if os.path.exists(path):\n            ...     print(\"File exists\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFileSize",
          "signature": "GetFileSize(media_or_hvo)",
          "summary": "Get the file size of a media file in bytes.",
          "description": "Get the file size of a media file in bytes.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "int: File size in bytes, or -1 if file doesn't exist ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> size = project.Media.GetFileSize(media)\n            >>> print(f\"File size: {size / 1024:.2f} KB\")\n            File size: 1234.56 KB\n\n            >>> # Get size in human-readable format\n            >>> if size > 1024 * 1024:\n            ...     print(f\"{size / (1024 * 1024):.2f} MB\")\n            ... elif size > 1024:\n            ...     print(f\"{size / 1024:.2f} KB\")\n            ... else:\n            ...     print(f\"{size} bytes\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(media_or_hvo)",
          "summary": "Get the GUID (Globally Unique Identifier) of a media file.",
          "description": "Get the GUID (Globally Unique Identifier) of a media file.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "System.Guid: The media file's GUID ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> guid = project.Media.GetGuid(media)\n            >>> print(guid)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\n            >>> # Get as string\n            >>> guid_str = str(guid)\n            >>> print(guid_str)\n            a1b2c3d4-e5f6-7890-abcd-ef1234567890\n\n            >>> # Use GUID to retrieve media later\n            >>> media2 = project.Object(guid)\n            >>> print(project.Media.GetInternalPath(media2))\n            audio.wav\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetHvo",
          "signature": "GetHvo(media)",
          "summary": "Get the HVO (database ID) of a media file.",
          "description": "Get the HVO (database ID) of a media file.\n",
          "parameters": [
            {
              "name": "media",
              "type": "",
              "default": null,
              "description": "An ICmFile object"
            }
          ],
          "returns": "int: The media file's HVO ",
          "raises": [
            "FP_NullParameterError: If media is None"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> hvo = project.Media.GetHvo(media)\n            >>> print(hvo)\n            12345\n\n            >>> # Use HVO to retrieve media later\n            >>> media2 = project.Object(hvo)\n            >>> print(project.Media.GetInternalPath(media2))\n            audio.wav\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetInternalPath",
          "signature": "GetInternalPath(media_or_hvo)",
          "summary": "Get the internal path of a media file.",
          "description": "Get the internal path of a media file.\n\nThe internal path is the file location relative to the project's\nLinkedFiles directory or an absolute path.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "str: The internal path (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> path = project.Media.GetInternalPath(media)\n            >>> print(path)\n            LinkedFiles/AudioVisual/audio.wav\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLabel",
          "signature": "GetLabel(media_or_hvo, wsHandle=None)",
          "summary": "Get the label/description of a media file.",
          "description": "Get the label/description of a media file.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The label text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> label = project.Media.GetLabel(media, \"en\")\n            >>> print(label)\n            Speaker 1 pronunciation\n\n            >>> # Get in specific writing system\n            >>> label_fr = project.Media.GetLabel(media, \"fr\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMediaType",
          "signature": "GetMediaType(media_or_hvo)",
          "summary": "Get the media type (audio/video/image) based on file extension.",
          "description": "Get the media type (audio/video/image) based on file extension.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "int: Media type constant (MediaType.AUDIO, VIDEO, IMAGE, or UNKNOWN) ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> media_type = project.Media.GetMediaType(media)\n            >>> if media_type == MediaType.AUDIO:\n            ...     print(\"This is an audio file\")\n            This is an audio file\n\n            >>> # Check type name\n            >>> type_names = {MediaType.AUDIO: \"Audio\",\n            ...               MediaType.VIDEO: \"Video\",\n            ...               MediaType.IMAGE: \"Image\",\n            ...               MediaType.UNKNOWN: \"Unknown\"}\n            >>> print(type_names[media_type])\n            Audio\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOrphanedMedia",
          "signature": "GetOrphanedMedia()",
          "summary": "Get all media files that are not referenced by any object.",
          "description": "Get all media files that are not referenced by any object.\n",
          "parameters": [],
          "returns": "ICmFile: Each orphaned media file ",
          "raises": [],
          "example": "            >>> # Find orphaned media files\n            >>> orphaned = list(project.Media.GetOrphanedMedia())\n            >>> print(f\"Found {len(orphaned)} orphaned media files\")\n            Found 5 orphaned media files\n\n            >>> # Delete orphaned media\n            >>> for media in project.Media.GetOrphanedMedia():\n            ...     path = project.Media.GetInternalPath(media)\n            ...     print(f\"Deleting orphaned: {path}\")\n            ...     project.Media.Delete(media)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwnerCount",
          "signature": "GetOwnerCount(media_or_hvo)",
          "summary": "Get the count of objects referencing this media file.",
          "description": "Get the count of objects referencing this media file.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "int: Number of objects using this media file ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> count = project.Media.GetOwnerCount(media)\n            >>> print(f\"Used by {count} objects\")\n            Used by 3 objects\n\n            >>> # Check if media is orphaned\n            >>> if project.Media.GetOwnerCount(media) == 0:\n            ...     print(\"This media file is not used anywhere\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwners",
          "signature": "GetOwners(media_or_hvo)",
          "summary": "Get all objects that reference this media file.",
          "description": "Get all objects that reference this media file.\n\nReturns objects (entries, pronunciations, examples, etc.) that\nhave this media file attached.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "list: List of objects referencing this media file (empty if none) ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> owners = project.Media.GetOwners(media)\n            >>> for owner in owners:\n            ...     print(f\"Owner: {owner.ClassName} (HVO: {owner.Hvo})\")\n            Owner: LexPronunciation (HVO: 12345)\n            Owner: LexExampleSentence (HVO: 67890)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a media file.",
          "description": "Get all syncable properties of a media file.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ICmFile object."
            }
          ],
          "returns": "dict: Dictionary of syncable properties with their values. ",
          "raises": [],
          "example": "            >>> props = project.Media.GetSyncableProperties(media)\n            >>> print(props['InternalPath'])\n            'LinkedFiles/AudioVisual/audio.wav'\n            >>> print(props['Description'])\n            {'en': 'Speaker 1 recording'}\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsAudio",
          "signature": "IsAudio(media_or_hvo)",
          "summary": "Check if a media file is an audio file.",
          "description": "Check if a media file is an audio file.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "bool: True if the file is audio, False otherwise ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> if project.Media.IsAudio(media):\n            ...     print(\"This is an audio file\")\n            This is an audio file\n\n            >>> # Process all audio files\n            >>> for media in project.Media.GetAll():\n            ...     if project.Media.IsAudio(media):\n            ...         # Process audio file\n            ...         pass\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsImage",
          "signature": "IsImage(media_or_hvo)",
          "summary": "Check if a media file is an image file.",
          "description": "Check if a media file is an image file.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "bool: True if the file is image, False otherwise ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"photo.jpg\")\n            >>> if project.Media.IsImage(media):\n            ...     print(\"This is an image file\")\n            This is an image file\n\n            >>> # Get all image files\n            >>> images = [m for m in project.Media.GetAll()\n            ...           if project.Media.IsImage(m)]\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsValid",
          "signature": "IsValid(media_or_hvo)",
          "summary": "Check if a media file's referenced file exists on disk.",
          "description": "Check if a media file's referenced file exists on disk.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "bool: True if the file exists on disk, False otherwise ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> if project.Media.IsValid(media):\n            ...     print(\"File exists on disk\")\n            ... else:\n            ...     print(\"File is missing!\")\n\n            >>> # Find all missing media files\n            >>> for media in project.Media.GetAll():\n            ...     if not project.Media.IsValid(media):\n            ...         path = project.Media.GetInternalPath(media)\n            ...         print(f\"Missing: {path}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsVideo",
          "signature": "IsVideo(media_or_hvo)",
          "summary": "Check if a media file is a video file.",
          "description": "Check if a media file is a video file.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            }
          ],
          "returns": "bool: True if the file is video, False otherwise ",
          "raises": [
            "FP_NullParameterError: If media_or_hvo is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"intro.mp4\")\n            >>> if project.Media.IsVideo(media):\n            ...     print(\"This is a video file\")\n            This is a video file\n\n            >>> # Count video files\n            >>> video_count = sum(1 for m in project.Media.GetAll()\n            ...                   if project.Media.IsVideo(m))\n            >>> print(f\"Total videos: {video_count}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RenameMediaFile",
          "signature": "RenameMediaFile(media_or_hvo, new_filename)",
          "summary": "Rename a media file on disk and update the database reference.",
          "description": "Rename a media file on disk and update the database reference.\n\nThis is an atomic operation that:\n1. Validates parameters and checks write permissions\n2. Gets current internal and external paths\n3. Constructs new paths with new filename\n4. Renames the physical file in LinkedFiles directory\n5. Updates the InternalPath in the database\n6. Handles filename conflicts (adds suffix if needed)\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO (database ID)"
            },
            {
              "name": "new_filename",
              "type": "",
              "default": null,
              "description": "New filename (without path, just filename.ext)"
            }
          ],
          "returns": "str: The actual new internal path (may differ if conflict occurred) ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If media_or_hvo or new_filename is None",
            "FP_ParameterError: If media doesn't exist, filename is invalid,",
            "or contains path separators",
            "OSError: If file doesn't exist or rename operation fails"
          ],
          "example": "            >>> # Rename an audio file\n            >>> media = project.Media.Find(\"LinkedFiles/AudioVisual/old_name.wav\")\n            >>> new_path = project.Media.RenameMediaFile(media, \"new_name.wav\")\n            >>> print(new_path)\n            LinkedFiles/AudioVisual/new_name.wav\n\n            >>> # Handles conflicts automatically\n            >>> media2 = project.Media.Find(\"LinkedFiles/AudioVisual/temp.wav\")\n            >>> new_path = project.Media.RenameMediaFile(media2, \"new_name.wav\")\n            >>> print(new_path)\n            LinkedFiles/AudioVisual/new_name_1.wav\n\n            >>> # Rename by HVO\n            >>> new_path = project.Media.RenameMediaFile(12345, \"recording.wav\")\n\n        Warning:\n            - Renames the physical file on disk\n            - This is a destructive operation\n            - If new filename already exists, adds _1, _2, etc. suffix\n            - Cannot be undone\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetInternalPath",
          "signature": "SetInternalPath(media_or_hvo, path)",
          "summary": "Set the internal path of a media file.",
          "description": "Set the internal path of a media file.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            },
            {
              "name": "path",
              "type": "",
              "default": null,
              "description": "The new internal path to set"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If media_or_hvo or path is None",
            "FP_ParameterError: If path is empty or media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> project.Media.SetInternalPath(media,\n            ...                                \"LinkedFiles/AudioVisual/new_audio.wav\")\n            >>> print(project.Media.GetInternalPath(media))\n            LinkedFiles/AudioVisual/new_audio.wav\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLabel",
          "signature": "SetLabel(media_or_hvo, text, wsHandle=None)",
          "summary": "Set the label/description of a media file.",
          "description": "Set the label/description of a media file.\n",
          "parameters": [
            {
              "name": "media_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmFile object or its HVO"
            },
            {
              "name": "text",
              "type": "",
              "default": null,
              "description": "The label text to set"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If media_or_hvo or text is None",
            "FP_ParameterError: If media doesn't exist"
          ],
          "example": "            >>> media = project.Media.Find(\"audio.wav\")\n            >>> project.Media.SetLabel(media, \"Speaker 1 pronunciation\", \"en\")\n            >>> print(project.Media.GetLabel(media, \"en\"))\n            Speaker 1 pronunciation\n\n            >>> # Set in multiple writing systems\n            >>> project.Media.SetLabel(media, \"Pronunciation locuteur 1\", \"fr\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize MediaOperations.",
          "description": "Initialize MediaOperations.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "FLExProject instance"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "general",
        "operations"
      ]
    },
    "AnnotationDefOperations": {
      "name": "AnnotationDefOperations",
      "type": "class",
      "namespace": "FlexLibs2.System.AnnotationDefOperations",
      "source_file": "System/AnnotationDefOperations",
      "category": "system",
      "summary": "This class provides operations for managing annotation type definitions\nin a FieldWorks project.",
      "description": "This class provides operations for managing annotation type definitions\nin a FieldWorks project.\n\nAnnotation definitions specify the types and characteristics of annotations\n(notes, comments) that can be created in FLEx. They define properties such\nas name, help text, whether users can create instances, and whether multiple\nannotations of this type are allowed.\n\nThis class should be accessed via FLExProject.AnnotationDef property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all annotation definitions\nfor anno_def in project.AnnotationDef.GetAll():\nname = project.AnnotationDef.GetName(anno_def)\nanno_type = project.AnnotationDef.GetAnnotationType(anno_def)\nprint(f\"{name}: {anno_type}\")\n\n# Find a specific annotation definition\ntodo_def = project.AnnotationDef.Find(\"To Do\")\nif todo_def:\n# Get properties\nhelp_text = project.AnnotationDef.GetHelpString(todo_def)\nuser_can_create = project.AnnotationDef.GetUserCanCreate(todo_def)\nprint(f\"Help: {help_text}\")\nprint(f\"User creatable: {user_can_create}\")\n\n# Create a new annotation definition\ncustom_def = project.AnnotationDef.Create(\n\"Review Required\",\nCmAnnotationType.katGeneralNote,\n\"en\"\n)\nproject.AnnotationDef.SetHelpString(custom_def,\n\"Mark entries that need review\", \"en\")\nproject.AnnotationDef.SetUserCanCreate(custom_def, True)\n\n# Get annotation definitions by type\nfor note_def in project.AnnotationDef.FindByType(\nCmAnnotationType.katGeneralNote):\nname = project.AnnotationDef.GetName(note_def)\nprint(f\"Note type: {name}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two annotation definitions and return detailed differences.",
          "description": "Compare two annotation definitions and return detailed differences.",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null
            },
            {
              "name": "item2",
              "type": "",
              "default": null
            },
            {
              "name": "ops1",
              "type": "",
              "default": null
            },
            {
              "name": "ops2",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, annotation_type, wsHandle=None, parent=None)",
          "summary": "Create a new annotation definition.",
          "description": "Create a new annotation definition.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the annotation definition."
            },
            {
              "name": "annotation_type",
              "type": "CmAnnotationType",
              "default": null,
              "description": "The annotation type enumeration."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            },
            {
              "name": "parent",
              "type": "ICmAnnotationDefn, optional",
              "default": null,
              "description": "Parent definition for creating a sub-type. If None, creates a top-level definition."
            }
          ],
          "returns": "ICmAnnotationDefn: The newly created annotation definition. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If name or annotation_type is None.",
            "FP_ParameterError: If name is empty or already exists."
          ],
          "example": "            >>> # Create a top-level annotation definition\n            >>> custom_def = project.AnnotationDef.Create(\n            ...     \"Review Required\",\n            ...     CmAnnotationType.katGeneralNote,\n            ...     \"en\"\n            ... )\n            >>> print(project.AnnotationDef.GetName(custom_def))\n            Review Required\n\n            >>> # Create a sub-type under an existing definition\n            >>> todo_def = project.AnnotationDef.Find(\"To Do\")\n            >>> urgent_def = project.AnnotationDef.Create(\n            ...     \"Urgent\",\n            ...     CmAnnotationType.katGeneralNote,\n            ...     \"en\",\n            ...     parent=todo_def\n            ... )\n\n            >>> # Set properties for new definition\n            >>> project.AnnotationDef.SetUserCanCreate(custom_def, True)\n            >>> project.AnnotationDef.SetHelpString(custom_def,\n            ...     \"Marks entries requiring review\", \"en\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(anno_def)",
          "summary": "Delete an annotation definition.",
          "description": "Delete an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object to delete."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If anno_def is None.",
            "FP_ParameterError: If trying to delete a system definition."
          ],
          "example": "            >>> # Delete a custom annotation definition\n            >>> custom = project.AnnotationDef.Find(\"Old Custom Type\")\n            >>> if custom:\n            ...     project.AnnotationDef.Delete(custom)\n\n        Warning:\n            - DO NOT delete system annotation definitions\n            - Deletion is permanent and cannot be undone\n            - Any annotations using this definition will be affected\n            - Deletes all sub-definitions recursively\n            - Only delete custom definitions you created\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate an annotation definition, creating a new copy with a new GUID.",
          "description": "Duplicate an annotation definition, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source definition. If False, insert at end of parent's list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate sub-possibilities. If False (default), only copy simple properties."
            }
          ],
          "returns": "ICmAnnotationDefn: The newly created duplicate with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> todo = project.AnnotationDef.Find(\"To Do\")\n            >>> if todo:\n            ...     dup = project.AnnotationDef.Duplicate(todo)\n            ...     print(f\"Duplicate GUID: {project.AnnotationDef.GetGuid(dup)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name, wsHandle=None)",
          "summary": "Check if an annotation definition with the given name exists.",
          "description": "Check if an annotation definition with the given name exists.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to check."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "bool: True if the annotation definition exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> if project.AnnotationDef.Exists(\"To Do\"):\n            ...     print(\"To Do annotation type exists\")\n            To Do annotation type exists\n\n            >>> if not project.AnnotationDef.Exists(\"Custom\"):\n            ...     print(\"Custom type does not exist\")\n            Custom type does not exist\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(name, wsHandle=None)",
          "summary": "Find an annotation definition by name.",
          "description": "Find an annotation definition by name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name to search for (case-sensitive)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmAnnotationDefn or None: The annotation definition if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None."
          ],
          "example": "            >>> # Find by name\n            >>> todo_def = project.AnnotationDef.Find(\"To Do\")\n            >>> if todo_def:\n            ...     print(f\"Found: {project.AnnotationDef.GetName(todo_def)}\")\n            ... else:\n            ...     print(\"Not found\")\n            Found: To Do\n\n            >>> # Use to check if definition exists\n            >>> if not project.AnnotationDef.Find(\"Custom Type\"):\n            ...     # Create it\n            ...     custom = project.AnnotationDef.Create(\n            ...         \"Custom Type\",\n            ...         CmAnnotationType.katGeneralNote\n            ...     )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByType",
          "signature": "FindByType(annotation_type)",
          "summary": "Find all annotation definitions of a specific type.",
          "description": "Find all annotation definitions of a specific type.\n",
          "parameters": [
            {
              "name": "annotation_type",
              "type": "CmAnnotationType",
              "default": null,
              "description": "The annotation type to search for."
            }
          ],
          "returns": "ICmAnnotationDefn: Each annotation definition matching the type. ",
          "raises": [
            "FP_NullParameterError: If annotation_type is None."
          ],
          "example": "            >>> from SIL.LCModel import CmAnnotationType\n            >>> # Get all general note types\n            >>> for note_def in project.AnnotationDef.FindByType(\n            ...         CmAnnotationType.katGeneralNote):\n            ...     name = project.AnnotationDef.GetName(note_def)\n            ...     print(f\"Note type: {name}\")\n            Note type: To Do\n            Note type: Question\n            Note type: Review Required\n\n            >>> # Count question types\n            >>> question_types = list(project.AnnotationDef.FindByType(\n            ...     CmAnnotationType.katQuestionNote))\n            >>> print(f\"Found {len(question_types)} question types\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all annotation definitions in the project.",
          "description": "Get all annotation definitions in the project.\n",
          "parameters": [],
          "returns": "ICmAnnotationDefn: Each annotation definition in the project. ",
          "raises": [],
          "example": "            >>> for anno_def in project.AnnotationDef.GetAll():\n            ...     name = project.AnnotationDef.GetName(anno_def)\n            ...     anno_type = project.AnnotationDef.GetAnnotationType(anno_def)\n            ...     user_create = project.AnnotationDef.GetUserCanCreate(anno_def)\n            ...     print(f\"{name} ({anno_type}): user_create={user_create}\")\n            To Do (katGeneralNote): user_create=True\n            Question (katGeneralNote): user_create=True\n            Resolved (katGeneralNote): user_create=False\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnnotationType",
          "signature": "GetAnnotationType(anno_def)",
          "summary": "Get the annotation type of an annotation definition.",
          "description": "Get the annotation type of an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            }
          ],
          "returns": "int: The annotation type enumeration value (CmAnnotationType). ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> from SIL.LCModel import CmAnnotationType\n            >>> todo_def = project.AnnotationDef.Find(\"To Do\")\n            >>> if todo_def:\n            ...     anno_type = project.AnnotationDef.GetAnnotationType(todo_def)\n            ...     if anno_type == int(CmAnnotationType.katGeneralNote):\n            ...         print(\"This is a general note type\")\n            This is a general note type\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCopyCutPasteAllowed",
          "signature": "GetCopyCutPasteAllowed(anno_def)",
          "summary": "Check if copy/cut/paste operations are allowed for this type.",
          "description": "Check if copy/cut/paste operations are allowed for this type.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            }
          ],
          "returns": "bool: True if copy/cut/paste allowed, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> todo_def = project.AnnotationDef.Find(\"To Do\")\n            >>> if todo_def:\n            ...     can_copy = project.AnnotationDef.GetCopyCutPasteAllowed(todo_def)\n            ...     if can_copy:\n            ...         print(\"Can copy/paste To Do annotations\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated(anno_def)",
          "summary": "Get the creation date of an annotation definition.",
          "description": "Get the creation date of an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            }
          ],
          "returns": "System.DateTime: The creation date/time, or None if not set. ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> custom = project.AnnotationDef.Find(\"Custom Review\")\n            >>> if custom:\n            ...     date = project.AnnotationDef.GetDateCreated(custom)\n            ...     if date:\n            ...         print(f\"Created: {date}\")\n            Created: 11/23/2025 10:30:45 AM\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(anno_def)",
          "summary": "Get the GUID of an annotation definition.",
          "description": "Get the GUID of an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            }
          ],
          "returns": "System.Guid: The GUID of the annotation definition. ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> todo_def = project.AnnotationDef.Find(\"To Do\")\n            >>> if todo_def:\n            ...     guid = project.AnnotationDef.GetGuid(todo_def)\n            ...     print(f\"GUID: {guid}\")\n            GUID: 12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetHelpString",
          "signature": "GetHelpString(anno_def, wsHandle=None)",
          "summary": "Get the help string (description) of an annotation definition.",
          "description": "Get the help string (description) of an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The help string, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> todo_def = project.AnnotationDef.Find(\"To Do\")\n            >>> if todo_def:\n            ...     help_text = project.AnnotationDef.GetHelpString(todo_def)\n            ...     print(f\"Help: {help_text}\")\n            Help: Marks items that need to be done\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetInstanceOf",
          "signature": "GetInstanceOf(anno_def)",
          "summary": "Get the class that this annotation definition is an instance of.",
          "description": "Get the class that this annotation definition is an instance of.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            }
          ],
          "returns": "int: The class ID that this definition instantiates. ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> todo_def = project.AnnotationDef.Find(\"To Do\")\n            >>> if todo_def:\n            ...     class_id = project.AnnotationDef.GetInstanceOf(todo_def)\n            ...     print(f\"Instance of class: {class_id}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMultiple",
          "signature": "GetMultiple(anno_def)",
          "summary": "Check if multiple annotations of this type are allowed.",
          "description": "Check if multiple annotations of this type are allowed.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            }
          ],
          "returns": "bool: True if multiple annotations allowed, False if only one. ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> todo_def = project.AnnotationDef.Find(\"To Do\")\n            >>> if todo_def:\n            ...     allows_multiple = project.AnnotationDef.GetMultiple(todo_def)\n            ...     if allows_multiple:\n            ...         print(\"Can have multiple To Do notes per item\")\n            ...     else:\n            ...         print(\"Only one To Do note allowed per item\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(anno_def, wsHandle=None)",
          "summary": "Get the name of an annotation definition.",
          "description": "Get the name of an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The name, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> for anno_def in project.AnnotationDef.GetAll():\n            ...     name = project.AnnotationDef.GetName(anno_def)\n            ...     print(f\"Definition: {name}\")\n            Definition: To Do\n            Definition: Question\n            Definition: Resolved\n\n        See Also:\n            SetName, Find",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetPrompt",
          "signature": "GetPrompt(anno_def, wsHandle=None)",
          "summary": "Get the prompt text for an annotation definition.",
          "description": "Get the prompt text for an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The prompt text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> todo_def = project.AnnotationDef.Find(\"To Do\")\n            >>> if todo_def:\n            ...     prompt = project.AnnotationDef.GetPrompt(todo_def)\n            ...     print(f\"Prompt: {prompt}\")\n            Prompt: Enter what needs to be done\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetUserCanCreate",
          "signature": "GetUserCanCreate(anno_def)",
          "summary": "Check if users can create annotations of this type.",
          "description": "Check if users can create annotations of this type.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            }
          ],
          "returns": "bool: True if users can create this type, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If anno_def is None."
          ],
          "example": "            >>> for anno_def in project.AnnotationDef.GetAll():\n            ...     name = project.AnnotationDef.GetName(anno_def)\n            ...     can_create = project.AnnotationDef.GetUserCanCreate(anno_def)\n            ...     print(f\"{name}: user_can_create={can_create}\")\n            To Do: user_can_create=True\n            Question: user_can_create=True\n            System Only: user_can_create=False\n\n            >>> # Filter to user-creatable types only\n            >>> user_types = [d for d in project.AnnotationDef.GetAll()\n            ...     if project.AnnotationDef.GetUserCanCreate(d)]\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetUserCreatableTypes",
          "signature": "GetUserCreatableTypes()",
          "summary": "Get all annotation definitions that users can create.",
          "description": "Get all annotation definitions that users can create.\n",
          "parameters": [],
          "returns": "ICmAnnotationDefn: Each user-creatable annotation definition. ",
          "raises": [],
          "example": "            >>> # Get types available to users\n            >>> for anno_def in project.AnnotationDef.GetUserCreatableTypes():\n            ...     name = project.AnnotationDef.GetName(anno_def)\n            ...     anno_type = project.AnnotationDef.GetAnnotationType(anno_def)\n            ...     print(f\"Available: {name} (type={anno_type})\")\n            Available: To Do (type=0)\n            Available: Question (type=1)\n            Available: Custom Review (type=0)\n\n            >>> # Count user-creatable types\n            >>> count = len(list(project.AnnotationDef.GetUserCreatableTypes()))\n            >>> print(f\"Users can create {count} annotation types\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetHelpString",
          "signature": "SetHelpString(anno_def, help_string, wsHandle=None)",
          "summary": "Set the help string (description) of an annotation definition.",
          "description": "Set the help string (description) of an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            },
            {
              "name": "help_string",
              "type": "str",
              "default": null,
              "description": "The help text to set."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If anno_def or help_string is None."
          ],
          "example": "            >>> custom_def = project.AnnotationDef.Create(\n            ...     \"Review Required\",\n            ...     CmAnnotationType.katGeneralNote\n            ... )\n            >>> project.AnnotationDef.SetHelpString(\n            ...     custom_def,\n            ...     \"Marks entries that require linguistic review\",\n            ...     \"en\"\n            ... )\n            >>> print(project.AnnotationDef.GetHelpString(custom_def))\n            Marks entries that require linguistic review\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetMultiple",
          "signature": "SetMultiple(anno_def, allow_multiple)",
          "summary": "Set whether multiple annotations of this type are allowed.",
          "description": "Set whether multiple annotations of this type are allowed.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            },
            {
              "name": "allow_multiple",
              "type": "bool",
              "default": null,
              "description": "True to allow multiple, False for one only."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If anno_def or allow_multiple is None."
          ],
          "example": "            >>> # Allow multiple review notes\n            >>> review_def = project.AnnotationDef.Find(\"Review\")\n            >>> if review_def:\n            ...     project.AnnotationDef.SetMultiple(review_def, True)\n\n            >>> # Allow only one status annotation\n            >>> status_def = project.AnnotationDef.Find(\"Status\")\n            >>> if status_def:\n            ...     project.AnnotationDef.SetMultiple(status_def, False)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(anno_def, name, wsHandle=None)",
          "summary": "Set the name of an annotation definition.",
          "description": "Set the name of an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If anno_def or name is None.",
            "FP_ParameterError: If name is empty."
          ],
          "example": "            >>> custom = project.AnnotationDef.Find(\"Custom\")\n            >>> if custom:\n            ...     project.AnnotationDef.SetName(custom, \"Custom Review\", \"en\")\n            ...     print(project.AnnotationDef.GetName(custom))\n            Custom Review\n\n        Warning:\n            - Renaming system definitions is not recommended\n            - Only rename custom definitions you created\n            - Changes affect display throughout FLEx\n\n        See Also:\n            GetName, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetPrompt",
          "signature": "SetPrompt(anno_def, prompt_text, wsHandle=None)",
          "summary": "Set the prompt text for an annotation definition.",
          "description": "Set the prompt text for an annotation definition.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            },
            {
              "name": "prompt_text",
              "type": "str",
              "default": null,
              "description": "The prompt text to set."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If anno_def or prompt_text is None."
          ],
          "example": "            >>> custom_def = project.AnnotationDef.Create(\n            ...     \"Review\",\n            ...     CmAnnotationType.katGeneralNote\n            ... )\n            >>> project.AnnotationDef.SetPrompt(\n            ...     custom_def,\n            ...     \"Describe what needs to be reviewed\",\n            ...     \"en\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetUserCanCreate",
          "signature": "SetUserCanCreate(anno_def, can_create)",
          "summary": "Set whether users can create annotations of this type.",
          "description": "Set whether users can create annotations of this type.\n",
          "parameters": [
            {
              "name": "anno_def",
              "type": "",
              "default": null,
              "description": "The ICmAnnotationDefn object."
            },
            {
              "name": "can_create",
              "type": "bool",
              "default": null,
              "description": "True to allow user creation, False to restrict."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled.",
            "FP_NullParameterError: If anno_def or can_create is None."
          ],
          "example": "            >>> # Make a custom type user-creatable\n            >>> custom = project.AnnotationDef.Find(\"Custom Review\")\n            >>> if custom:\n            ...     project.AnnotationDef.SetUserCanCreate(custom, True)\n            ...     print(f\"Can create: {project.AnnotationDef.GetUserCanCreate(custom)}\")\n            Can create: True\n\n            >>> # Hide a deprecated type from users\n            >>> old_type = project.AnnotationDef.Find(\"Old Type\")\n            >>> if old_type:\n            ...     project.AnnotationDef.SetUserCanCreate(old_type, False)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize AnnotationDefOperations with a FLExProject instance.",
          "description": "Initialize AnnotationDefOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "system",
        "operations"
      ]
    },
    "CheckOperations": {
      "name": "CheckOperations",
      "type": "class",
      "namespace": "FlexLibs2.System.CheckOperations",
      "source_file": "System/CheckOperations",
      "category": "system",
      "summary": "This class provides operations for managing consistency checks and\nvalidation in a FieldWorks project.",
      "description": "This class provides operations for managing consistency checks and\nvalidation in a FieldWorks project.\n\nConsistency checks help identify data quality issues, missing information,\nand inconsistencies in lexical entries, texts, and other project data.\nCheck types are managed as possibility list items.\n\nThis class should be accessed via FLExProject.Checks property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all check types\nfor check_type in project.Checks.GetAllCheckTypes():\nname = project.Checks.GetName(check_type)\nenabled = project.Checks.IsEnabled(check_type)\nprint(f\"{name}: {'Enabled' if enabled else 'Disabled'}\")\n\n# Create a custom check type\ncheck = project.Checks.CreateCheckType(\"Missing Gloss Check\")\nproject.Checks.SetDescription(check, \"Verify all senses have glosses\")\nproject.Checks.EnableCheck(check)\n\n# Run a check and get results\nproject.Checks.RunCheck(check)\nerrors = project.Checks.GetErrorCount(check)\nwarnings = project.Checks.GetWarningCount(check)\nprint(f\"Check found {errors} errors and {warnings} warnings\")\n\n# Get items with issues\nitems = project.Checks.FindItemsWithIssues(check)\nfor item in items:\nissues = project.Checks.GetIssuesForObject(check, item)\nprint(f\"Issues: {len(issues)}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two checks and return detailed differences.",
          "description": "Compare two checks and return detailed differences.",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null
            },
            {
              "name": "item2",
              "type": "",
              "default": null
            },
            {
              "name": "ops1",
              "type": "",
              "default": null
            },
            {
              "name": "ops2",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateCheckType",
          "signature": "CreateCheckType(name, description=None, wsHandle=None)",
          "summary": "Create a new consistency check type.",
          "description": "Create a new consistency check type.\n\nCreates a new check type that can be used to validate project data.\nThe check type is added to the project's check possibility list.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the check type. Must be unique and non-empty."
            },
            {
              "name": "description",
              "type": "str, optional",
              "default": null,
              "description": "Description of what the check validates. Defaults to None (empty description)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "ICmPossibility: The newly created check type object. ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If name is None or empty.",
            "FP_ParameterError: If a check type with this name already exists."
          ],
          "example": "            >>> # Create a simple check type\n            >>> check = project.Checks.CreateCheckType(\"Missing Etymology Check\")\n            >>> print(project.Checks.GetName(check))\n            Missing Etymology Check\n\n            >>> # Create with description\n            >>> check = project.Checks.CreateCheckType(\n            ...     \"Incomplete Paradigm\",\n            ...     \"Verify all paradigm slots are filled\")\n            >>> print(project.Checks.GetDescription(check))\n            Verify all paradigm slots are filled\n\n            >>> # Enable the check\n            >>> project.Checks.EnableCheck(check)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "DeleteCheckType",
          "signature": "DeleteCheckType(check_or_hvo)",
          "summary": "Delete a consistency check type from the project.",
          "description": "Delete a consistency check type from the project.\n\nRemoves the check type and all associated results and configuration.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> # Delete by object\n            >>> check = project.Checks.FindCheckType(\"Old Check\")\n            >>> if check:\n            ...     project.Checks.DeleteCheckType(check)\n\n            >>> # Delete by HVO\n            >>> project.Checks.DeleteCheckType(check_hvo)\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - All check results and configuration are deleted\n            - Only delete custom check types, not system checks\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "DisableCheck",
          "signature": "DisableCheck(check_or_hvo)",
          "summary": "Disable a consistency check type.",
          "description": "Disable a consistency check type.\n\nDeactivates the check so it cannot be run. Previous results\nare retained.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> project.Checks.DisableCheck(check)\n            >>> print(project.Checks.IsEnabled(check))\n            False\n\n            >>> # Previous results still accessible\n            >>> results = project.Checks.GetCheckResults(check)\n\n        See Also:\n            EnableCheck, IsEnabled, GetEnabledChecks",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a check type, creating a new copy with a new GUID.",
          "description": "Duplicate a check type, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The ICmPossibility check object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source check. If False, insert at end of parent's list."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate sub-checks. If False (default), only copy simple properties."
            }
          ],
          "returns": "ICmPossibility: The newly created duplicate with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> if check:\n            ...     dup = project.Checks.Duplicate(check)\n            ...     print(f\"Duplicate: {project.Checks.GetName(dup)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "EnableCheck",
          "signature": "EnableCheck(check_or_hvo)",
          "summary": "Enable a consistency check type.",
          "description": "Enable a consistency check type.\n\nActivates the check so it can be run on project data.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> project.Checks.EnableCheck(check)\n            >>> print(project.Checks.IsEnabled(check))\n            True\n\n            >>> # Run the enabled check\n            >>> results = project.Checks.RunCheck(check)\n\n        See Also:\n            DisableCheck, IsEnabled, GetEnabledChecks",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindCheckType",
          "signature": "FindCheckType(name)",
          "summary": "Find a check type by its name.",
          "description": "Find a check type by its name.\n\nSearches for a check type with the specified name in the project's\ncheck possibility list.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The check type name to search for (case-insensitive)."
            }
          ],
          "returns": "ICmPossibility or None: The check type object if found, None otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None or empty."
          ],
          "example": "            >>> # Find a check type\n            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> if check:\n            ...     status = project.Checks.GetCheckStatus(check)\n            ...     print(f\"Status: {status}\")\n            Status: Ready\n\n            >>> # Case-insensitive search\n            >>> check = project.Checks.FindCheckType(\"missing gloss\")\n            >>> print(check is not None)\n            True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindItemsWithIssues",
          "signature": "FindItemsWithIssues(check_or_hvo, issue_type='all')",
          "summary": "Find all items that have issues according to a check.",
          "description": "Find all items that have issues according to a check.\n\nReturns items that failed the check, either with errors, warnings,\nor both, from the most recent check execution.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            },
            {
              "name": "issue_type",
              "type": "str",
              "default": "all",
              "description": "Type of issues to return. Options: - 'all': Both errors and warnings (default) - 'errors': Only errors - 'warnings': Only warnings"
            }
          ],
          "returns": "list: List of objects that have the specified issues. Returns empty list if check has never been run or no issues found. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist, is invalid,",
            "or issue_type is not recognized."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> project.Checks.RunCheck(check)\n            >>>\n            >>> # Get all items with issues\n            >>> items = project.Checks.FindItemsWithIssues(check)\n            >>> print(f\"Total items with issues: {len(items)}\")\n            Total items with issues: 18\n            >>>\n            >>> # Get only items with errors\n            >>> error_items = project.Checks.FindItemsWithIssues(check, 'errors')\n            >>> print(f\"Items with errors: {len(error_items)}\")\n            Items with errors: 15\n            >>>\n            >>> # Get only items with warnings\n            >>> warning_items = project.Checks.FindItemsWithIssues(check, 'warnings')\n            >>> print(f\"Items with warnings: {len(warning_items)}\")\n            Items with warnings: 3\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllCheckTypes",
          "signature": "GetAllCheckTypes()",
          "summary": "Get all consistency check types in the project.",
          "description": "Get all consistency check types in the project.\n\nReturns all check types that are available for validation and\nconsistency checking.\n",
          "parameters": [],
          "returns": "ICmPossibility: Each check type object ",
          "raises": [],
          "example": "            >>> for check_type in project.Checks.GetAllCheckTypes():\n            ...     name = project.Checks.GetName(check_type)\n            ...     desc = project.Checks.GetDescription(check_type)\n            ...     enabled = project.Checks.IsEnabled(check_type)\n            ...     print(f\"{name}: {desc} ({'Enabled' if enabled else 'Disabled'})\")\n            Missing Gloss: Check for senses without glosses (Enabled)\n            Duplicate Entries: Find potential duplicate lexical entries (Disabled)\n            Incomplete Paradigm: Verify paradigm completeness (Enabled)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCheckResults",
          "signature": "GetCheckResults(check_or_hvo)",
          "summary": "Get the full results from the last check execution.",
          "description": "Get the full results from the last check execution.\n\nRetrieves all results including errors, warnings, and passed items\nfrom the most recent run of the check.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "dict or None: Results dictionary containing: - 'errors': list of error items - 'warnings': list of warning items - 'passed': list of items that passed - 'timestamp': datetime when check was run Returns None if check has never been run. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> project.Checks.RunCheck(check)\n            >>> results = project.Checks.GetCheckResults(check)\n            >>> if results:\n            ...     print(f\"Errors: {len(results['errors'])}\")\n            ...     print(f\"Warnings: {len(results['warnings'])}\")\n            ...     print(f\"Passed: {len(results['passed'])}\")\n            Errors: 15\n            Warnings: 3\n            Passed: 142\n\n        See Also:\n            RunCheck, GetErrorCount, GetWarningCount",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCheckStatus",
          "signature": "GetCheckStatus(check_or_hvo)",
          "summary": "Get the current status of a check type.",
          "description": "Get the current status of a check type.\n\nReturns a status indicating whether the check is ready to run,\nrunning, completed, or has issues.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "str: Status string, one of: - 'Ready': Check is enabled and ready to run - 'Disabled': Check is not enabled - 'Completed': Check has been run and results are available - 'Never Run': Check has never been executed ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> status = project.Checks.GetCheckStatus(check)\n            >>> print(f\"Status: {status}\")\n            Status: Ready\n\n            >>> # Run check and check status\n            >>> project.Checks.RunCheck(check)\n            >>> status = project.Checks.GetCheckStatus(check)\n            >>> print(status)\n            Completed\n\n        See Also:\n            RunCheck, GetLastRun, IsEnabled",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(check_or_hvo, wsHandle=None)",
          "summary": "Get the description of a check type.",
          "description": "Get the description of a check type.\n\nRetrieves the detailed description explaining what the check validates.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The description of the check type. Returns empty string if no description is set. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> desc = project.Checks.GetDescription(check)\n            >>> print(desc)\n            Identifies lexical senses that are missing glosses in the analysis\n            writing system\n\n        See Also:\n            SetDescription, GetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEnabledChecks",
          "signature": "GetEnabledChecks()",
          "summary": "Get all enabled check types.",
          "description": "Get all enabled check types.\n\nReturns only those check types that are currently enabled and\nready to run.\n",
          "parameters": [],
          "returns": "ICmPossibility: Each enabled check type object ",
          "raises": [],
          "example": "            >>> # List enabled checks\n            >>> for check in project.Checks.GetEnabledChecks():\n            ...     name = project.Checks.GetName(check)\n            ...     print(f\"Enabled: {name}\")\n            Enabled: Missing Gloss\n            Enabled: Incomplete Paradigm\n            Enabled: Duplicate Entries\n\n            >>> # Count enabled checks\n            >>> enabled_count = len(list(project.Checks.GetEnabledChecks()))\n            >>> print(f\"Total enabled: {enabled_count}\")\n            Total enabled: 3\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetErrorCount",
          "signature": "GetErrorCount(check_or_hvo)",
          "summary": "Get the number of errors found by a check.",
          "description": "Get the number of errors found by a check.\n\nReturns the count of items that failed the check with errors\nfrom the most recent execution.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "int: Number of errors found. Returns 0 if check has never been run. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> project.Checks.RunCheck(check)\n            >>> error_count = project.Checks.GetErrorCount(check)\n            >>> print(f\"Found {error_count} errors\")\n            Found 15 errors\n\n        See Also:\n            GetWarningCount, GetCheckResults, RunCheck",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(check_or_hvo)",
          "summary": "Get the GUID of a check type.",
          "description": "Get the GUID of a check type.\n\nReturns the globally unique identifier for the check type.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "System.Guid: The check type's globally unique identifier. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> guid = project.Checks.GetGuid(check)\n            >>> print(guid)\n            a23b6fcc-654c-4983-a11c-5e4e15e1f6e9\n\n            >>> # Use GUID to retrieve check later\n            >>> retrieved = project.Object(guid)\n            >>> name = project.Checks.GetName(retrieved)\n            >>> print(name)\n            Missing Gloss\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetIssuesForObject",
          "signature": "GetIssuesForObject(check_or_hvo, obj)",
          "summary": "Get all issues found for a specific object.",
          "description": "Get all issues found for a specific object.\n\nReturns detailed information about issues found for the given\nobject during the most recent check execution.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            },
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object to get issues for (e.g., ILexEntry, IText, etc.)."
            }
          ],
          "returns": "list: List of issue descriptions for the object. Returns empty list if object has no issues or check has never been run. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo or obj is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> project.Checks.RunCheck(check)\n            >>>\n            >>> # Get issues for a specific entry\n            >>> entry = list(project.LexiconGetAllEntries())[0]\n            >>> issues = project.Checks.GetIssuesForObject(check, entry)\n            >>> for issue in issues:\n            ...     print(f\"- {issue}\")\n            - Sense 1 is missing gloss in English\n            - Sense 2 is missing gloss in English\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLastRun",
          "signature": "GetLastRun(check_or_hvo)",
          "summary": "Get the timestamp when a check was last executed.",
          "description": "Get the timestamp when a check was last executed.\n\nReturns the date and time when the check was most recently run.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "datetime or None: Timestamp of last execution, or None if the check has never been run. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> last_run = project.Checks.GetLastRun(check)\n            >>> if last_run:\n            ...     print(f\"Last run: {last_run.strftime('%Y-%m-%d %H:%M:%S')}\")\n            ... else:\n            ...     print(\"Never run\")\n            Last run: 2025-11-23 14:30:45\n\n        See Also:\n            RunCheck, GetCheckStatus",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(check_or_hvo, wsHandle=None)",
          "summary": "Get the name of a check type.",
          "description": "Get the name of a check type.\n\nRetrieves the check type name in the specified writing system.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The name of the check type in the specified writing system. Returns empty string if no name is set. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> name = project.Checks.GetName(check)\n            >>> print(name)\n            Missing Gloss\n\n            >>> # Get name in specific WS\n            >>> ws_handle = project.WSHandle('fr')\n            >>> name_fr = project.Checks.GetName(check, ws_handle)\n\n        See Also:\n            SetName, GetDescription, FindCheckType",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties for cross-project synchronization.",
          "description": "Get syncable properties for cross-project synchronization.",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetWarningCount",
          "signature": "GetWarningCount(check_or_hvo)",
          "summary": "Get the number of warnings found by a check.",
          "description": "Get the number of warnings found by a check.\n\nReturns the count of items with warnings from the most recent\ncheck execution.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "int: Number of warnings found. Returns 0 if check has never been run. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> project.Checks.RunCheck(check)\n            >>> warning_count = project.Checks.GetWarningCount(check)\n            >>> print(f\"Found {warning_count} warnings\")\n            Found 3 warnings\n\n        See Also:\n            GetErrorCount, GetCheckResults, RunCheck",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsEnabled",
          "signature": "IsEnabled(check_or_hvo)",
          "summary": "Check if a consistency check type is enabled.",
          "description": "Check if a consistency check type is enabled.\n\nReturns whether the check is currently active and can be run.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            }
          ],
          "returns": "bool: True if check is enabled, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> if project.Checks.IsEnabled(check):\n            ...     print(\"Check is active\")\n            ... else:\n            ...     print(\"Check is disabled\")\n            Check is active\n\n        See Also:\n            EnableCheck, DisableCheck, GetEnabledChecks",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RunCheck",
          "signature": "RunCheck(check_or_hvo, target_objects=None)",
          "summary": "Run a consistency check on project data.",
          "description": "Run a consistency check on project data.\n\nExecutes the specified check and stores the results. The actual\nvalidation logic is determined by the check type.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            },
            {
              "name": "target_objects",
              "type": "list, optional",
              "default": null,
              "description": "List of specific objects to check. If None, checks all relevant objects in the project. Defaults to None."
            }
          ],
          "returns": "dict: Results dictionary containing: - 'errors': list of error items - 'warnings': list of warning items - 'passed': list of items that passed - 'timestamp': datetime when check was run ",
          "raises": [
            "FP_NullParameterError: If check_or_hvo is None.",
            "FP_ParameterError: If the check type does not exist, is invalid,",
            "or is not enabled."
          ],
          "example": "            >>> # Run check on all data\n            >>> check = project.Checks.FindCheckType(\"Missing Gloss\")\n            >>> project.Checks.EnableCheck(check)\n            >>> results = project.Checks.RunCheck(check)\n            >>> print(f\"Errors: {len(results['errors'])}\")\n            Errors: 15\n            >>> print(f\"Warnings: {len(results['warnings'])}\")\n            Warnings: 3\n\n            >>> # Run check on specific entries\n            >>> entries = list(project.LexiconGetAllEntries())[:10]\n            >>> results = project.Checks.RunCheck(check, entries)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(check_or_hvo, description, wsHandle=None)",
          "summary": "Set the description of a check type.",
          "description": "Set the description of a check type.\n\nSets a detailed description explaining what the check validates.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            },
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The new description text."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If check_or_hvo or description is None.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Missing Etymology\")\n            >>> project.Checks.SetDescription(\n            ...     check,\n            ...     \"Identifies entries without etymology information\")\n            >>> print(project.Checks.GetDescription(check))\n            Identifies entries without etymology information\n\n        See Also:\n            GetDescription, SetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(check_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a check type.",
          "description": "Set the name of a check type.\n\nSets the check type name in the specified writing system.\n",
          "parameters": [
            {
              "name": "check_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ICmPossibility check type object or its HVO (integer identifier)."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name for the check type. Must be non-empty."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If check_or_hvo or name is None/empty.",
            "FP_ParameterError: If the check type does not exist or is invalid."
          ],
          "example": "            >>> check = project.Checks.FindCheckType(\"Old Name\")\n            >>> if check:\n            ...     project.Checks.SetName(check, \"Updated Check Name\")\n            ...     print(project.Checks.GetName(check))\n            Updated Check Name\n\n            >>> # Set name in specific WS\n            >>> ws_handle = project.WSHandle('fr')\n            >>> project.Checks.SetName(check, \"Vrification manquante\", ws_handle)\n\n        See Also:\n            GetName, SetDescription",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize CheckOperations with a FLExProject instance.",
          "description": "Initialize CheckOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ],
      "tags": [
        "system",
        "operations"
      ]
    },
    "CustomFieldOperations": {
      "name": "CustomFieldOperations",
      "type": "class",
      "namespace": "FlexLibs2.System.CustomFieldOperations",
      "source_file": "System/CustomFieldOperations",
      "category": "system",
      "summary": "This class provides operations for managing custom fields in a\nFieldWorks project.",
      "description": "This class provides operations for managing custom fields in a\nFieldWorks project.\n\nCustom fields extend the FLEx data model by allowing users to add\nadditional fields to various object classes (entries, senses, examples,\netc.). These fields can store strings, integers, dates, or references\nto lists/objects.\n\nField Types:\n- String: Single-line text (one writing system)\n- MultiString: Multi-line text (multiple writing systems)\n- MultiUnicode: Unicode text (multiple writing systems)\n- Integer: Whole number (e.g., frequency counts)\n- GenDate: Date with flexible precision\n- ReferenceAtom: Single-select from predefined list (dropdown menu)\n- ReferenceCollection: Multi-select from predefined list (checkboxes)\n\nThis class should be accessed via FLExProject.CustomFields property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all custom fields for entries\nentry_fields = project.CustomFields.GetAllFields(\"LexEntry\")\nfor field_id, label in entry_fields:\nprint(f\"Field: {label} (ID: {field_id})\")\n\n# Create a new custom field\nfield_id = project.CustomFields.CreateField(\n\"LexEntry\",\n\"DialectVariant\",\n\"MultiString\",\n\"vernacular\"\n)\n\n# Get and set field values\nentry = project.LexEntry.Find(\"run\")\nproject.CustomFields.SetValue(entry, \"DialectVariant\", \"runnin'\", \"en\")\nvalue = project.CustomFields.GetValue(entry, \"DialectVariant\", \"en\")\nprint(value)  # \"runnin'\"\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddListValue",
          "signature": "AddListValue(obj, field_name, value)",
          "summary": "Add a value to a ReferenceCollection custom field.",
          "description": "Add a value to a ReferenceCollection custom field.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object (ILexEntry, ILexSense, etc.) or HVO"
            },
            {
              "name": "field_name",
              "type": "str",
              "default": null,
              "description": "The custom field name (must be ReferenceCollection type)"
            },
            {
              "name": "value",
              "type": "str",
              "default": null,
              "description": "The value to add (short name or full name of possibility)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If obj, field_name, or value is None",
            "FP_ParameterError: If field not found, obj invalid, field is not",
            "ReferenceCollection type, or value not found in possibility list"
          ],
          "example": "            >>> sense = entry.SensesOS[0]\n            >>> # Add a region\n            >>> project.CustomFields.AddListValue(sense, \"Regions\", \"North\")\n\n            >>> # Add multiple values\n            >>> for region in [\"East\", \"West\"]:\n            ...     project.CustomFields.AddListValue(sense, \"Regions\", region)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ClearField",
          "signature": "ClearField(obj, field_name, ws=None)",
          "summary": "Clear a custom field value for an object.",
          "description": "Clear a custom field value for an object.\n\nThis is an alias for ClearValue() provided for FlexTools compatibility.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object (ILexEntry, ILexSense, etc.) or HVO"
            },
            {
              "name": "field_name",
              "type": "str",
              "default": null,
              "description": "The custom field name"
            },
            {
              "name": "ws",
              "type": "str or int, optional",
              "default": null,
              "description": "Writing system for multi-string fields. If None, clears all writing systems."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If obj or field_name is None",
            "FP_ParameterError: If field not found or obj invalid"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> # Clear a field (FlexTools-style API)\n            >>> project.CustomFields.ClearField(entry, \"Etymology Source\")\n\n            >>> # This is equivalent to:\n            >>> project.CustomFields.ClearValue(entry, \"Etymology Source\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ClearValue",
          "signature": "ClearValue(obj, field_name, ws=None)",
          "summary": "Clear the value of a custom field for an object.",
          "description": "Clear the value of a custom field for an object.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object (ILexEntry, ILexSense, etc.) or HVO"
            },
            {
              "name": "field_name",
              "type": "str",
              "default": null,
              "description": "The custom field name"
            },
            {
              "name": "ws",
              "type": "str or int, optional",
              "default": null,
              "description": "Writing system for multi-string fields. If None, clears all writing systems."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If obj or field_name is None",
            "FP_ParameterError: If field not found or obj invalid"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> # Clear a field value\n            >>> project.CustomFields.ClearValue(entry, \"Etymology Source\")\n\n            >>> # Clear specific writing system in multi-string field\n            >>> project.CustomFields.ClearValue(entry, \"Dialect\", \"en\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare custom fields - NOT IMPLEMENTED.",
          "description": "Compare custom fields - NOT IMPLEMENTED.\n\nCustom fields are project schema definitions that cannot be safely synced\nbetween projects due to their structural nature.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null
            },
            {
              "name": "item2",
              "type": "",
              "default": null
            },
            {
              "name": "ops1",
              "type": "",
              "default": null
            },
            {
              "name": "ops2",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [
            "NotImplementedError: Custom fields are not syncable"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateField",
          "signature": "CreateField(owner_class, name, field_type, ws_type=None)",
          "summary": "Create a new custom field.",
          "description": "Create a new custom field.\n",
          "parameters": [
            {
              "name": "owner_class",
              "type": "str",
              "default": null,
              "description": "The class name (e.g., \"LexEntry\", \"LexSense\")"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The field name/label"
            },
            {
              "name": "field_type",
              "type": "str",
              "default": null,
              "description": "Field type: - \"String\": Single-line text (one writing system) - \"MultiString\": Multi-line text (multiple writing systems) - \"MultiUnicode\": Unicode text (multiple writing systems) - \"Integer\": Whole number (e.g., frequency counts) - \"GenDate\": Date with flexible precision - \"ReferenceAtom\": Single-select from predefined list (dropdown menu) - \"ReferenceCollection\": Multi-select from predefined list (checkboxes)"
            },
            {
              "name": "ws_type",
              "type": "str, optional",
              "default": null,
              "description": "Writing system type for string fields - \"vernacular\", \"analysis\", or \"all\". Default is \"analysis\" for MultiString, None for String."
            }
          ],
          "returns": "int: The field ID of the newly created field ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If required parameters are None",
            "FP_ParameterError: If parameters are invalid or field already exists"
          ],
          "example": "            >>> # Create a vernacular multi-string field\n            >>> field_id = project.CustomFields.CreateField(\n            ...     \"LexEntry\",\n            ...     \"Dialect Variant\",\n            ...     \"MultiString\",\n            ...     \"vernacular\"\n            ... )\n\n            >>> # Create an integer field\n            >>> freq_field = project.CustomFields.CreateField(\n            ...     \"LexEntry\",\n            ...     \"Frequency\",\n            ...     \"Integer\"\n            ... )\n\n            >>> # Create a reference to a possibility list\n            >>> region_field = project.CustomFields.CreateField(\n            ...     \"LexSense\",\n            ...     \"Region\",\n            ...     \"ReferenceAtom\"\n            ... )\n\n        Warning:\n            - This operation modifies the project schema\n            - Field creation is permanent and cannot be easily undone\n            - Field names must be unique within a class\n            - Use FLEx UI for complex field setup (lists, etc.)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "DeleteField",
          "signature": "DeleteField(field_id)",
          "summary": "Delete a custom field from the project.",
          "description": "Delete a custom field from the project.\n",
          "parameters": [
            {
              "name": "field_id",
              "type": "int",
              "default": null,
              "description": "The field ID to delete"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If field_id is None",
            "FP_ParameterError: If field_id is invalid or is not a custom field"
          ],
          "example": "            >>> field_id = project.CustomFields.FindField(\"LexEntry\", \"OldField\")\n            >>> if field_id:\n            ...     project.CustomFields.DeleteField(field_id)\n\n        Warning:\n            - This is a destructive operation\n            - All data stored in this field will be lost\n            - Cannot be undone\n            - Field deletion affects all objects in the project\n            - Use FLEx UI for safe field management\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate operation is not applicable for custom fields.",
          "description": "Duplicate operation is not applicable for custom fields.\n\nCustom fields are metadata definitions at the project schema level and\ncannot be duplicated like data objects.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "insert_after",
              "type": "",
              "default": true
            },
            {
              "name": "deep",
              "type": "",
              "default": false
            }
          ],
          "returns": "",
          "raises": [
            "NotImplementedError: Always raised - custom fields cannot be duplicated."
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindField",
          "signature": "FindField(owner_class, name)",
          "summary": "Find a custom field by owner class and name.",
          "description": "Find a custom field by owner class and name.\n",
          "parameters": [
            {
              "name": "owner_class",
              "type": "str",
              "default": null,
              "description": "The class name (e.g., \"LexEntry\", \"LexSense\")"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The field name/label to search for (case-sensitive)"
            }
          ],
          "returns": "int or None: The field ID if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If owner_class or name is None",
            "FP_ParameterError: If owner_class is invalid"
          ],
          "example": "            >>> # Find entry-level custom field\n            >>> field_id = project.CustomFields.FindField(\"LexEntry\", \"Etymology Source\")\n            >>> if field_id:\n            ...     print(f\"Found field: {field_id}\")\n            ... else:\n            ...     print(\"Field not found\")\n\n            >>> # Find sense-level custom field\n            >>> domain_field = project.CustomFields.FindField(\"LexSense\", \"Semantic Domain Notes\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllFields",
          "signature": "GetAllFields(owner_class)",
          "summary": "Get all custom fields for a given class.",
          "description": "Get all custom fields for a given class.\n",
          "parameters": [
            {
              "name": "owner_class",
              "type": "str",
              "default": null,
              "description": "The class name (e.g., \"LexEntry\", \"LexSense\", \"LexExampleSentence\", \"MoForm\")"
            }
          ],
          "returns": "list: List of tuples (field_id, label) for each custom field ",
          "raises": [
            "FP_NullParameterError: If owner_class is None",
            "FP_ParameterError: If owner_class is invalid"
          ],
          "example": "            >>> # Get all entry-level custom fields\n            >>> fields = project.CustomFields.GetAllFields(\"LexEntry\")\n            >>> for field_id, label in fields:\n            ...     print(f\"{label}: {field_id}\")\n            Etymology Source: 5002\n            Dialect: 5003\n\n            >>> # Get all sense-level custom fields\n            >>> sense_fields = project.CustomFields.GetAllFields(\"LexSense\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFieldName",
          "signature": "GetFieldName(field_id)",
          "summary": "Get the name/label of a custom field.",
          "description": "Get the name/label of a custom field.\n",
          "parameters": [
            {
              "name": "field_id",
              "type": "int",
              "default": null,
              "description": "The field ID"
            }
          ],
          "returns": "str: The field name/label ",
          "raises": [
            "FP_NullParameterError: If field_id is None",
            "FP_ParameterError: If field_id is invalid"
          ],
          "example": "            >>> field_id = 5002\n            >>> name = project.CustomFields.GetFieldName(field_id)\n            >>> print(name)\n            Etymology Source\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFieldType",
          "signature": "GetFieldType(field_id)",
          "summary": "Get the data type of a custom field.",
          "description": "Get the data type of a custom field.\n",
          "parameters": [
            {
              "name": "field_id",
              "type": "int",
              "default": null,
              "description": "The field ID"
            }
          ],
          "returns": "CellarPropertyType: The field type enumeration value ",
          "raises": [
            "FP_NullParameterError: If field_id is None",
            "FP_ParameterError: If field_id is invalid"
          ],
          "example": "            >>> field_id = project.CustomFields.FindField(\"LexEntry\", \"Frequency\")\n            >>> field_type = project.CustomFields.GetFieldType(field_id)\n            >>> if field_type == CellarPropertyType.Integer:\n            ...     print(\"This is an integer field\")\n\n            >>> # Check if field is multi-string type\n            >>> if project.CustomFields.IsMultiString(field_id):\n            ...     print(\"This field supports multiple writing systems\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetListValues",
          "signature": "GetListValues(obj, field_name)",
          "summary": "Get list values from a ReferenceCollection custom field.",
          "description": "Get list values from a ReferenceCollection custom field.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object (ILexEntry, ILexSense, etc.) or HVO"
            },
            {
              "name": "field_name",
              "type": "str",
              "default": null,
              "description": "The custom field name (must be ReferenceCollection type)"
            }
          ],
          "returns": "list: List of short names (str) of referenced items ",
          "raises": [
            "FP_NullParameterError: If obj or field_name is None",
            "FP_ParameterError: If field not found, obj invalid, or field",
            "is not a ReferenceCollection type"
          ],
          "example": "            >>> sense = entry.SensesOS[0]\n            >>> # Get list of regions\n            >>> regions = project.CustomFields.GetListValues(sense, \"Regions\")\n            >>> print(regions)\n            ['North', 'East', 'West']\n\n            >>> # Check if list is empty\n            >>> if not project.CustomFields.GetListValues(entry, \"Tags\"):\n            ...     print(\"No tags assigned\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwnerClass",
          "signature": "GetOwnerClass(field_id)",
          "summary": "Get the owner class name for a custom field.",
          "description": "Get the owner class name for a custom field.\n",
          "parameters": [
            {
              "name": "field_id",
              "type": "int",
              "default": null,
              "description": "The field ID"
            }
          ],
          "returns": "str: The class name (e.g., \"LexEntry\", \"LexSense\") ",
          "raises": [
            "FP_NullParameterError: If field_id is None",
            "FP_ParameterError: If field_id is invalid"
          ],
          "example": "            >>> field_id = 5002\n            >>> class_name = project.CustomFields.GetOwnerClass(field_id)\n            >>> print(class_name)\n            LexEntry\n\n            >>> # Use to determine which objects can use this field\n            >>> owner = project.CustomFields.GetOwnerClass(field_id)\n            >>> if owner == \"LexSense\":\n            ...     print(\"This field is for senses\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties - NOT IMPLEMENTED for custom fields.",
          "description": "Get syncable properties - NOT IMPLEMENTED for custom fields.\n\nCustom fields are project schema definitions that cannot be safely synced\nbetween projects due to their structural nature.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [
            "NotImplementedError: Custom fields are not syncable"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetValue",
          "signature": "GetValue(obj, field_name, ws=None)",
          "summary": "Get the value of a custom field for an object.",
          "description": "Get the value of a custom field for an object.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object (ILexEntry, ILexSense, etc.) or HVO"
            },
            {
              "name": "field_name",
              "type": "str",
              "default": null,
              "description": "The custom field name"
            },
            {
              "name": "ws",
              "type": "str or int, optional",
              "default": null,
              "description": "Writing system (tag or handle) for multi-string fields. If None, returns best analysis/vernacular."
            }
          ],
          "returns": "Value depends on field type: - String/MultiString: str - Integer: int - ReferenceAtom: str (short name of referenced item) - ReferenceCollection: list of str ",
          "raises": [
            "FP_NullParameterError: If obj or field_name is None",
            "FP_ParameterError: If field not found or obj invalid"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> # Get string field value\n            >>> etym = project.CustomFields.GetValue(entry, \"Etymology Source\")\n            >>> print(etym)\n            Latin currere\n\n            >>> # Get multi-string field with specific WS\n            >>> dialect = project.CustomFields.GetValue(entry, \"Dialect\", \"en\")\n            >>> print(dialect)\n            runnin'\n\n            >>> # Get integer field\n            >>> freq = project.CustomFields.GetValue(entry, \"Frequency\")\n            >>> print(freq)\n            42\n\n            >>> # Get list field\n            >>> regions = project.CustomFields.GetValue(sense, \"Regions\")\n            >>> print(regions)\n            ['North', 'East']\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsListType",
          "signature": "IsListType(field_id)",
          "summary": "Check if a custom field is a list (reference) type.",
          "description": "Check if a custom field is a list (reference) type.\n\nList fields reference possibility lists (e.g., selecting from\npredefined options like regions, tags, categories).\n",
          "parameters": [
            {
              "name": "field_id",
              "type": "int",
              "default": null,
              "description": "The field ID"
            }
          ],
          "returns": "bool: True if field is ReferenceAtom or ReferenceCollection, False otherwise ",
          "raises": [
            "FP_NullParameterError: If field_id is None",
            "FP_ParameterError: If field_id is invalid"
          ],
          "example": "            >>> field_id = project.CustomFields.FindField(\"LexSense\", \"Region\")\n            >>> if project.CustomFields.IsListType(field_id):\n            ...     # Use list-specific methods\n            ...     values = project.CustomFields.GetListValues(sense, \"Region\")\n            ...     project.CustomFields.AddListValue(sense, \"Region\", \"North\")\n            ... else:\n            ...     # Use regular GetValue/SetValue\n            ...     value = project.CustomFields.GetValue(sense, \"Region\")\n\n            >>> # Check if multi-select list\n            >>> field_type = project.CustomFields.GetFieldType(field_id)\n            >>> if field_type == CellarPropertyType.ReferenceCollection:\n            ...     print(\"Multi-select list\")\n            ... elif field_type == CellarPropertyType.ReferenceAtom:\n            ...     print(\"Single-select list\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsMultiString",
          "signature": "IsMultiString(field_id)",
          "summary": "Check if a custom field is a multi-string type.",
          "description": "Check if a custom field is a multi-string type.\n\nMulti-string fields support multiple writing systems (e.g., entering\nthe same field in English, French, Spanish).\n",
          "parameters": [
            {
              "name": "field_id",
              "type": "int",
              "default": null,
              "description": "The field ID"
            }
          ],
          "returns": "bool: True if field is MultiString or MultiUnicode, False otherwise ",
          "raises": [
            "FP_NullParameterError: If field_id is None",
            "FP_ParameterError: If field_id is invalid"
          ],
          "example": "            >>> field_id = project.CustomFields.FindField(\"LexEntry\", \"Dialect\")\n            >>> if project.CustomFields.IsMultiString(field_id):\n            ...     # Need to specify writing system when getting/setting\n            ...     value_en = project.CustomFields.GetValue(entry, \"Dialect\", \"en\")\n            ...     value_fr = project.CustomFields.GetValue(entry, \"Dialect\", \"fr\")\n            ... else:\n            ...     # Single string, no WS needed\n            ...     value = project.CustomFields.GetValue(entry, \"Dialect\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsStringType",
          "signature": "IsStringType(field_id)",
          "summary": "Check if a custom field is a string type.",
          "description": "Check if a custom field is a string type.\n\nString fields store text data (single or multiple writing systems).\n",
          "parameters": [
            {
              "name": "field_id",
              "type": "int",
              "default": null,
              "description": "The field ID"
            }
          ],
          "returns": "bool: True if field is String, MultiString, or MultiUnicode, False otherwise ",
          "raises": [
            "FP_NullParameterError: If field_id is None",
            "FP_ParameterError: If field_id is invalid"
          ],
          "example": "            >>> field_id = project.CustomFields.FindField(\"LexEntry\", \"Etymology\")\n            >>> if project.CustomFields.IsStringType(field_id):\n            ...     # Can use GetValue/SetValue with string\n            ...     value = project.CustomFields.GetValue(entry, \"Etymology\")\n            ...     project.CustomFields.SetValue(entry, \"Etymology\", \"New value\")\n            ... else:\n            ...     # Use type-specific methods (Integer, List, etc.)\n            ...     pass\n\n            >>> # Determine if it's single vs multi-string\n            >>> if project.CustomFields.IsStringType(field_id):\n            ...     if project.CustomFields.IsMultiString(field_id):\n            ...         print(\"Multi-string field (multiple writing systems)\")\n            ...     else:\n            ...         print(\"Single string field\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RemoveListValue",
          "signature": "RemoveListValue(obj, field_name, value)",
          "summary": "Remove a value from a ReferenceCollection custom field.",
          "description": "Remove a value from a ReferenceCollection custom field.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object (ILexEntry, ILexSense, etc.) or HVO"
            },
            {
              "name": "field_name",
              "type": "str",
              "default": null,
              "description": "The custom field name (must be ReferenceCollection type)"
            },
            {
              "name": "value",
              "type": "str",
              "default": null,
              "description": "The value to remove (short name or full name of possibility)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If obj, field_name, or value is None",
            "FP_ParameterError: If field not found, obj invalid, or field is not",
            "ReferenceCollection type"
          ],
          "example": "            >>> sense = entry.SensesOS[0]\n            >>> # Remove a region\n            >>> project.CustomFields.RemoveListValue(sense, \"Regions\", \"North\")\n\n            >>> # Remove all values\n            >>> for region in project.CustomFields.GetListValues(sense, \"Regions\"):\n            ...     project.CustomFields.RemoveListValue(sense, \"Regions\", region)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetFieldName",
          "signature": "SetFieldName(field_id, name)",
          "summary": "Set/rename the label of a custom field.",
          "description": "Set/rename the label of a custom field.\n",
          "parameters": [
            {
              "name": "field_id",
              "type": "int",
              "default": null,
              "description": "The field ID"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new field name/label"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If field_id or name is None",
            "FP_ParameterError: If field_id is invalid or name is empty"
          ],
          "example": "            >>> field_id = project.CustomFields.FindField(\"LexEntry\", \"OldName\")\n            >>> if field_id:\n            ...     project.CustomFields.SetFieldName(field_id, \"NewName\")\n\n        Warning:\n            - Renaming fields may affect exports and scripts\n            - Other users/systems may reference fields by name\n            - Consider backward compatibility before renaming\n            - Recommended to use FLEx UI for field management\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetListFieldMultiple",
          "signature": "SetListFieldMultiple(obj, field_name, values)",
          "summary": "Set the values of a ReferenceCollection (multi-select list) custom field.",
          "description": "Set the values of a ReferenceCollection (multi-select list) custom field.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object (ILexEntry, ILexSense, etc.) or HVO"
            },
            {
              "name": "field_name",
              "type": "str",
              "default": null,
              "description": "The custom field name (must be ReferenceCollection type)"
            },
            {
              "name": "values",
              "type": "list",
              "default": null,
              "description": "List of values to set (short names or full names)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If obj, field_name, or values is None",
            "FP_ParameterError: If field not found, obj invalid, field is not",
            "ReferenceCollection type, or any value not found in possibility list"
          ],
          "example": "            >>> sense = entry.SensesOS[0]\n            >>> # Set multiple regions\n            >>> project.CustomFields.SetListFieldMultiple(sense, \"Regions\",\n            ...                                           [\"North\", \"East\", \"West\"])\n\n            >>> # Clear all values by setting empty list\n            >>> project.CustomFields.SetListFieldMultiple(sense, \"Regions\", [])\n\n            >>> # Replace existing values\n            >>> project.CustomFields.SetListFieldMultiple(sense, \"Regions\", [\"South\"])\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetListFieldSingle",
          "signature": "SetListFieldSingle(obj, field_name, value)",
          "summary": "Set the value of a ReferenceAtom (single-select list) custom field.",
          "description": "Set the value of a ReferenceAtom (single-select list) custom field.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object (ILexEntry, ILexSense, etc.) or HVO"
            },
            {
              "name": "field_name",
              "type": "str",
              "default": null,
              "description": "The custom field name (must be ReferenceAtom type)"
            },
            {
              "name": "value",
              "type": "str",
              "default": null,
              "description": "The value to set (short name or full name of possibility)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If obj, field_name, or value is None",
            "FP_ParameterError: If field not found, obj invalid, field is not",
            "ReferenceAtom type, or value not found in possibility list"
          ],
          "example": "            >>> sense = entry.SensesOS[0]\n            >>> # Set a single-select field\n            >>> project.CustomFields.SetListFieldSingle(sense, \"Primary Region\", \"North\")\n\n            >>> # Change the value\n            >>> project.CustomFields.SetListFieldSingle(sense, \"Primary Region\", \"South\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetValue",
          "signature": "SetValue(obj, field_name, value, ws=None)",
          "summary": "Set the value of a custom field for an object.",
          "description": "Set the value of a custom field for an object.\n",
          "parameters": [
            {
              "name": "obj",
              "type": "",
              "default": null,
              "description": "The object (ILexEntry, ILexSense, etc.) or HVO"
            },
            {
              "name": "field_name",
              "type": "str",
              "default": null,
              "description": "The custom field name"
            },
            {
              "name": "value",
              "type": "",
              "default": null,
              "description": "The value to set (type depends on field type)"
            },
            {
              "name": "ws",
              "type": "str or int, optional",
              "default": null,
              "description": "Writing system (tag or handle) for multi-string fields. Defaults to default analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If obj or field_name is None",
            "FP_ParameterError: If field not found, obj invalid, or value",
            "type doesn't match field type"
          ],
          "example": "            >>> entry = project.LexEntry.Find(\"run\")\n            >>> # Set string field\n            >>> project.CustomFields.SetValue(entry, \"Etymology Source\",\n            ...                                \"Latin currere\")\n\n            >>> # Set multi-string field with specific WS\n            >>> project.CustomFields.SetValue(entry, \"Dialect\", \"runnin'\", \"en\")\n\n            >>> # Set integer field\n            >>> project.CustomFields.SetValue(entry, \"Frequency\", 42)\n\n            >>> # For list fields, use SetListFieldSingle/Multiple\n            >>> # or AddListValue/RemoveListValue\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize CustomFieldOperations with a FLExProject instance.",
          "description": "Initialize CustomFieldOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "system",
        "operations"
      ]
    },
    "ProjectSettingsOperations": {
      "name": "ProjectSettingsOperations",
      "type": "class",
      "namespace": "FlexLibs2.System.ProjectSettingsOperations",
      "source_file": "System/ProjectSettingsOperations",
      "category": "system",
      "summary": "This class provides operations for managing project-level settings and\nconfiguration in a FieldWorks project.",
      "description": "This class provides operations for managing project-level settings and\nconfiguration in a FieldWorks project.\n\nProject settings include metadata (name, description), language settings\n(vernacular and analysis writing systems), interface preferences, default\nfonts, and file paths for external resources.\n\nThis class should be accessed via FLExProject.ProjectSettings property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get project information\nname = project.ProjectSettings.GetProjectName()\ndescription = project.ProjectSettings.GetDescription(\"en\")\nprint(f\"Project: {name}\")\nprint(f\"Description: {description}\")\n\n# Set project metadata\nproject.ProjectSettings.SetProjectName(\"My Linguistic Study\")\nproject.ProjectSettings.SetDescription(\n\"Documentation of endangered language\", \"en\"\n)\n\n# Language settings\nvern_wss = project.ProjectSettings.GetVernacularWSs()\nanal_wss = project.ProjectSettings.GetAnalysisWSs()\nprint(f\"Vernacular WSs: {vern_wss}\")\nprint(f\"Analysis WSs: {anal_wss}\")\n\n# Set default writing systems\nproject.ProjectSettings.SetDefaultVernacular(\"qaa-x-kal\")\nproject.ProjectSettings.SetDefaultAnalysis(\"en\")\n\n# Configure default fonts\nproject.ProjectSettings.SetDefaultFont(\"qaa-x-kal\", \"Charis SIL\")\nproject.ProjectSettings.SetDefaultFontSize(\"qaa-x-kal\", 14)\n\n# External file paths\nlinked_path = project.ProjectSettings.GetLinkedFilesRootDir()\nprint(f\"Linked files: {linked_path}\")\n\n# Metadata\ncreated = project.ProjectSettings.GetDateCreated()\nmodified = project.ProjectSettings.GetDateModified()\nprint(f\"Created: {created}\")\nprint(f\"Last modified: {modified}\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare project settings - NOT IMPLEMENTED.",
          "description": "Compare project settings - NOT IMPLEMENTED.\n\nProject settings are configuration data unique to each project and should\nnot be synced between projects.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null
            },
            {
              "name": "item2",
              "type": "",
              "default": null
            },
            {
              "name": "ops1",
              "type": "",
              "default": null
            },
            {
              "name": "ops2",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [
            "NotImplementedError: Project settings are not syncable"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate operation is not applicable for project settings.",
          "description": "Duplicate operation is not applicable for project settings.\n\nProject settings are singleton configuration objects and cannot be duplicated.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "insert_after",
              "type": "",
              "default": true
            },
            {
              "name": "deep",
              "type": "",
              "default": false
            }
          ],
          "returns": "",
          "raises": [
            "NotImplementedError: Always raised - project settings cannot be duplicated."
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnalysisWSs",
          "signature": "GetAnalysisWSs()",
          "summary": "Get the list of analysis writing system tags.",
          "description": "Get the list of analysis writing system tags.\n",
          "parameters": [],
          "returns": "list: List of analysis writing system language tags (e.g., [\"en\", \"fr\"]) ",
          "raises": [],
          "example": "            >>> anal_wss = project.ProjectSettings.GetAnalysisWSs()\n            >>> print(\"Analysis writing systems:\")\n            >>> for ws_tag in anal_wss:\n            ...     print(f\"  - {ws_tag}\")\n            Analysis writing systems:\n              - en\n              - fr\n              - es\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnalysisWritingSystems",
          "signature": "GetAnalysisWritingSystems()",
          "summary": "Get the list of analysis writing system tags.",
          "description": "Get the list of analysis writing system tags.\n",
          "parameters": [],
          "returns": "list: List of analysis writing system language tags (e.g., [\"en\", \"fr\"]) ",
          "raises": [],
          "example": "            >>> anal_wss = project.ProjectSettings.GetAnalysisWritingSystems()\n            >>> print(\"Analysis writing systems:\")\n            >>> for ws_tag in anal_wss:\n            ...     print(f\"  - {ws_tag}\")\n            Analysis writing systems:\n              - en\n              - fr\n              - es\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateCreated",
          "signature": "GetDateCreated()",
          "summary": "Get the date the project was created.",
          "description": "Get the date the project was created.\n",
          "parameters": [],
          "returns": "datetime: The creation date/time, or None if not available ",
          "raises": [],
          "example": "            >>> created = project.ProjectSettings.GetDateCreated()\n            >>> if created:\n            ...     print(f\"Created: {created.strftime('%Y-%m-%d %H:%M:%S')}\")\n            Created: 2024-01-15 10:30:00\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDateModified",
          "signature": "GetDateModified()",
          "summary": "Get the date the project was last modified.",
          "description": "Get the date the project was last modified.\n",
          "parameters": [],
          "returns": "datetime: The last modification date/time, or None if not available ",
          "raises": [],
          "example": "            >>> modified = project.ProjectSettings.GetDateModified()\n            >>> if modified:\n            ...     print(f\"Last modified: {modified.strftime('%Y-%m-%d %H:%M:%S')}\")\n            Last modified: 2024-03-20 15:45:30\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDefaultFont",
          "signature": "GetDefaultFont(ws_handle_or_tag)",
          "summary": "Get the default font name for a writing system.",
          "description": "Get the default font name for a writing system.\n",
          "parameters": [
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Writing system handle (int) or language tag (str)"
            }
          ],
          "returns": "str: Font name (e.g., \"Charis SIL\", \"Arial\") ",
          "raises": [
            "FP_NullParameterError: If ws_handle_or_tag is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> font = project.ProjectSettings.GetDefaultFont(\"qaa-x-kal\")\n            >>> print(f\"Default font: {font}\")\n            Default font: Charis SIL\n\n            >>> # Get for analysis WS\n            >>> font = project.ProjectSettings.GetDefaultFont(\"en\")\n            >>> print(font)\n            Calibri\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDefaultFontSize",
          "signature": "GetDefaultFontSize(ws_handle_or_tag)",
          "summary": "Get the default font size for a writing system.",
          "description": "Get the default font size for a writing system.\n",
          "parameters": [
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Writing system handle (int) or language tag (str)"
            }
          ],
          "returns": "float: Font size in points (e.g., 12.0) ",
          "raises": [
            "FP_NullParameterError: If ws_handle_or_tag is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> size = project.ProjectSettings.GetDefaultFontSize(\"qaa-x-kal\")\n            >>> print(f\"Font size: {size} pt\")\n            Font size: 14.0 pt\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDescription",
          "signature": "GetDescription(ws_handle_or_tag=None)",
          "summary": "Get the project description in the specified writing system.",
          "description": "Get the project description in the specified writing system.\n",
          "parameters": [
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Writing system handle (int), language tag (str), or None for default analysis WS"
            }
          ],
          "returns": "str: The project description text ",
          "raises": [
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> # Get in default analysis WS\n            >>> desc = project.ProjectSettings.GetDescription()\n            >>> print(desc)\n            Documentation of endangered Kalaba language\n\n            >>> # Get in specific writing system\n            >>> desc_en = project.ProjectSettings.GetDescription(\"en\")\n            >>> desc_fr = project.ProjectSettings.GetDescription(\"fr\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetExtLinkRootDir",
          "signature": "GetExtLinkRootDir()",
          "summary": "Get the external link root directory.",
          "description": "Get the external link root directory.\n",
          "parameters": [],
          "returns": "str: Path to the external link root directory ",
          "raises": [],
          "example": "            >>> ext_link_path = project.ProjectSettings.GetExtLinkRootDir()\n            >>> print(f\"External links: {ext_link_path}\")\n            External links: C:\\Users\\username\\Documents\\ExternalResources\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetInterfaceLanguage",
          "signature": "GetInterfaceLanguage()",
          "summary": "Get the user interface language writing system.",
          "description": "Get the user interface language writing system.\n",
          "parameters": [],
          "returns": "IWritingSystemDefinition: The UI language writing system ",
          "raises": [],
          "example": "            >>> ui_ws = project.ProjectSettings.GetInterfaceLanguage()\n            >>> tag = project.WritingSystems.GetLanguageTag(ui_ws)\n            >>> print(f\"UI language: {tag}\")\n            UI language: en\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLinkedFilesRootDir",
          "signature": "GetLinkedFilesRootDir()",
          "summary": "Get the root directory for linked files (media, pictures, etc.",
          "description": "Get the root directory for linked files (media, pictures, etc.).\n",
          "parameters": [],
          "returns": "str: Path to the linked files root directory ",
          "raises": [],
          "example": "            >>> linked_path = project.ProjectSettings.GetLinkedFilesRootDir()\n            >>> print(f\"Linked files: {linked_path}\")\n            Linked files: C:\\Users\\username\\Documents\\FLEx\\Kalaba\\LinkedFiles\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetProjectName",
          "signature": "GetProjectName()",
          "summary": "Get the project name.",
          "description": "Get the project name.\n",
          "parameters": [],
          "returns": "str: The name of the project ",
          "raises": [],
          "example": "            >>> name = project.ProjectSettings.GetProjectName()\n            >>> print(f\"Project name: {name}\")\n            Project name: Kalaba Documentation\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties - NOT IMPLEMENTED for project settings.",
          "description": "Get syncable properties - NOT IMPLEMENTED for project settings.\n\nProject settings are configuration data unique to each project and should\nnot be synced between projects.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [
            "NotImplementedError: Project settings are not syncable"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetVernacularWSs",
          "signature": "GetVernacularWSs()",
          "summary": "Get the list of vernacular writing system tags.",
          "description": "Get the list of vernacular writing system tags.\n",
          "parameters": [],
          "returns": "list: List of vernacular writing system language tags (e.g., [\"qaa-x-kal\"]) ",
          "raises": [],
          "example": "            >>> vern_wss = project.ProjectSettings.GetVernacularWSs()\n            >>> print(\"Vernacular writing systems:\")\n            >>> for ws_tag in vern_wss:\n            ...     print(f\"  - {ws_tag}\")\n            Vernacular writing systems:\n              - qaa-x-kal\n              - qaa-x-kal-fonipa\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetVernacularWritingSystems",
          "signature": "GetVernacularWritingSystems()",
          "summary": "Get the list of vernacular writing system tags.",
          "description": "Get the list of vernacular writing system tags.\n",
          "parameters": [],
          "returns": "list: List of vernacular writing system language tags (e.g., [\"qaa-x-kal\"]) ",
          "raises": [],
          "example": "            >>> vern_wss = project.ProjectSettings.GetVernacularWritingSystems()\n            >>> print(\"Vernacular writing systems:\")\n            >>> for ws_tag in vern_wss:\n            ...     print(f\"  - {ws_tag}\")\n            Vernacular writing systems:\n              - qaa-x-kal\n              - qaa-x-kal-fonipa\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDefaultAnalysis",
          "signature": "SetDefaultAnalysis(ws_handle_or_tag)",
          "summary": "Set the default analysis writing system.",
          "description": "Set the default analysis writing system.\n",
          "parameters": [
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Writing system handle (int) or language tag (str)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws_handle_or_tag is None",
            "FP_WritingSystemError: If writing system not found",
            "FP_ParameterError: If WS is not in analysis list"
          ],
          "example": "            >>> # Set by language tag\n            >>> project.ProjectSettings.SetDefaultAnalysis(\"en\")\n\n            >>> # Verify the change\n            >>> default = project.WritingSystems.GetDefaultAnalysis()\n            >>> tag = project.WritingSystems.GetLanguageTag(default)\n            >>> print(f\"Default analysis: {tag}\")\n            Default analysis: en\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDefaultFont",
          "signature": "SetDefaultFont(ws_handle_or_tag, font_name)",
          "summary": "Set the default font name for a writing system.",
          "description": "Set the default font name for a writing system.\n",
          "parameters": [
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Writing system handle (int) or language tag (str)"
            },
            {
              "name": "font_name",
              "type": "str",
              "default": null,
              "description": "Font name (e.g., \"Charis SIL\", \"Arial\")"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws_handle_or_tag or font_name is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> # Set font for vernacular\n            >>> project.ProjectSettings.SetDefaultFont(\"qaa-x-kal\", \"Charis SIL\")\n\n            >>> # Set font for IPA\n            >>> project.ProjectSettings.SetDefaultFont(\"qaa-x-kal-fonipa\", \"Doulos SIL\")\n\n            >>> # Set font for analysis\n            >>> project.ProjectSettings.SetDefaultFont(\"en\", \"Calibri\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDefaultFontSize",
          "signature": "SetDefaultFontSize(ws_handle_or_tag, size)",
          "summary": "Set the default font size for a writing system.",
          "description": "Set the default font size for a writing system.\n",
          "parameters": [
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Writing system handle (int) or language tag (str)"
            },
            {
              "name": "size",
              "type": "float or int",
              "default": null,
              "description": "Font size in points (e.g., 12, 14.5)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws_handle_or_tag or size is None",
            "FP_WritingSystemError: If writing system not found",
            "FP_ParameterError: If size is not positive"
          ],
          "example": "            >>> # Set standard size\n            >>> project.ProjectSettings.SetDefaultFontSize(\"qaa-x-kal\", 14)\n\n            >>> # Set larger for better readability\n            >>> project.ProjectSettings.SetDefaultFontSize(\"qaa-x-kal\", 16)\n\n            >>> # Set for analysis\n            >>> project.ProjectSettings.SetDefaultFontSize(\"en\", 12)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDefaultVernacular",
          "signature": "SetDefaultVernacular(ws_handle_or_tag)",
          "summary": "Set the default vernacular writing system.",
          "description": "Set the default vernacular writing system.\n",
          "parameters": [
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Writing system handle (int) or language tag (str)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws_handle_or_tag is None",
            "FP_WritingSystemError: If writing system not found",
            "FP_ParameterError: If WS is not in vernacular list"
          ],
          "example": "            >>> # Set by language tag\n            >>> project.ProjectSettings.SetDefaultVernacular(\"qaa-x-kal\")\n\n            >>> # Verify the change\n            >>> default = project.WritingSystems.GetDefaultVernacular()\n            >>> tag = project.WritingSystems.GetLanguageTag(default)\n            >>> print(f\"Default vernacular: {tag}\")\n            Default vernacular: qaa-x-kal\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDescription",
          "signature": "SetDescription(description, ws_handle_or_tag=None)",
          "summary": "Set the project description in the specified writing system.",
          "description": "Set the project description in the specified writing system.\n",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "default": null,
              "description": "The description text"
            },
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Writing system handle (int), language tag (str), or None for default analysis WS"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If description is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> # Set in default analysis WS\n            >>> project.ProjectSettings.SetDescription(\n            ...     \"Documentation of endangered Kalaba language\"\n            ... )\n\n            >>> # Set in multiple languages\n            >>> project.ProjectSettings.SetDescription(\n            ...     \"Documentation of endangered Kalaba language\", \"en\"\n            ... )\n            >>> project.ProjectSettings.SetDescription(\n            ...     \"Documentation de la langue Kalaba en danger\", \"fr\"\n            ... )\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetExtLinkRootDir",
          "signature": "SetExtLinkRootDir(path)",
          "summary": "Set the external link root directory.",
          "description": "Set the external link root directory.\n",
          "parameters": [
            {
              "name": "path",
              "type": "str",
              "default": null,
              "description": "Path to the external link root directory"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If path is None"
          ],
          "example": "            >>> # Set absolute path\n            >>> project.ProjectSettings.SetExtLinkRootDir(\n            ...     \"C:\\\\Users\\\\username\\\\Documents\\\\ExternalResources\"\n            ... )\n\n            >>> # Set relative path\n            >>> project.ProjectSettings.SetExtLinkRootDir(\"ExternalLinks\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetInterfaceLanguage",
          "signature": "SetInterfaceLanguage(ws_handle_or_tag)",
          "summary": "Set the user interface language writing system.",
          "description": "Set the user interface language writing system.\n",
          "parameters": [
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Writing system handle (int) or language tag (str)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws_handle_or_tag is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> # Set UI to French\n            >>> project.ProjectSettings.SetInterfaceLanguage(\"fr\")\n\n            >>> # Set UI to English\n            >>> project.ProjectSettings.SetInterfaceLanguage(\"en\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLinkedFilesRootDir",
          "signature": "SetLinkedFilesRootDir(path)",
          "summary": "Set the root directory for linked files (media, pictures, etc.",
          "description": "Set the root directory for linked files (media, pictures, etc.).\n",
          "parameters": [
            {
              "name": "path",
              "type": "str",
              "default": null,
              "description": "Path to the linked files root directory"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If path is None"
          ],
          "example": "            >>> # Set absolute path\n            >>> project.ProjectSettings.SetLinkedFilesRootDir(\n            ...     \"C:\\\\Users\\\\username\\\\Documents\\\\FLEx\\\\Kalaba\\\\LinkedFiles\"\n            ... )\n\n            >>> # Set relative path\n            >>> project.ProjectSettings.SetLinkedFilesRootDir(\"LinkedFiles\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetProjectName",
          "signature": "SetProjectName(name)",
          "summary": "Set the project name.",
          "description": "Set the project name.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new project name"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If name is None",
            "FP_ParameterError: If name is empty"
          ],
          "example": "            >>> project.ProjectSettings.SetProjectName(\"Kalaba Documentation\")\n            >>> name = project.ProjectSettings.GetProjectName()\n            >>> print(name)\n            Kalaba Documentation\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ProjectSettingsOperations with a FLExProject instance.",
          "description": "Initialize ProjectSettingsOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "system",
        "operations"
      ]
    },
    "WritingSystemOperations": {
      "name": "WritingSystemOperations",
      "type": "class",
      "namespace": "FlexLibs2.System.WritingSystemOperations",
      "source_file": "System/WritingSystemOperations",
      "category": "system",
      "summary": "This class provides operations for managing writing systems in a\nFieldWorks project.",
      "description": "This class provides operations for managing writing systems in a\nFieldWorks project.\n\nWriting systems define how text is displayed, including language,\nscript, font settings, and directionality (left-to-right or right-to-left).\n\nThis class should be accessed via FLExProject.WritingSystems property.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all writing systems\nfor ws in project.WritingSystems.GetAll():\nname = project.WritingSystems.GetDisplayName(ws)\ntag = project.WritingSystems.GetLanguageTag(ws)\nprint(f\"{name} ({tag})\")\n\n# Get vernacular and analysis writing systems\nvern_wss = project.WritingSystems.GetVernacular()\nanal_wss = project.WritingSystems.GetAnalysis()\n\n# Configure a writing system\nws = list(vern_wss)[0]\nproject.WritingSystems.SetFontName(ws, \"Charis SIL\")\nproject.WritingSystems.SetFontSize(ws, 12)\nproject.WritingSystems.SetRightToLeft(ws, False)\n\n# Check and set defaults\ndefault_vern = project.WritingSystems.GetDefaultVernacular()\ndefault_anal = project.WritingSystems.GetDefaultAnalysis()\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare writing systems - NOT IMPLEMENTED.",
          "description": "Compare writing systems - NOT IMPLEMENTED.\n\nWriting systems are linguistic configuration unique to each project and\nshould not be synced between projects.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null
            },
            {
              "name": "item2",
              "type": "",
              "default": null
            },
            {
              "name": "ops1",
              "type": "",
              "default": null
            },
            {
              "name": "ops2",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [
            "NotImplementedError: Writing systems are not syncable"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(language_tag, name, is_vernacular=True)",
          "summary": "Create a new writing system in the project.",
          "description": "Create a new writing system in the project.\n",
          "parameters": [
            {
              "name": "language_tag",
              "type": "str",
              "default": null,
              "description": "Language tag (e.g., \"en\", \"fr\", \"qaa-x-kal\")"
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "Display name for the writing system"
            },
            {
              "name": "is_vernacular",
              "type": "bool",
              "default": true,
              "description": "True for vernacular, False for analysis. Defaults to True."
            }
          ],
          "returns": "IWritingSystemDefinition: The newly created writing system ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If language_tag or name is None",
            "FP_ParameterError: If language_tag is empty or already exists"
          ],
          "example": "            >>> # Create a vernacular writing system\n            >>> ws = project.WritingSystems.Create(\"qaa-x-kal\", \"Kalaba\")\n            >>> print(project.WritingSystems.GetDisplayName(ws))\n            Kalaba\n\n            >>> # Create an analysis writing system\n            >>> ws = project.WritingSystems.Create(\"es\", \"Spanish\", is_vernacular=False)\n            >>> project.WritingSystems.SetFontName(ws, \"Arial\")\n            >>> project.WritingSystems.SetFontSize(ws, 12)\n\n            >>> # Create IPA writing system\n            >>> ws = project.WritingSystems.Create(\"qaa-x-kal-fonipa\", \"Kalaba IPA\")\n            >>> project.WritingSystems.SetFontName(ws, \"Charis SIL\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(ws_handle_or_tag)",
          "summary": "Remove a writing system from the project.",
          "description": "Remove a writing system from the project.\n",
          "parameters": [
            {
              "name": "ws_handle_or_tag",
              "type": "",
              "default": null,
              "description": "Either a writing system handle (int) or language tag (str)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws_handle_or_tag is None",
            "FP_WritingSystemError: If writing system not found",
            "FP_ParameterError: If trying to delete the default WS"
          ],
          "example": "            >>> # Delete by language tag\n            >>> if project.WritingSystems.Exists(\"qaa-x-old\"):\n            ...     project.WritingSystems.Delete(\"qaa-x-old\")\n\n            >>> # Delete by handle\n            >>> ws = list(project.WritingSystems.GetVernacular())[2]\n            ...     handle = ws.Handle\n            ...     project.WritingSystems.Delete(handle)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate operation is not applicable for writing systems.",
          "description": "Duplicate operation is not applicable for writing systems.\n\nWriting systems are project-level configuration objects with unique\nidentifiers and cannot be duplicated in the traditional sense.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null
            },
            {
              "name": "insert_after",
              "type": "",
              "default": true
            },
            {
              "name": "deep",
              "type": "",
              "default": false
            }
          ],
          "returns": "",
          "raises": [
            "NotImplementedError: Always raised - writing systems cannot be duplicated."
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(language_tag)",
          "summary": "Check if a writing system with the given language tag exists and is active.",
          "description": "Check if a writing system with the given language tag exists and is active.\n",
          "parameters": [
            {
              "name": "language_tag",
              "type": "str",
              "default": null,
              "description": "Language tag to check (e.g., \"en\", \"qaa-x-kal\")"
            }
          ],
          "returns": "bool: True if writing system exists and is active, False otherwise ",
          "raises": [
            "FP_NullParameterError: If language_tag is None"
          ],
          "example": "            >>> if project.WritingSystems.Exists(\"en\"):\n            ...     print(\"English writing system is active\")\n            English writing system is active\n\n            >>> if not project.WritingSystems.Exists(\"ar\"):\n            ...     print(\"Arabic writing system not found\")\n            Arabic writing system not found\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all active writing systems in the project.",
          "description": "Get all active writing systems in the project.\n\nReturns all writing systems that are currently active (both vernacular\nand analysis) in the project.\n",
          "parameters": [],
          "returns": "IWritingSystemDefinition: Each writing system object ",
          "raises": [],
          "example": "            >>> for ws in project.WritingSystems.GetAll():\n            ...     name = project.WritingSystems.GetDisplayName(ws)\n            ...     tag = project.WritingSystems.GetLanguageTag(ws)\n            ...     font = project.WritingSystems.GetFontName(ws)\n            ...     print(f\"{name} ({tag}): {font}\")\n            English (en): Calibri\n            French (fr): Arial\n            Vernacular (qaa-x-kal): Charis SIL\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnalysis",
          "signature": "GetAnalysis()",
          "summary": "Get all analysis writing systems.",
          "description": "Get all analysis writing systems.\n\nAnalysis writing systems are those used for linguistic analysis,\nglosses, and translations (typically major languages like English,\nFrench, Spanish, etc.).\n",
          "parameters": [],
          "returns": "IWritingSystemDefinition: Each analysis writing system ",
          "raises": [],
          "example": "            >>> for ws in project.WritingSystems.GetAnalysis():\n            ...     name = project.WritingSystems.GetDisplayName(ws)\n            ...     tag = project.WritingSystems.GetLanguageTag(ws)\n            ...     print(f\"Analysis: {name} ({tag})\")\n            Analysis: English (en)\n            Analysis: French (fr)\n            Analysis: Spanish (es)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBestString",
          "signature": "GetBestString(string_obj)",
          "summary": "Extract the best analysis or vernacular string from a MultiString or\nMultiUnicode object.",
          "description": "Extract the best analysis or vernacular string from a MultiString or\nMultiUnicode object.\n\nThis method intelligently selects the most appropriate string alternative\nfrom a multi-writing-system text object, preferring analysis writing\nsystems first, then falling back to vernacular writing systems.\n",
          "parameters": [
            {
              "name": "string_obj",
              "type": "",
              "default": null,
              "description": "IMultiUnicode or IMultiString object containing text in multiple writing systems"
            }
          ],
          "returns": "str: The best available string, or empty string if no valid text found ",
          "raises": [
            "FP_NullParameterError: If string_obj is None",
            "FP_ParameterError: If string_obj is not IMultiUnicode or IMultiString"
          ],
          "example": "            >>> # Get the best string from a lexeme form\n            >>> entry = project.LexEntries.GetEntry(\"test\")\n            >>> best_text = project.WritingSystems.GetBestString(entry.LexemeFormOA.Form)\n            >>> print(best_text)\n            test\n\n            >>> # Get best gloss from a sense\n            >>> sense = entry.SensesOS[0]\n            >>> best_gloss = project.WritingSystems.GetBestString(sense.Gloss)\n            >>> print(best_gloss)\n            a sample word\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDefaultAnalysis",
          "signature": "GetDefaultAnalysis()",
          "summary": "Get the default analysis writing system.",
          "description": "Get the default analysis writing system.\n",
          "parameters": [],
          "returns": "IWritingSystemDefinition: The default analysis writing system ",
          "raises": [],
          "example": "            >>> ws = project.WritingSystems.GetDefaultAnalysis()\n            >>> name = project.WritingSystems.GetDisplayName(ws)\n            >>> tag = project.WritingSystems.GetLanguageTag(ws)\n            >>> print(f\"Default analysis: {name} ({tag})\")\n            Default analysis: English (en)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDefaultVernacular",
          "signature": "GetDefaultVernacular()",
          "summary": "Get the default vernacular writing system.",
          "description": "Get the default vernacular writing system.\n",
          "parameters": [],
          "returns": "IWritingSystemDefinition: The default vernacular writing system ",
          "raises": [],
          "example": "            >>> ws = project.WritingSystems.GetDefaultVernacular()\n            >>> name = project.WritingSystems.GetDisplayName(ws)\n            >>> tag = project.WritingSystems.GetLanguageTag(ws)\n            >>> print(f\"Default vernacular: {name} ({tag})\")\n            Default vernacular: Kalaba (qaa-x-kal)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetDisplayName",
          "signature": "GetDisplayName(ws)",
          "summary": "Get the display name (UI label) for a writing system.",
          "description": "Get the display name (UI label) for a writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object or language tag (str)"
            }
          ],
          "returns": "str: Display name (e.g., \"English\", \"Kalaba\") ",
          "raises": [
            "FP_NullParameterError: If ws is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> ws = list(project.WritingSystems.GetAll())[0]\n            >>> name = project.WritingSystems.GetDisplayName(ws)\n            >>> print(name)\n            English\n\n            >>> # By language tag\n            >>> name = project.WritingSystems.GetDisplayName(\"en\")\n            >>> print(name)\n            English\n\n        See Also:\n            GetLanguageTag, GetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFontName",
          "signature": "GetFontName(ws)",
          "summary": "Get the default font name for a writing system.",
          "description": "Get the default font name for a writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object or language tag (str)"
            }
          ],
          "returns": "str: Font name (e.g., \"Charis SIL\", \"Arial\") ",
          "raises": [
            "FP_NullParameterError: If ws is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> ws = list(project.WritingSystems.GetVernacular())[0]\n            >>> font = project.WritingSystems.GetFontName(ws)\n            >>> print(f\"Font: {font}\")\n            Font: Charis SIL\n\n            >>> # By language tag\n            >>> font = project.WritingSystems.GetFontName(\"en\")\n            >>> print(font)\n            Calibri\n\n        See Also:\n            SetFontName, GetFontSize",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFontSize",
          "signature": "GetFontSize(ws)",
          "summary": "Get the default font size for a writing system.",
          "description": "Get the default font size for a writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object or language tag (str)"
            }
          ],
          "returns": "float: Font size in points (e.g., 12.0) ",
          "raises": [
            "FP_NullParameterError: If ws is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> ws = list(project.WritingSystems.GetVernacular())[0]\n            >>> size = project.WritingSystems.GetFontSize(ws)\n            >>> print(f\"Font size: {size} pt\")\n            Font size: 12.0 pt\n\n        See Also:\n            SetFontSize, GetFontName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLanguageTag",
          "signature": "GetLanguageTag(ws)",
          "summary": "Get the language tag (BCP 47 identifier) for a writing system.",
          "description": "Get the language tag (BCP 47 identifier) for a writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object"
            }
          ],
          "returns": "str: Language tag (e.g., \"en\", \"fr\", \"qaa-x-kal\") ",
          "raises": [
            "FP_NullParameterError: If ws is None"
          ],
          "example": "            >>> ws = list(project.WritingSystems.GetVernacular())[0]\n            >>> tag = project.WritingSystems.GetLanguageTag(ws)\n            >>> print(tag)\n            qaa-x-kal\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRightToLeft",
          "signature": "GetRightToLeft(ws)",
          "summary": "Get the right-to-left directionality setting for a writing system.",
          "description": "Get the right-to-left directionality setting for a writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object or language tag (str)"
            }
          ],
          "returns": "bool: True if right-to-left, False if left-to-right ",
          "raises": [
            "FP_NullParameterError: If ws is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> ws = list(project.WritingSystems.GetVernacular())[0]\n            >>> rtl = project.WritingSystems.GetRightToLeft(ws)\n            >>> print(f\"RTL: {rtl}\")\n            RTL: False\n\n            >>> # Check Arabic\n            >>> if project.WritingSystems.Exists(\"ar\"):\n            ...     rtl = project.WritingSystems.GetRightToLeft(\"ar\")\n            ...     print(f\"Arabic is RTL: {rtl}\")\n            Arabic is RTL: True\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get syncable properties - NOT IMPLEMENTED for writing systems.",
          "description": "Get syncable properties - NOT IMPLEMENTED for writing systems.\n\nWriting systems are linguistic configuration unique to each project and\nshould not be synced between projects.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null
            }
          ],
          "returns": "",
          "raises": [
            "NotImplementedError: Writing systems are not syncable"
          ],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetVernacular",
          "signature": "GetVernacular()",
          "summary": "Get all vernacular writing systems.",
          "description": "Get all vernacular writing systems.\n\nVernacular writing systems are those used for the language(s) being\nstudied or documented.\n",
          "parameters": [],
          "returns": "IWritingSystemDefinition: Each vernacular writing system ",
          "raises": [],
          "example": "            >>> for ws in project.WritingSystems.GetVernacular():\n            ...     name = project.WritingSystems.GetDisplayName(ws)\n            ...     tag = project.WritingSystems.GetLanguageTag(ws)\n            ...     print(f\"Vernacular: {name} ({tag})\")\n            Vernacular: Kalaba (qaa-x-kal)\n            Vernacular: Kalaba-IPA (qaa-x-kal-fonipa)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDefaultAnalysis",
          "signature": "SetDefaultAnalysis(ws)",
          "summary": "Set the default analysis writing system.",
          "description": "Set the default analysis writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object or language tag (str)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws is None",
            "FP_WritingSystemError: If writing system not found",
            "FP_ParameterError: If ws is not an analysis writing system"
          ],
          "example": "            >>> # Set by object\n            >>> ws = list(project.WritingSystems.GetAnalysis())[0]\n            >>> project.WritingSystems.SetDefaultAnalysis(ws)\n\n            >>> # Set by language tag\n            >>> project.WritingSystems.SetDefaultAnalysis(\"en\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetDefaultVernacular",
          "signature": "SetDefaultVernacular(ws)",
          "summary": "Set the default vernacular writing system.",
          "description": "Set the default vernacular writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object or language tag (str)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws is None",
            "FP_WritingSystemError: If writing system not found",
            "FP_ParameterError: If ws is not a vernacular writing system"
          ],
          "example": "            >>> # Set by object\n            >>> ws = list(project.WritingSystems.GetVernacular())[0]\n            >>> project.WritingSystems.SetDefaultVernacular(ws)\n\n            >>> # Set by language tag\n            >>> project.WritingSystems.SetDefaultVernacular(\"qaa-x-kal\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetFontName",
          "signature": "SetFontName(ws, font_name)",
          "summary": "Set the default font name for a writing system.",
          "description": "Set the default font name for a writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object or language tag (str)"
            },
            {
              "name": "font_name",
              "type": "str",
              "default": null,
              "description": "Font name (e.g., \"Charis SIL\", \"Arial\")"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws or font_name is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> ws = list(project.WritingSystems.GetVernacular())[0]\n            >>> project.WritingSystems.SetFontName(ws, \"Charis SIL\")\n\n            >>> # Set by language tag\n            >>> project.WritingSystems.SetFontName(\"en\", \"Calibri\")\n\n            >>> # Set IPA font\n            >>> project.WritingSystems.SetFontName(\"qaa-x-kal-fonipa\", \"Doulos SIL\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetFontSize",
          "signature": "SetFontSize(ws, size)",
          "summary": "Set the default font size for a writing system.",
          "description": "Set the default font size for a writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object or language tag (str)"
            },
            {
              "name": "size",
              "type": "float or int",
              "default": null,
              "description": "Font size in points (e.g., 12, 14.5)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws or size is None",
            "FP_WritingSystemError: If writing system not found",
            "FP_ParameterError: If size is not positive"
          ],
          "example": "            >>> ws = list(project.WritingSystems.GetVernacular())[0]\n            >>> project.WritingSystems.SetFontSize(ws, 14)\n\n            >>> # Set by language tag\n            >>> project.WritingSystems.SetFontSize(\"en\", 12)\n\n            >>> # Larger size for better readability\n            >>> project.WritingSystems.SetFontSize(\"qaa-x-kal\", 16)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetRightToLeft",
          "signature": "SetRightToLeft(ws, is_rtl)",
          "summary": "Set the right-to-left directionality for a writing system.",
          "description": "Set the right-to-left directionality for a writing system.\n",
          "parameters": [
            {
              "name": "ws",
              "type": "",
              "default": null,
              "description": "IWritingSystemDefinition object or language tag (str)"
            },
            {
              "name": "is_rtl",
              "type": "bool",
              "default": null,
              "description": "True for right-to-left, False for left-to-right"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If ws or is_rtl is None",
            "FP_WritingSystemError: If writing system not found"
          ],
          "example": "            >>> # Set Arabic to RTL\n            >>> if project.WritingSystems.Exists(\"ar\"):\n            ...     project.WritingSystems.SetRightToLeft(\"ar\", True)\n\n            >>> # Set English to LTR\n            >>> project.WritingSystems.SetRightToLeft(\"en\", False)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize WritingSystemOperations with a FLExProject instance.",
          "description": "Initialize WritingSystemOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ],
      "tags": [
        "system",
        "operations"
      ]
    },
    "DiscourseOperations": {
      "name": "DiscourseOperations",
      "type": "class",
      "namespace": "FlexLibs2.TextsWords.DiscourseOperations",
      "source_file": "TextsWords/DiscourseOperations",
      "category": "texts",
      "summary": "Discourse and constituent chart management operations for FLEx projects.",
      "description": "Discourse and constituent chart management operations for FLEx projects.\n\nThis class provides methods for creating and managing discourse charts and\nconstituent charts. Charts provide a visual analysis of text structure, showing\nrelationships between clauses, participants, and discourse features.\n",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddRow",
          "signature": "AddRow(chart_or_hvo)",
          "summary": "Add a new row to a chart.",
          "description": "Add a new row to a chart.\n\nCreates a new row and appends it to the end of the chart's row collection.\nThe row will be empty initially and can be populated with cells and content.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a chart object or its HVO (integer identifier)."
            }
          ],
          "returns": "IConstChartRow: The newly created row object. ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> chart = discourse_ops.CreateChart(text, \"Analysis\")\n            >>>\n            >>> # Add rows to the chart\n            >>> row1 = discourse_ops.AddRow(chart)\n            >>> row2 = discourse_ops.AddRow(chart)\n            >>> row3 = discourse_ops.AddRow(chart)\n            >>> print(f\"Chart has {discourse_ops.GetRowCount(chart)} rows\")\n            Chart has 3 rows\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two discourse charts for differences.",
          "description": "Compare two discourse charts for differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First chart object (from project 1)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second chart object (from project 2)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional DiscourseOperations instance for project 1 (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional DiscourseOperations instance for project 2 (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) - is_different (bool): True if charts differ, False if identical - differences_dict (dict): Maps property names to (value1, value2) tuples for properties that differ ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(chart1, chart2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} != {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CreateChart",
          "signature": "CreateChart(text_or_hvo, name, chart_type='constituent')",
          "summary": "Create a new chart for a text.",
          "description": "Create a new chart for a text.\n\nCreates either a constituent chart (IConstChart) or discourse chart based\non the chart_type parameter. The chart will be added to the text's chart\ncollection.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the chart. Must be non-empty."
            },
            {
              "name": "chart_type",
              "type": "str",
              "default": "constituent",
              "description": "Type of chart to create. Either \"constituent\" or \"discourse\". Defaults to \"constituent\"."
            }
          ],
          "returns": "Chart object (IConstChart): The newly created chart. ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If text_or_hvo or name is None.",
            "FP_ParameterError: If name is empty, text is invalid, or chart_type",
            "is not recognized."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>>\n            >>> # Create a constituent chart (default)\n            >>> chart = discourse_ops.CreateChart(text, \"Main Analysis\")\n            >>> print(discourse_ops.GetChartName(chart))\n            Main Analysis\n            >>>\n            >>> # Create a discourse chart\n            >>> discourse_chart = discourse_ops.CreateChart(text, \"Discourse\", \"discourse\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "DeleteChart",
          "signature": "DeleteChart(chart_or_hvo)",
          "summary": "Delete a chart from its text.",
          "description": "Delete a chart from its text.\n\nRemoves the chart and all its rows, cells, and associated data from the\ntext's chart collection.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a chart object or its HVO (integer identifier)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     # Delete the first chart\n            ...     discourse_ops.DeleteChart(charts[0])\n            ...     print(\"Chart deleted\")\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - All chart rows and cells will be deleted\n            - All chart analysis data will be lost\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "DeleteRow",
          "signature": "DeleteRow(row_or_hvo)",
          "summary": "Delete a row from its chart.",
          "description": "Delete a row from its chart.\n\nRemoves the row and all its cells and content from the chart's row\ncollection.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO (integer identifier)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If row_or_hvo is None.",
            "FP_ParameterError: If the row does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     rows = discourse_ops.GetRows(charts[0])\n            ...     if rows:\n            ...         # Delete the last row\n            ...         discourse_ops.DeleteRow(rows[-1])\n            ...         print(f\"Chart now has {discourse_ops.GetRowCount(charts[0])} rows\")\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - All cells and content in the row will be deleted\n            - Chart structure may be affected\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a chart, creating a new copy with a new GUID.",
          "description": "Duplicate a chart, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The chart object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True (default), insert after the source chart. If False, insert at end of text's chart collection."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate rows and cells. If False (default), only copy chart properties."
            }
          ],
          "returns": "Chart object: The newly created duplicate with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     dup = discourse_ops.Duplicate(charts[0])\n            ...     print(f\"Duplicate: {discourse_ops.GetChartName(dup)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllCharts",
          "signature": "GetAllCharts(text_or_hvo)",
          "summary": "Get all charts (discourse and constituent) for a text.",
          "description": "Get all charts (discourse and constituent) for a text.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            }
          ],
          "returns": "Chart objects (IConstChart or IDsChart): Each chart associated with the text. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> print(f\"Text has {len(charts)} charts\")\n            Text has 2 charts\n            >>>\n            >>> for chart in charts:\n            ...     name = discourse_ops.GetChartName(chart)\n            ...     chart_type = discourse_ops.GetChartType(chart)\n            ...     print(f\"Chart: {name} ({chart_type})\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCellContent",
          "signature": "GetCellContent(cell, wsHandle=None)",
          "summary": "Get content from a chart cell.",
          "description": "Get content from a chart cell.\n\nRetrieves the text content of a chart cell. For cells that reference\ntext segments, this may return the referenced text. For annotation cells,\nit returns the annotation content.\n",
          "parameters": [
            {
              "name": "cell",
              "type": "",
              "default": null,
              "description": "The cell object to read from."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system."
            }
          ],
          "returns": "str: The cell content, or empty string if no content is available. ",
          "raises": [
            "FP_NullParameterError: If cell is None."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     rows = discourse_ops.GetRows(charts[0])\n            ...     for row in rows:\n            ...         cells = discourse_ops.GetCells(row)\n            ...         for cell in cells:\n            ...             content = discourse_ops.GetCellContent(cell)\n            ...             if content:\n            ...                 print(f\"Cell: {content}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCells",
          "signature": "GetCells(row_or_hvo)",
          "summary": "Get all cells in a chart row.",
          "description": "Get all cells in a chart row.\n\nRetrieves the cells (word groups, markers, etc.) that make up a row in\nthe chart. Cells represent individual units of analysis within the row.\n",
          "parameters": [
            {
              "name": "row_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IConstChartRow object or its HVO (integer identifier)."
            }
          ],
          "returns": "list: List of cell objects (IConstChartWordGroup, IConstChartMovedTextMarker, IConstChartClauseMarker, etc.). Returns empty list if the row has no cells. ",
          "raises": [
            "FP_NullParameterError: If row_or_hvo is None.",
            "FP_ParameterError: If the row does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     rows = discourse_ops.GetRows(charts[0])\n            ...     for row in rows:\n            ...         cells = discourse_ops.GetCells(row)\n            ...         print(f\"Row has {len(cells)} cells\")\n            Row has 3 cells\n            Row has 2 cells\n            Row has 4 cells\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetChartName",
          "signature": "GetChartName(chart_or_hvo, wsHandle=None)",
          "summary": "Get the name of a chart.",
          "description": "Get the name of a chart.\n\nRetrieves the chart's name in the specified writing system, or the default\nanalysis writing system if not specified.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a chart object or its HVO (integer identifier)."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system."
            }
          ],
          "returns": "str: The chart name in the specified writing system. Returns empty string if no name is set. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     name = discourse_ops.GetChartName(charts[0])\n            ...     print(f\"Chart name: {name}\")\n            Chart name: Main Analysis\n\n        See Also:\n            SetChartName, CreateChart",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetChartType",
          "signature": "GetChartType(chart_or_hvo)",
          "summary": "Get the type of a chart (constituent or discourse).",
          "description": "Get the type of a chart (constituent or discourse).\n\nDetermines whether the chart is a constituent chart (IConstChart) or\na discourse chart (IDsChart) based on its class type.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a chart object or its HVO (integer identifier)."
            }
          ],
          "returns": "str: \"constituent\" for constituent charts, \"discourse\" for discourse charts, or \"unknown\" if the type cannot be determined. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> for chart in charts:\n            ...     name = discourse_ops.GetChartName(chart)\n            ...     chart_type = discourse_ops.GetChartType(chart)\n            ...     print(f\"{name}: {chart_type}\")\n            Main Analysis: constituent\n            Discourse Chart: discourse\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGuid",
          "signature": "GetGuid(chart_or_hvo)",
          "summary": "Get the GUID of a chart.",
          "description": "Get the GUID of a chart.\n\nRetrieves the globally unique identifier for the chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a chart object or its HVO (integer identifier)."
            }
          ],
          "returns": "System.Guid: The GUID of the chart. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     guid = discourse_ops.GetGuid(charts[0])\n            ...     print(f\"Chart GUID: {guid}\")\n            Chart GUID: 12345678-1234-1234-1234-123456789abc\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOwningText",
          "signature": "GetOwningText(chart_or_hvo)",
          "summary": "Get the text that owns a chart.",
          "description": "Get the text that owns a chart.\n\nRetrieves the IText object that contains the chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a chart object or its HVO (integer identifier)."
            }
          ],
          "returns": "IText: The text object that owns the chart. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or has no owner."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     owner = discourse_ops.GetOwningText(charts[0])\n            ...     text_name = owner.Name.BestAnalysisAlternative.Text\n            ...     print(f\"Chart belongs to text: {text_name}\")\n            Chart belongs to text: Genesis\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRowCount",
          "signature": "GetRowCount(chart_or_hvo)",
          "summary": "Get the number of rows in a chart.",
          "description": "Get the number of rows in a chart.\n\nThis is more efficient than calling len(GetRows()) when you only need\nthe count.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a chart object or its HVO (integer identifier)."
            }
          ],
          "returns": "int: The number of rows in the chart. Returns 0 if the chart has no rows. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     count = discourse_ops.GetRowCount(charts[0])\n            ...     print(f\"Chart has {count} rows\")\n            Chart has 5 rows\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetRows",
          "signature": "GetRows(chart_or_hvo)",
          "summary": "Get all rows in a chart.",
          "description": "Get all rows in a chart.\n\nRetrieves the ordered list of rows (typically representing clauses or\ndiscourse units) from the chart.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a chart object or its HVO (integer identifier)."
            }
          ],
          "returns": "list: List of IConstChartRow objects. Returns empty list if the chart has no rows. ",
          "raises": [
            "FP_NullParameterError: If chart_or_hvo is None.",
            "FP_ParameterError: If the chart does not exist or is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     rows = discourse_ops.GetRows(charts[0])\n            ...     print(f\"Chart has {len(rows)} rows\")\n            ...     for i, row in enumerate(rows, 1):\n            ...         print(f\"Row {i}\")\n            Chart has 5 rows\n            Row 1\n            Row 2\n            Row 3\n            Row 4\n            Row 5\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a discourse chart.",
          "description": "Get all syncable properties of a discourse chart.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The chart object (IConstChart or IDsChart)."
            }
          ],
          "returns": "dict: Dictionary of syncable properties with their values. Keys are property names, values are the property values. ",
          "raises": [],
          "example": "            >>> props = discourse_ops.GetSyncableProperties(chart)\n            >>> print(props['Name'])\n            {'en': 'Main Chart'}\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetCellContent",
          "signature": "SetCellContent(cell, content, wsHandle=None)",
          "summary": "Set content for a chart cell.",
          "description": "Set content for a chart cell.\n\nUpdates the text content of a chart cell. This is primarily for cells\nthat contain annotations or labels.\n",
          "parameters": [
            {
              "name": "cell",
              "type": "",
              "default": null,
              "description": "The cell object to update."
            },
            {
              "name": "content",
              "type": "str",
              "default": null,
              "description": "The content to set."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If cell or content is None.",
            "FP_ParameterError: If the cell is invalid or doesn't support content."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     rows = discourse_ops.GetRows(charts[0])\n            ...     if rows:\n            ...         cells = discourse_ops.GetCells(rows[0])\n            ...         if cells:\n            ...             # Set content for a cell (if it supports it)\n            ...             discourse_ops.SetCellContent(cells[0], \"Subject\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetChartName",
          "signature": "SetChartName(chart_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a chart.",
          "description": "Set the name of a chart.\n\nUpdates the chart's name in the specified writing system, or the default\nanalysis writing system if not specified.\n",
          "parameters": [
            {
              "name": "chart_or_hvo",
              "type": "",
              "default": null,
              "description": "Either a chart object or its HVO (integer identifier)."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name for the chart. Must be non-empty."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If chart_or_hvo or name is None.",
            "FP_ParameterError: If name is empty or chart is invalid."
          ],
          "example": "            >>> discourse_ops = DiscourseOperations(project)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> charts = list(discourse_ops.GetAllCharts(text))\n            >>> if charts:\n            ...     discourse_ops.SetChartName(charts[0], \"Updated Analysis\")\n            ...     print(discourse_ops.GetChartName(charts[0]))\n            Updated Analysis\n\n        See Also:\n            GetChartName, CreateChart",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize DiscourseOperations with a FLExProject instance.",
          "description": "Initialize DiscourseOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "texts",
        "operations"
      ]
    },
    "ParagraphOperations": {
      "name": "ParagraphOperations",
      "type": "class",
      "namespace": "FlexLibs2.TextsWords.ParagraphOperations",
      "source_file": "TextsWords/ParagraphOperations",
      "category": "texts",
      "summary": "Paragraph CRUD operations for managing FLEx paragraph objects.",
      "description": "Paragraph CRUD operations for managing FLEx paragraph objects.\n\nThis class provides methods for creating, reading, updating, and deleting\nparagraphs within texts in a FieldWorks Language Explorer project.\n\nUsage:\nproject = FLExProject()\nproject.OpenProject(\"MyProject\", writeEnabled=True)\n\n# Access through the Paragraphs property\npara_ops = ParagraphOperations(project)\n\n# Or if integrated into FLExProject:\n# text = project.Texts.Create(\"Genesis\")\n# para = project.Paragraphs.Create(text, \"In the beginning...\")",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two paragraphs for differences.",
          "description": "Compare two paragraphs for differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First paragraph object (from project 1)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second paragraph object (from project 2)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional ParagraphOperations instance for project 1 (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional ParagraphOperations instance for project 2 (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) - is_different (bool): True if paragraphs differ, False if identical - differences_dict (dict): Maps property names to (value1, val2) tuples ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(para1, para2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} != {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(text_or_hvo, content, wsHandle=None)",
          "summary": "Create a new paragraph and append it to a text.",
          "description": "Create a new paragraph and append it to a text.\n\nCreates a new paragraph with the specified content and adds it to the end\nof the text's paragraph collection. The paragraph will be created in the\nspecified writing system or the default vernacular writing system.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            },
            {
              "name": "content",
              "type": "str",
              "default": null,
              "description": "The text content for the new paragraph. Must be non-empty."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default vernacular writing system. Can also be a language tag string."
            }
          ],
          "returns": "IStTxtPara: The newly created paragraph object. ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If text_or_hvo or content is None.",
            "FP_ParameterError: If text has no StText contents, or content is empty."
          ],
          "example": "            >>> # Create a paragraph in a text\n            >>> text = project.Texts.Create(\"Genesis\")\n            >>> para = project.Paragraphs.Create(text, \"In the beginning...\")\n            >>> print(project.Paragraphs.GetText(para))\n            In the beginning...\n\n            >>> # Create with specific writing system\n            >>> ws_handle = project.WSHandle('en')\n            >>> para2 = project.Paragraphs.Create(text, \"Chapter 2\", ws_handle)\n\n        See Also:\n            Delete, InsertAt, GetAll, SetText",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(paragraph_or_hvo)",
          "summary": "Delete a paragraph from its text.",
          "description": "Delete a paragraph from its text.\n\nRemoves the paragraph from its parent text's paragraph collection. This\nwill also delete all segments and other data associated with the paragraph.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IStTxtPara object or its HVO (integer identifier)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If paragraph_or_hvo is None.",
            "FP_ParameterError: If the paragraph does not exist or is invalid."
          ],
          "example": "            >>> # Delete a paragraph\n            >>> para = list(project.Paragraphs.GetAll(text))[0]\n            >>> project.Paragraphs.Delete(para)\n\n            >>> # Delete by HVO\n            >>> project.Paragraphs.Delete(para_hvo)\n\n        Warning:\n            - Deletion is permanent and cannot be undone\n            - All segments in the paragraph will also be deleted\n            - References to the paragraph from other objects may become invalid\n\n        See Also:\n            Create, GetAll, InsertAt",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a paragraph, creating a new paragraph with the same content.",
          "description": "Duplicate a paragraph, creating a new paragraph with the same content.\n\nThis method creates a copy of an existing paragraph. With deep=False, only\nthe paragraph text is duplicated. With deep=True, all segments are also\nduplicated (though segments typically need re-parsing).\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IStTxtPara object or its HVO (integer identifier)"
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True, insert the duplicate after the original paragraph in the text. If False, append to the end of the text."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If False, only duplicate the paragraph text. If True, also duplicate all segments (though they may need re-parsing)."
            }
          ],
          "returns": "IStTxtPara: The newly created duplicate paragraph ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the paragraph does not exist or is invalid, or",
            "if the paragraph has no valid owner text."
          ],
          "example": "            >>> # Shallow duplicate (paragraph text only)\n            >>> para = list(project.Paragraphs.GetAll(text))[0]\n            >>> duplicate = project.Paragraphs.Duplicate(para, insert_after=True)\n            >>> print(project.Paragraphs.GetText(duplicate))\n            In the beginning...\n\n            >>> # Deep duplicate (with segments, though they need re-parsing)\n            >>> duplicate = project.Paragraphs.Duplicate(para, deep=True)\n\n        Warning:\n            - The duplicate will have identical content but a new GUID\n            - Segments in duplicated paragraphs will need re-parsing for analyses\n            - insert_after=True inserts immediately after the original paragraph\n            - deep=True duplicates segments, but they may not have valid analyses\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(text_or_hvo)",
          "summary": "Get all paragraphs in a text.",
          "description": "Get all paragraphs in a text.\n\nReturns a generator that yields all paragraph objects in the text's\nparagraph collection in order.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            }
          ],
          "returns": "IStTxtPara: Each paragraph object in the text. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> # Iterate over all paragraphs\n            >>> text = project.Texts.Find(\"Genesis\")\n            >>> for para in project.Paragraphs.GetAll(text):\n            ...     text = project.Paragraphs.GetText(para)\n            ...     print(f\"Paragraph: {text[:50]}...\")\n\n            >>> # Get as list\n            >>> all_paras = list(project.Paragraphs.GetAll(text))\n            >>> print(f\"Total paragraphs: {len(all_paras)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSegmentCount",
          "signature": "GetSegmentCount(paragraph_or_hvo)",
          "summary": "Get the number of segments in a paragraph.",
          "description": "Get the number of segments in a paragraph.\n\nThis is more efficient than calling len(GetSegments()) when you only\nneed the count.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IStTxtPara object or its HVO (integer identifier)."
            }
          ],
          "returns": "int: The number of segments in the paragraph. ",
          "raises": [
            "FP_NullParameterError: If paragraph_or_hvo is None.",
            "FP_ParameterError: If the paragraph does not exist or is invalid."
          ],
          "example": "            >>> para = list(project.Paragraphs.GetAll(text))[0]\n            >>> count = project.Paragraphs.GetSegmentCount(para)\n            >>> print(f\"Paragraph has {count} segments\")\n            Paragraph has 3 segments\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSegments",
          "signature": "GetSegments(paragraph_or_hvo)",
          "summary": "Get all segments in a paragraph.",
          "description": "Get all segments in a paragraph.\n\nSegments are the individual units (typically sentences) within a paragraph\nthat can have their own analyses and translations.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IStTxtPara object or its HVO (integer identifier)."
            }
          ],
          "returns": "list: A list of ISegment objects in the paragraph. ",
          "raises": [
            "FP_NullParameterError: If paragraph_or_hvo is None.",
            "FP_ParameterError: If the paragraph does not exist or is invalid."
          ],
          "example": "            >>> para = list(project.Paragraphs.GetAll(text))[0]\n            >>> segments = project.Paragraphs.GetSegments(para)\n            >>> print(f\"Paragraph has {len(segments)} segments\")\n            Paragraph has 3 segments\n            >>>\n            >>> # Iterate over segments\n            >>> for seg in segments:\n            ...     print(seg.BaselineText.Text)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a paragraph.",
          "description": "Get all syncable properties of a paragraph.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IStTxtPara object."
            }
          ],
          "returns": "dict: Dictionary of syncable properties with their values. ",
          "raises": [],
          "example": "            >>> props = project.Paragraphs.GetSyncableProperties(para)\n            >>> print(props['Contents'])\n            {'en': 'In the beginning...'}\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetText",
          "signature": "GetText(paragraph_or_hvo, wsHandle=None)",
          "summary": "Get the text content of a paragraph.",
          "description": "Get the text content of a paragraph.\n\nRetrieves the text content in the specified writing system, or the default\nvernacular writing system if not specified.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IStTxtPara object or its HVO (integer identifier)."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default vernacular writing system. Can also be a language tag string."
            }
          ],
          "returns": "str: The text content of the paragraph. Returns empty string if no content is set for that writing system. ",
          "raises": [
            "FP_NullParameterError: If paragraph_or_hvo is None.",
            "FP_ParameterError: If the paragraph does not exist or is invalid."
          ],
          "example": "            >>> para = list(project.Paragraphs.GetAll(text))[0]\n            >>>\n            >>> # Get text in default vernacular WS\n            >>> text = project.Paragraphs.GetText(para)\n            >>> print(text)\n            In the beginning...\n            >>>\n            >>> # Get text in specific WS\n            >>> ws_handle = project.WSHandle('en')\n            >>> text_en = project.Paragraphs.GetText(para, ws_handle)\n\n        See Also:\n            SetText, Create, GetSegments",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "InsertAt",
          "signature": "InsertAt(text_or_hvo, index, content, wsHandle=None)",
          "summary": "Insert a new paragraph at a specific position in a text.",
          "description": "Insert a new paragraph at a specific position in a text.\n\nCreates a new paragraph with the specified content and inserts it at the\ngiven index in the text's paragraph collection. Existing paragraphs at\nthat index and after will be shifted down.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "The position at which to insert the paragraph (0-based). Must be between 0 and the current paragraph count (inclusive)."
            },
            {
              "name": "content",
              "type": "str",
              "default": null,
              "description": "The text content for the new paragraph. Must be non-empty."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default vernacular writing system. Can also be a language tag string."
            }
          ],
          "returns": "IStTxtPara: The newly created paragraph object. ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If text_or_hvo or content is None.",
            "FP_ParameterError: If text has no StText contents, content is empty,",
            "or index is out of range."
          ],
          "example": "            >>> text = project.Texts.Find(\"Genesis\")\n            >>>\n            >>> # Insert at beginning\n            >>> para = project.Paragraphs.InsertAt(text, 0, \"Title: Genesis\")\n            >>>\n            >>> # Insert at end (equivalent to Create)\n            >>> count = len(list(project.Paragraphs.GetAll(text)))\n            >>> para2 = project.Paragraphs.InsertAt(text, count, \"The end\")\n            >>>\n            >>> # Insert in middle\n            >>> para3 = project.Paragraphs.InsertAt(text, 5, \"Chapter 3\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetText",
          "signature": "SetText(paragraph_or_hvo, content, wsHandle=None)",
          "summary": "Set the text content of a paragraph.",
          "description": "Set the text content of a paragraph.\n\nUpdates the paragraph's text content in the specified writing system, or\nthe default vernacular writing system if not specified.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IStTxtPara object or its HVO (integer identifier)."
            },
            {
              "name": "content",
              "type": "str",
              "default": null,
              "description": "The new text content for the paragraph. Must be non-empty."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default vernacular writing system. Can also be a language tag string."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If paragraph_or_hvo or content is None.",
            "FP_ParameterError: If the paragraph does not exist, is invalid, or",
            "content is empty."
          ],
          "example": "            >>> para = list(project.Paragraphs.GetAll(text))[0]\n            >>>\n            >>> # Set text in default vernacular WS\n            >>> project.Paragraphs.SetText(para, \"Updated paragraph text.\")\n            >>>\n            >>> # Set text in specific WS\n            >>> ws_handle = project.WSHandle('en')\n            >>> project.Paragraphs.SetText(para, \"English text\", ws_handle)\n\n        Warning:\n            - This will replace all existing content in the paragraph\n            - Existing segments may be invalidated and need re-analysis\n            - Use with caution on analyzed texts\n\n        See Also:\n            GetText, Create, InsertAt",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize ParagraphOperations with a FLEx project.",
          "description": "Initialize ParagraphOperations with a FLEx project.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "texts",
        "operations"
      ]
    },
    "SegmentOperations": {
      "name": "SegmentOperations",
      "type": "class",
      "namespace": "FlexLibs2.TextsWords.SegmentOperations",
      "source_file": "TextsWords/SegmentOperations",
      "category": "texts",
      "summary": "This class provides operations for managing segments in a FieldWorks project.",
      "description": "This class provides operations for managing segments in a FieldWorks project.\n\nSegments represent the units of text analysis in FLEx, typically sentences\nor clauses within paragraphs. Each segment can have baseline text, analyses,\ntranslations (free and literal), and notes.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get all segments in a paragraph\npara = project.Object(para_hvo)\nfor segment in project.Segments.GetAll(para):\nbaseline = project.Segments.GetBaselineText(segment)\nprint(baseline)\n\n# Set translations\nproject.Segments.SetFreeTranslation(segment, \"In the beginning...\")\nproject.Segments.SetLiteralTranslation(segment, \"In-the beginning...\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two segments for differences.",
          "description": "Compare two segments for differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First segment object (from project 1)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second segment object (from project 2)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional SegmentOperations instance for project 1 (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional SegmentOperations instance for project 2 (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) - is_different (bool): True if segments differ, False if identical - differences_dict (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(seg1, seg2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} != {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(paragraph_or_hvo, baseline_text, wsHandle=None)",
          "summary": "Create a new segment and append it to a paragraph.",
          "description": "Create a new segment and append it to a paragraph.\n\nCreates a new segment with the specified baseline text and adds it to the\nend of the paragraph's segment collection.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IStTxtPara object or HVO."
            },
            {
              "name": "baseline_text",
              "type": "",
              "default": null,
              "description": "The baseline text for the new segment. Must be non-empty."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "ISegment: The newly created segment object. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If paragraph_or_hvo or baseline_text is None.",
            "FP_ParameterError: If baseline_text is empty."
          ],
          "example": "            >>> para = project.Object(para_hvo)\n            >>> segment = project.Segments.Create(para, \"This is a new sentence.\", ws)\n            >>> print(project.Segments.GetBaselineText(segment))\n            This is a new sentence.\n\n        See Also:\n            Delete, Exists, SetBaselineText\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(segment_or_hvo)",
          "summary": "Delete a segment from its paragraph.",
          "description": "Delete a segment from its paragraph.\n\nRemoves the segment from its parent paragraph's segment collection. This\nwill also delete all analyses, translations, and notes associated with the segment.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> project.Segments.Delete(segment)\n            >>> # Segment is now removed from the paragraph\n\n        See Also:\n            Create, Exists, MergeSegments\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a segment, creating a new segment with the same content.",
          "description": "Duplicate a segment, creating a new segment with the same content.\n\nThis method creates a copy of an existing segment. The baseline text and\ntranslations (free and literal) are copied. Analyses are NOT copied as they\nare complex and context-dependent.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an ISegment object or its HVO (integer identifier)"
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "If True, insert the duplicate after the original segment in the paragraph. If False, append to the end of the paragraph."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "Currently not used for segments (analyses are never copied). Parameter kept for consistency with other Duplicate() methods."
            }
          ],
          "returns": "ISegment: The newly created duplicate segment ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the segment does not exist or is invalid, or",
            "if the segment has no valid owner paragraph."
          ],
          "example": "            >>> # Duplicate a segment\n            >>> segment = list(project.Segments.GetAll(para))[0]\n            >>> duplicate = project.Segments.Duplicate(segment, insert_after=True)\n            >>> print(project.Segments.GetBaselineText(duplicate))\n            In the beginning God created the heavens and the earth.\n            >>> print(project.Segments.GetFreeTranslation(duplicate))\n            In the beginning God created the heavens and the earth.\n\n        Warning:\n            - Analyses are NOT copied (would need re-parsing)\n            - Notes are NOT copied\n            - Offsets may need adjustment after duplication\n            - The duplicate will have identical text but a new GUID\n            - insert_after=True inserts immediately after the original segment\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(paragraph_or_hvo, segment_or_hvo)",
          "summary": "Check if a segment exists in a paragraph.",
          "description": "Check if a segment exists in a paragraph.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IStTxtPara object or HVO."
            },
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO to check for."
            }
          ],
          "returns": "bool: True if the segment exists in the paragraph, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If paragraph_or_hvo or segment_or_hvo is None."
          ],
          "example": "            >>> para = project.Object(para_hvo)\n            >>> segment = segments[0]\n            >>> exists = project.Segments.Exists(para, segment)\n            >>> print(exists)\n            True\n\n        See Also:\n            Create, Delete, GetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(paragraph_or_hvo)",
          "summary": "Get all segments in a paragraph.",
          "description": "Get all segments in a paragraph.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IStTxtPara object or HVO."
            }
          ],
          "returns": "ISegment: Each segment in the paragraph. ",
          "raises": [
            "FP_NullParameterError: If paragraph_or_hvo is None."
          ],
          "example": "            >>> para = project.Object(para_hvo)\n            >>> for segment in project.Segments.GetAll(para):\n            ...     text = project.Segments.GetBaselineText(segment)\n            ...     print(text)\n            In the beginning God created the heavens and the earth.\n            Now the earth was formless and empty.\n\n        See Also:\n            GetBaselineText, GetFreeTranslation, GetAnalyses",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnalyses",
          "signature": "GetAnalyses(segment_or_hvo)",
          "summary": "Get all analyses (wordforms and their linguistic analyses) for a segment.",
          "description": "Get all analyses (wordforms and their linguistic analyses) for a segment.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            }
          ],
          "returns": "list: List of IAnalysis objects representing the wordforms in the segment. ",
          "raises": [
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> analyses = project.Segments.GetAnalyses(segment)\n            >>> print(f\"Segment has {len(analyses)} wordforms\")\n            Segment has 5 wordforms\n\n        See Also:\n            GetAll, GetBaselineText\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBaselineText",
          "signature": "GetBaselineText(segment_or_hvo, wsHandle=None)",
          "summary": "Get the baseline text of a segment (the original text in the vernacular language).",
          "description": "Get the baseline text of a segment (the original text in the vernacular language).\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The baseline text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> text = project.Segments.GetBaselineText(segment)\n            >>> print(text)\n            In the beginning God created the heavens and the earth.\n\n        See Also:\n            SetBaselineText, GetFreeTranslation, GetLiteralTranslation",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetBeginOffset",
          "signature": "GetBeginOffset(segment_or_hvo)",
          "summary": "Get the beginning character offset of a segment within its paragraph.",
          "description": "Get the beginning character offset of a segment within its paragraph.\n\nThe offset indicates where the segment's text starts in the paragraph's\nbaseline text.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            }
          ],
          "returns": "int: The beginning offset (0-based character position). ",
          "raises": [
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> offset = project.Segments.GetBeginOffset(segment)\n            >>> print(offset)\n            0\n\n        See Also:\n            GetEndOffset, SetOffsets\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetEndOffset",
          "signature": "GetEndOffset(segment_or_hvo)",
          "summary": "Get the ending character offset of a segment within its paragraph.",
          "description": "Get the ending character offset of a segment within its paragraph.\n\nThe offset indicates where the segment's text ends in the paragraph's\nbaseline text.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            }
          ],
          "returns": "int: The ending offset (0-based character position). ",
          "raises": [
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> offset = project.Segments.GetEndOffset(segment)\n            >>> print(offset)\n            45\n\n        See Also:\n            GetBeginOffset, SetOffsets\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetFreeTranslation",
          "signature": "GetFreeTranslation(segment_or_hvo, wsHandle=None)",
          "summary": "Get the free translation for a segment.",
          "description": "Get the free translation for a segment.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The free translation text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> trans = project.Segments.GetFreeTranslation(segment)\n            >>> print(trans)\n            In the beginning God created the heavens and the earth.\n\n        See Also:\n            SetFreeTranslation, GetLiteralTranslation, GetBaselineText\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetLiteralTranslation",
          "signature": "GetLiteralTranslation(segment_or_hvo, wsHandle=None)",
          "summary": "Get the literal (word-for-word) translation of a segment.",
          "description": "Get the literal (word-for-word) translation of a segment.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The literal translation text, or empty string if not set. ",
          "raises": [
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> trans = project.Segments.GetLiteralTranslation(segment)\n            >>> print(trans)\n            In-the beginning God created the-heavens and-the-earth\n\n        See Also:\n            SetLiteralTranslation, GetFreeTranslation, GetBaselineText\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetNotes",
          "signature": "GetNotes(segment_or_hvo)",
          "summary": "Get all notes associated with a segment.",
          "description": "Get all notes associated with a segment.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            }
          ],
          "returns": "list: List of note objects associated with the segment. ",
          "raises": [
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> notes = project.Segments.GetNotes(segment)\n            >>> print(f\"Segment has {len(notes)} notes\")\n            Segment has 2 notes\n\n        See Also:\n            GetAll, GetBaselineText, GetFreeTranslation\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a segment.",
          "description": "Get all syncable properties of a segment.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The ISegment object."
            }
          ],
          "returns": "dict: Dictionary of syncable properties with their values. ",
          "raises": [],
          "example": "            >>> props = project.Segments.GetSyncableProperties(segment)\n            >>> print(props['BaselineText'])\n            {'en': 'In the beginning...'}\n            >>> print(props['IsLabel'])\n            False\n            >>> print(props['BeginOffset'])\n            0\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsLabel",
          "signature": "IsLabel(segment_or_hvo)",
          "summary": "Check if a segment is marked as a label (section header).",
          "description": "Check if a segment is marked as a label (section header).\n\nLabels are segments that represent section headers, titles, or other\nstructural markers rather than regular text content.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            }
          ],
          "returns": "bool: True if the segment is a label, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> is_header = project.Segments.IsLabel(segment)\n            >>> print(is_header)\n            False\n\n        See Also:\n            SetIsLabel\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "MergeSegments",
          "signature": "MergeSegments(segment1_or_hvo, segment2_or_hvo)",
          "summary": "Merge two adjacent segments into one.",
          "description": "Merge two adjacent segments into one.\n\nCombines the baseline text of two segments into a single segment. The segments\nmust be adjacent in the paragraph.\n",
          "parameters": [
            {
              "name": "segment1_or_hvo",
              "type": "",
              "default": null,
              "description": "The first ISegment object or HVO."
            },
            {
              "name": "segment2_or_hvo",
              "type": "",
              "default": null,
              "description": "The second ISegment object or HVO (must be adjacent)."
            }
          ],
          "returns": "ISegment: The merged segment containing text from both segments. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If either segment is None.",
            "FP_ParameterError: If segments are not adjacent or not in same paragraph."
          ],
          "example": "            >>> seg1 = segments[0]\n            >>> seg2 = segments[1]\n            >>> merged = project.Segments.MergeSegments(seg1, seg2)\n            >>> print(project.Segments.GetBaselineText(merged))\n            In the beginning God created the heavens and the earth.\n\n        See Also:\n            SplitSegment, Create, Delete\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "RebuildSegments",
          "signature": "RebuildSegments(paragraph_or_hvo)",
          "summary": "Rebuild and regenerate all segments from paragraph baseline text.",
          "description": "Rebuild and regenerate all segments from paragraph baseline text.\n\nAnalyzes the paragraph's baseline text and recreates segments with proper\noffsets. This is useful for repairing corrupted segment data or after\nmodifying paragraph text directly.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IStTxtPara object or HVO."
            }
          ],
          "returns": "int: Number of segments created. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If paragraph_or_hvo is None."
          ],
          "example": "            >>> para = project.Object(para_hvo)\n            >>> count = project.Segments.RebuildSegments(para)\n            >>> print(f\"Rebuilt {count} segments\")\n            Rebuilt 5 segments\n\n        See Also:\n            ValidateSegments, Create, SetOffsets\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetBaselineText",
          "signature": "SetBaselineText(segment_or_hvo, text, wsHandle=None)",
          "summary": "Set the baseline text of a segment.",
          "description": "Set the baseline text of a segment.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            },
            {
              "name": "text",
              "type": "",
              "default": null,
              "description": "The baseline text to set."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> project.Segments.SetBaselineText(segment, \"In the beginning...\")\n            >>> # Verify the change\n            >>> print(project.Segments.GetBaselineText(segment))\n            In the beginning...\n\n        See Also:\n            GetBaselineText, SetFreeTranslation, SetLiteralTranslation\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetFreeTranslation",
          "signature": "SetFreeTranslation(segment_or_hvo, text, wsHandle=None)",
          "summary": "Set the free translation for a segment.",
          "description": "Set the free translation for a segment.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            },
            {
              "name": "text",
              "type": "",
              "default": null,
              "description": "The free translation text to set."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> project.Segments.SetFreeTranslation(segment, \"In the beginning God created...\")\n            >>> # Verify the change\n            >>> print(project.Segments.GetFreeTranslation(segment))\n            In the beginning God created...\n\n        See Also:\n            GetFreeTranslation, SetLiteralTranslation, SetBaselineText\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetIsLabel",
          "signature": "SetIsLabel(segment_or_hvo, is_label)",
          "summary": "Set whether a segment is a label (section header).",
          "description": "Set whether a segment is a label (section header).\n\nMarks or unmarks a segment as a label. Labels represent section headers,\ntitles, or other structural markers.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            },
            {
              "name": "is_label",
              "type": "",
              "default": null,
              "description": "Boolean value - True to mark as label, False for regular segment."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> project.Segments.SetIsLabel(segment, True)\n            >>> print(project.Segments.IsLabel(segment))\n            True\n\n        See Also:\n            IsLabel\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetLiteralTranslation",
          "signature": "SetLiteralTranslation(segment_or_hvo, text, wsHandle=None)",
          "summary": "Set the literal (word-for-word) translation of a segment.",
          "description": "Set the literal (word-for-word) translation of a segment.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            },
            {
              "name": "text",
              "type": "",
              "default": null,
              "description": "The literal translation text to set."
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If segment_or_hvo is None."
          ],
          "example": "            >>> segment = segments[0]\n            >>> project.Segments.SetLiteralTranslation(segment, \"In-the beginning God created...\")\n            >>> # Verify the change\n            >>> print(project.Segments.GetLiteralTranslation(segment))\n            In-the beginning God created...\n\n        See Also:\n            GetLiteralTranslation, SetFreeTranslation, SetBaselineText\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetOffsets",
          "signature": "SetOffsets(segment_or_hvo, begin_offset, end_offset)",
          "summary": "Set the beginning and ending offsets of a segment.",
          "description": "Set the beginning and ending offsets of a segment.\n\nManually sets the character offsets that define where the segment's text\nappears within the paragraph's baseline text.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO."
            },
            {
              "name": "begin_offset",
              "type": "",
              "default": null,
              "description": "The beginning offset (0-based character position)."
            },
            {
              "name": "end_offset",
              "type": "",
              "default": null,
              "description": "The ending offset (0-based character position)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If segment_or_hvo is None.",
            "FP_ParameterError: If offsets are invalid (negative or begin >= end)."
          ],
          "example": "            >>> segment = segments[0]\n            >>> project.Segments.SetOffsets(segment, 0, 45)\n\n        See Also:\n            GetBeginOffset, GetEndOffset, RebuildSegments\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SplitSegment",
          "signature": "SplitSegment(segment_or_hvo, position)",
          "summary": "Split a segment at the specified character position.",
          "description": "Split a segment at the specified character position.\n\nCreates two segments from one by splitting the baseline text at the given\nposition. The first segment will contain text from 0 to position, and the\nsecond segment will contain text from position to the end.\n",
          "parameters": [
            {
              "name": "segment_or_hvo",
              "type": "",
              "default": null,
              "description": "The ISegment object or HVO to split."
            },
            {
              "name": "position",
              "type": "",
              "default": null,
              "description": "Character position (0-based) where to split the text."
            }
          ],
          "returns": "tuple: (first_segment, second_segment) - The two resulting segments. ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with writeEnabled=True.",
            "FP_NullParameterError: If segment_or_hvo is None.",
            "FP_ParameterError: If position is invalid or out of range."
          ],
          "example": "            >>> segment = segments[0]\n            >>> text = project.Segments.GetBaselineText(segment)\n            >>> print(text)\n            In the beginning God created the heavens.\n            >>> seg1, seg2 = project.Segments.SplitSegment(segment, 17)\n            >>> print(project.Segments.GetBaselineText(seg1))\n            In the beginning\n            >>> print(project.Segments.GetBaselineText(seg2))\n            God created the heavens.\n\n        See Also:\n            MergeSegments, Create, Delete\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "ValidateSegments",
          "signature": "ValidateSegments(paragraph_or_hvo)",
          "summary": "Validate the integrity of all segments in a paragraph.",
          "description": "Validate the integrity of all segments in a paragraph.\n\nChecks that segments are properly structured with valid offsets,\nnon-overlapping ranges, and complete coverage of the paragraph text.\n",
          "parameters": [
            {
              "name": "paragraph_or_hvo",
              "type": "",
              "default": null,
              "description": "The IStTxtPara object or HVO."
            }
          ],
          "returns": "dict: Validation results with keys: - 'valid': bool - Overall validity - 'errors': list - List of error messages - 'warnings': list - List of warning messages - 'segment_count': int - Number of segments checked ",
          "raises": [
            "FP_NullParameterError: If paragraph_or_hvo is None."
          ],
          "example": "            >>> para = project.Object(para_hvo)\n            >>> result = project.Segments.ValidateSegments(para)\n            >>> if result['valid']:\n            ...     print(\"All segments are valid\")\n            ... else:\n            ...     for error in result['errors']:\n            ...         print(f\"Error: {error}\")\n\n        See Also:\n            RebuildSegments, GetBeginOffset, GetEndOffset\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize SegmentOperations with a FLExProject instance.",
          "description": "Initialize SegmentOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "texts",
        "operations"
      ]
    },
    "TextOperations": {
      "name": "TextOperations",
      "type": "class",
      "namespace": "FlexLibs2.TextsWords.TextOperations",
      "source_file": "TextsWords/TextOperations",
      "category": "texts",
      "summary": "Text operations for managing FLEx Text objects.",
      "description": "Text operations for managing FLEx Text objects.\n\nThis class provides methods for creating, reading, updating, and deleting\ntexts in a FieldWorks Language Explorer project.\n\nUsage:\nproject = FLExProject()\nproject.OpenProject(\"MyProject\", writeEnabled=True)\n\n# Access through the Texts property\ntext_ops = TextOperations(project)\n\n# Or if integrated into FLExProject:\n# new_text = project.Texts.Create(\"Story 1\")",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "AddMediaFile",
          "signature": "AddMediaFile(text_or_hvo, filepath, label=None)",
          "summary": "Add a media file to a text.",
          "description": "Add a media file to a text.\n\nCopies the file to the project's LinkedFiles directory and creates\na media reference linked to the text. If the text doesn't have a\nmedia container yet, one will be created automatically.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            },
            {
              "name": "filepath",
              "type": "str",
              "default": null,
              "description": "Path to the external media file to import."
            },
            {
              "name": "label",
              "type": "str, optional",
              "default": null,
              "description": "Descriptive label for the media file."
            }
          ],
          "returns": "ICmMedia: The created media object with file properly linked. ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If text_or_hvo or filepath is None/empty.",
            "FP_ParameterError: If the text does not exist, is invalid, or file not found."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>> media = project.Texts.AddMediaFile(\n            ...     text,\n            ...     \"/home/user/audio/genesis.mp3\",\n            ...     label=\"Genesis Recording\"\n            ... )\n            >>> print(f\"Media added: {media.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two texts for differences.",
          "description": "Compare two texts for differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First text object (from project 1)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second text object (from project 2)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional TextOperations instance for project 1 (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional TextOperations instance for project 2 (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) - is_different (bool): True if texts differ, False if identical - differences_dict (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(text1, text2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} != {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(name, genre=None)",
          "summary": "Create a new text in the project.",
          "description": "Create a new text in the project.\n\nCreates a new IText object with the specified name and optional genre.\nThe text will have an empty StText contents object created automatically.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the text. Must be unique and non-empty."
            },
            {
              "name": "genre",
              "type": "ICmPossibility, optional",
              "default": null,
              "description": "Genre classification for the text. If provided, must be a valid ICmPossibility from the project's genre list. Defaults to None."
            }
          ],
          "returns": "IText: The newly created text object. ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If name is None or empty.",
            "FP_ParameterError: If a text with this name already exists."
          ],
          "example": "            >>> # Create a simple text\n            >>> text = project.Texts.Create(\"Genesis\")\n            >>> print(text.Name.BestAnalysisAlternative.Text)\n            Genesis\n\n            >>> # Create a text with genre\n            >>> narrative_genre = project.lp.GenreListOA.PossibilitiesOS[0]\n            >>> text = project.Texts.Create(\"Story 1\", genre=narrative_genre)\n\n        See Also:\n            Delete, Exists, GetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(text_or_hvo)",
          "summary": "Delete a text from the project.",
          "description": "Delete a text from the project.\n\nRemoves the text and all its contents (paragraphs, segments, etc.) from\nthe project database.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> # Delete by object\n            >>> text = project.Texts.GetAll()[0]\n            >>> project.Texts.Delete(text)\n\n            >>> # Delete by HVO\n            >>> project.Texts.Delete(text_hvo)\n\n        See Also:\n            Create, Exists, GetAll",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a text, creating a new text with the same properties.",
          "description": "Duplicate a text, creating a new text with the same properties.\n\nThis method creates a copy of an existing text. With deep=False, only\nthe text shell (name, genre, abbreviation) is duplicated. With deep=True,\nall paragraphs and their segments are recursively duplicated.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)"
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "Not applicable for texts (they are added to project-level collection, not a sequence). Parameter kept for consistency with other Duplicate() methods."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If False, only duplicate the text shell (name, genre). If True, recursively duplicate all paragraphs and segments."
            }
          ],
          "returns": "IText: The newly created duplicate text ",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If item_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> # Shallow duplicate (text shell only, no paragraphs)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> duplicate = project.Texts.Duplicate(text, deep=False)\n            >>> print(project.Texts.GetName(duplicate))\n            Genesis (copy)\n            >>> print(project.Texts.GetParagraphCount(duplicate))\n            0\n\n            >>> # Deep duplicate (with all paragraphs)\n            >>> text = list(project.Texts.GetAll())[0]\n            >>> duplicate = project.Texts.Duplicate(text, deep=True)\n            >>> print(project.Texts.GetParagraphCount(duplicate))\n            10\n\n        Warning:\n            - deep=True for Text can be slow for long texts with many paragraphs\n            - The duplicate will have a \" (copy)\" suffix added to the name\n            - The duplicate will have identical content but a new GUID\n            - Media files are NOT duplicated (to avoid file duplication)\n            - Segments will need re-parsing if you want analyses\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(name)",
          "summary": "Check if a text with the given name exists in the project.",
          "description": "Check if a text with the given name exists in the project.\n\nPerforms a case-sensitive comparison of text names in the default\nanalysis writing system.\n",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The name of the text to check."
            }
          ],
          "returns": "bool: True if a text with the given name exists, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If name is None or empty."
          ],
          "example": "            >>> if project.Texts.Exists(\"Genesis\"):\n            ...     print(\"Text already exists\")\n            ... else:\n            ...     text = project.Texts.Create(\"Genesis\")\n\n        See Also:\n            Create, GetAll, GetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAbbreviation",
          "signature": "GetAbbreviation(text_or_hvo, wsHandle=None)",
          "summary": "Get the abbreviation for a text.",
          "description": "Get the abbreviation for a text.\n\nRetrieves the text's abbreviation in the specified writing system.\nAbbreviations are used as short identifiers for texts in FLEx's UI\nand exports.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system. Can also be a language tag string."
            }
          ],
          "returns": "str: The abbreviation in the specified writing system. Returns empty string if no abbreviation is set for that writing system. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>>\n            >>> # Get abbreviation in default analysis WS\n            >>> abbr = project.Texts.GetAbbreviation(text)\n            >>> print(f\"Abbreviation: {abbr}\")\n            >>>\n            >>> # Get abbreviation in specific WS\n            >>> ws_handle = project.WSHandle('en')\n            >>> abbr_en = project.Texts.GetAbbreviation(text, ws_handle)\n\n        See Also:\n            GetName, SetName",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all texts in the project.",
          "description": "Get all texts in the project.\n\nReturns a generator that yields IText objects. This is a wrapper around\nthe existing TextsGetAll method but returns the raw IText objects instead\nof (name, content) tuples.\n",
          "parameters": [],
          "returns": "IText: Each text object in the project. ",
          "raises": [],
          "example": "            >>> # Iterate over all texts\n            >>> for text in project.Texts.GetAll():\n            ...     name = text.Name.BestAnalysisAlternative.Text\n            ...     print(f\"Text: {name}\")\n\n            >>> # Get as list\n            >>> all_texts = list(project.Texts.GetAll())\n            >>> print(f\"Total texts: {len(all_texts)}\")\n\n        See Also:\n            Create, Delete, Exists, project.TextsGetAll()",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetContents",
          "signature": "GetContents(text_or_hvo)",
          "summary": "Get the StText contents object for a text.",
          "description": "Get the StText contents object for a text.\n\nRetrieves the IStText object that contains the actual content (paragraphs,\nsegments, etc.) of the text. Each IText has a ContentsOA (owned atomic)\nproperty that points to its StText content object.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            }
          ],
          "returns": "IStText or None: The text contents object if set, or None if the text has no contents. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> text = project.Texts.Find(\"Genesis\")\n            >>> contents = project.Texts.GetContents(text)\n            >>> if contents:\n            ...     print(f\"Paragraphs: {contents.ParagraphsOS.Count}\")\n            ... else:\n            ...     print(\"Text has no contents\")\n\n        See Also:\n            GetParagraphs, GetParagraphCount, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGenre",
          "signature": "GetGenre(text_or_hvo)",
          "summary": "Get the genre of a text.",
          "description": "Get the genre of a text.\n\nRetrieves the first genre assigned to the text. In FLEx, texts can\ntechnically have multiple genres, but typically only one is assigned.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            }
          ],
          "returns": "ICmPossibility or None: The genre object if one is assigned, or None if no genre is set. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>> genre = project.Texts.GetGenre(text)\n            >>> if genre:\n            ...     genre_name = genre.Name.BestAnalysisAlternative.Text\n            ...     print(f\"Genre: {genre_name}\")\n            ... else:\n            ...     print(\"No genre assigned\")\n\n        See Also:\n            SetGenre, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetIsTranslated",
          "signature": "GetIsTranslated(text_or_hvo)",
          "summary": "Check if a text's translation is marked as complete.",
          "description": "Check if a text's translation is marked as complete.\n\nRetrieves the IsTranslated boolean property indicating whether the\ntext has been fully translated or not.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            }
          ],
          "returns": "bool: True if the text is marked as translated, False otherwise. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>> is_translated = project.Texts.GetIsTranslated(text)\n            >>> if is_translated:\n            ...     print(\"Text translation is complete\")\n            ... else:\n            ...     print(\"Text translation is incomplete\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMediaFiles",
          "signature": "GetMediaFiles(text_or_hvo)",
          "summary": "Get media files associated with a text.",
          "description": "Get media files associated with a text.\n\nRetrieves all media files (audio, video, etc.) that are linked to the\ntext. In FLEx, media files are stored in a CmMediaContainer object\nreferenced by the text's MediaFilesOA property.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            }
          ],
          "returns": "list: List of ICmMedia objects. Returns empty list if no media container exists or no media files are attached. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>> media = project.Texts.GetMediaFiles(text)\n            >>> for m in media:\n            ...     if m.MediaFileRA:\n            ...         path = m.MediaFileRA.AbsoluteInternalPath\n            ...         print(f\"Media file: {path}\")\n\n        See Also:\n            AddMediaFile",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetName",
          "signature": "GetName(text_or_hvo, wsHandle=None)",
          "summary": "Get the name of a text.",
          "description": "Get the name of a text.\n\nRetrieves the text name in the specified writing system, or the default\nanalysis writing system if not specified.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system. Can also be a language tag string."
            }
          ],
          "returns": "str: The name of the text in the specified writing system. Returns empty string if no name is set for that writing system. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>>\n            >>> # Get name in default analysis WS\n            >>> name = project.Texts.GetName(text)\n            >>>\n            >>> # Get name in specific WS\n            >>> ws_handle = project.WSHandle('en')\n            >>> name_en = project.Texts.GetName(text, ws_handle)\n\n        See Also:\n            SetName, Exists",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParagraphCount",
          "signature": "GetParagraphCount(text_or_hvo)",
          "summary": "Get the number of paragraphs in a text.",
          "description": "Get the number of paragraphs in a text.\n\nCounts the paragraphs in the text's contents. This is more efficient\nthan getting all paragraphs and checking the length if you only need\nthe count.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            }
          ],
          "returns": "int: The number of paragraphs. Returns 0 if the text has no contents. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>> count = project.Texts.GetParagraphCount(text)\n            >>> print(f\"Text has {count} paragraphs\")\n\n        See Also:\n            GetParagraphs, GetContents",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetParagraphs",
          "signature": "GetParagraphs(text_or_hvo)",
          "summary": "Get all paragraphs in a text.",
          "description": "Get all paragraphs in a text.\n\nRetrieves a list of all paragraph objects (IStTxtPara) from the text's\ncontents. If the text has no contents, returns an empty list.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            }
          ],
          "returns": "list: List of IStTxtPara objects. Returns empty list if the text has no contents or no paragraphs. ",
          "raises": [
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>> paras = project.Texts.GetParagraphs(text)\n            >>> for i, para in enumerate(paras, 1):\n            ...     content = para.Contents.Text\n            ...     print(f\"Paragraph {i}: {content}\")\n\n        See Also:\n            GetContents, GetParagraphCount",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a text.",
          "description": "Get all syncable properties of a text.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IText object."
            }
          ],
          "returns": "dict: Dictionary of syncable properties with their values. ",
          "raises": [],
          "example": "            >>> props = project.Texts.GetSyncableProperties(text)\n            >>> print(props['Title'])\n            {'en': 'Genesis'}\n            >>> print(props['Description'])\n            {'en': 'First book of the Bible'}\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetGenre",
          "signature": "SetGenre(text_or_hvo, genre)",
          "summary": "Set the genre of a text.",
          "description": "Set the genre of a text.\n\nClears any existing genres and sets the specified genre. If genre is None,\nall genres are cleared.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            },
            {
              "name": "genre",
              "type": "ICmPossibility or None",
              "default": null,
              "description": "The genre to assign. Must be a valid ICmPossibility from the project's genre list (typically found in project.lp.GenreListOA.PossibilitiesOS). If None, clears all genres."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid, or if",
            "genre is not a valid ICmPossibility."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>>\n            >>> # Set genre to first available genre\n            >>> if project.lp.GenreListOA.PossibilitiesOS.Count > 0:\n            ...     narrative = project.lp.GenreListOA.PossibilitiesOS[0]\n            ...     project.Texts.SetGenre(text, narrative)\n            >>>\n            >>> # Clear genre\n            >>> project.Texts.SetGenre(text, None)\n\n        See Also:\n            GetGenre, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetIsTranslated",
          "signature": "SetIsTranslated(text_or_hvo, value)",
          "summary": "Mark a text as translated or untranslated.",
          "description": "Mark a text as translated or untranslated.\n\nSets the IsTranslated boolean property to indicate whether the text\nhas been fully translated.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            },
            {
              "name": "value",
              "type": "bool",
              "default": null,
              "description": "True to mark as translated, False to mark as untranslated."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If text_or_hvo is None.",
            "FP_ParameterError: If the text does not exist or is invalid, or if",
            "value is not a boolean."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>>\n            >>> # Mark text as translated\n            >>> project.Texts.SetIsTranslated(text, True)\n            >>>\n            >>> # Verify\n            >>> if project.Texts.GetIsTranslated(text):\n            ...     print(\"Text is now marked as translated\")\n            >>>\n            >>> # Mark text as untranslated\n            >>> project.Texts.SetIsTranslated(text, False)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetName",
          "signature": "SetName(text_or_hvo, name, wsHandle=None)",
          "summary": "Set the name of a text.",
          "description": "Set the name of a text.\n\nSets the text name in the specified writing system, or the default\nanalysis writing system if not specified.\n",
          "parameters": [
            {
              "name": "text_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IText object or its HVO (integer identifier)."
            },
            {
              "name": "name",
              "type": "str",
              "default": null,
              "description": "The new name for the text. Must be non-empty."
            },
            {
              "name": "wsHandle",
              "type": "int, optional",
              "default": null,
              "description": "Writing system handle. If None, uses the default analysis writing system. Can also be a language tag string."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project was not opened with writeEnabled=True.",
            "FP_NullParameterError: If text_or_hvo or name is None/empty.",
            "FP_ParameterError: If the text does not exist or is invalid."
          ],
          "example": "            >>> text = list(project.Texts.GetAll())[0]\n            >>>\n            >>> # Set name in default analysis WS\n            >>> project.Texts.SetName(text, \"Updated Story\")\n            >>>\n            >>> # Set name in specific WS\n            >>> ws_handle = project.WSHandle('en')\n            >>> project.Texts.SetName(text, \"English Title\", ws_handle)\n\n        See Also:\n            GetName, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize TextOperations with a FLEx project.",
          "description": "Initialize TextOperations with a FLEx project.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "texts",
        "operations"
      ]
    },
    "ApprovalStatusTypes": {
      "name": "ApprovalStatusTypes",
      "type": "class",
      "namespace": "FlexLibs2.TextsWords.WfiAnalysisOperations",
      "source_file": "TextsWords/WfiAnalysisOperations",
      "category": "texts",
      "summary": "Approval status values for wordform analyses.",
      "description": "Approval status values for wordform analyses.",
      "example": "",
      "base_classes": [],
      "methods": [],
      "properties": [],
      "lcm_dependencies": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "texts"
      ]
    },
    "WfiAnalysisOperations": {
      "name": "WfiAnalysisOperations",
      "type": "class",
      "namespace": "FlexLibs2.Wordform.WfiAnalysisOperations",
      "source_file": "Wordform/WfiAnalysisOperations",
      "category": "wordform",
      "summary": "This class provides operations for managing wordform analyses.",
      "description": "This class provides operations for managing wordform analyses.\n\nA WfiAnalysis represents a morphological analysis of a wordform, breaking it down\ninto morpheme bundles with glosses and grammatical categories. Each wordform can\nhave multiple analyses representing different interpretations or parser hypotheses.\n\nAnalyses distinguish between:\n- Human-approved analyses (verified by linguist)\n- Parser-generated analyses (computational guesses)\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get wordform\nwordform = project.Wordforms.FindOrCreate(\"hlauka\")\n\n# Create analysis\nanalysis = project.WfiAnalyses.Create(wordform)\n\n# Set category (part of speech)\nverb_pos = project.GetPartOfSpeech(\"verb\")\nif verb_pos:\nproject.WfiAnalyses.SetCategory(analysis, verb_pos)\n\n# Mark as human-approved\nproject.WfiAnalyses.Approve(analysis)\n\n# Get morpheme bundles\nbundles = project.WfiAnalyses.GetMorphBundles(analysis)\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Approve",
          "signature": "Approve(analysis_or_hvo)",
          "summary": "Mark an analysis as human-approved.",
          "description": "Mark an analysis as human-approved.\n\nThis sets the analysis as the linguist-verified interpretation,\ndistinguishing it from parser guesses.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> analysis = project.WfiAnalyses.Create(wordform)\n            >>> # ... set category, add morph bundles, etc.\n            >>> project.WfiAnalyses.Approve(analysis)\n            >>>\n            >>> # Check approval\n            >>> if project.WfiAnalyses.IsHumanApproved(analysis):\n            ...     print(\"Analysis is now approved\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(wordform_or_hvo)",
          "summary": "Create a new analysis for a wordform.",
          "description": "Create a new analysis for a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "IWfiAnalysis: The newly created analysis ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If wordform_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.FindOrCreate(\"hlauka\")\n            >>> analysis = project.WfiAnalyses.Create(wordform)\n            >>>\n            >>> # Set category\n            >>> verb_pos = project.GetPartOfSpeech(\"verb\")\n            >>> project.WfiAnalyses.SetCategory(analysis, verb_pos)\n            >>>\n            >>> # Add morph bundles\n            >>> bundle = project.WfiMorphBundles.Create(analysis, \"hlauk-\")\n            >>> # ... set bundle properties\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(analysis_or_hvo)",
          "summary": "Delete a wordform analysis.",
          "description": "Delete a wordform analysis.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> analyses = list(project.WfiAnalyses.GetAll(wordform))\n            >>> if len(analyses) > 1:\n            ...     # Delete parser guess, keep human-approved\n            ...     for analysis in analyses:\n            ...         if not project.WfiAnalyses.IsHumanApproved(analysis):\n            ...             project.WfiAnalyses.Delete(analysis)\n\n        Warning:\n            - This is a destructive operation\n            - All morph bundles and glosses will be deleted\n            - Cannot be undone\n            - If this was the approved analysis, approval is cleared\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(wordform_or_hvo, index)",
          "summary": "Find an analysis by its index in the wordform's analyses.",
          "description": "Find an analysis by its index in the wordform's analyses.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "Zero-based index of the analysis"
            }
          ],
          "returns": "IWfiAnalysis or None: The analysis object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If wordform_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> # Get first analysis (typically parser's best guess)\n            >>> first_analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> if first_analysis:\n            ...     print(\"Found first analysis\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(wordform_or_hvo)",
          "summary": "Get all analyses for a wordform.",
          "description": "Get all analyses for a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "IWfiAnalysis: Each analysis object for the wordform ",
          "raises": [
            "FP_NullParameterError: If wordform_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> for analysis in project.WfiAnalyses.GetAll(wordform):\n            ...     approved = project.WfiAnalyses.IsHumanApproved(analysis)\n            ...     cat = project.WfiAnalyses.GetCategory(analysis)\n            ...     status = \"approved\" if approved else \"guess\"\n            ...     print(f\"Analysis ({status}): {cat}\")\n            Analysis (approved): verb\n            Analysis (guess): noun\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetCategory",
          "signature": "GetCategory(analysis_or_hvo)",
          "summary": "Get the part of speech category for an analysis.",
          "description": "Get the part of speech category for an analysis.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            }
          ],
          "returns": "IPartOfSpeech or None: The category object, or None if not set ",
          "raises": [
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> category = project.WfiAnalyses.GetCategory(analysis)\n            >>> if category:\n            ...     name = ITsString(category.Name.BestAnalysisAlternative).Text\n            ...     print(f\"Category: {name}\")\n            Category: verb\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetGlosses",
          "signature": "GetGlosses(analysis_or_hvo)",
          "summary": "Get all word-level glosses for an analysis.",
          "description": "Get all word-level glosses for an analysis.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            }
          ],
          "returns": "list: List of IWfiGloss objects ",
          "raises": [
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> glosses = project.WfiAnalyses.GetGlosses(analysis)\n            >>> for gloss in glosses:\n            ...     text = project.WfiGlosses.GetForm(gloss)\n            ...     print(f\"Gloss: {text}\")\n            Gloss: run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMorphBundles",
          "signature": "GetMorphBundles(analysis_or_hvo)",
          "summary": "Get all morpheme bundles for an analysis.",
          "description": "Get all morpheme bundles for an analysis.\n\nMorph bundles represent the morphological breakdown of the wordform.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            }
          ],
          "returns": "list: List of IWfiMorphBundle objects ",
          "raises": [
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> bundles = project.WfiAnalyses.GetMorphBundles(analysis)\n            >>> for bundle in bundles:\n            ...     form = project.WfiMorphBundles.GetForm(bundle)\n            ...     print(f\"Morpheme: {form}\")\n            Morpheme: hlauk-\n            Morpheme: -a\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsHumanApproved",
          "signature": "IsHumanApproved(analysis_or_hvo)",
          "summary": "Check if an analysis is human-approved.",
          "description": "Check if an analysis is human-approved.\n\nHuman approval distinguishes verified linguistic analyses from parser guesses.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            }
          ],
          "returns": "bool: True if human-approved, False otherwise ",
          "raises": [
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> for analysis in project.WfiAnalyses.GetAll(wordform):\n            ...     if project.WfiAnalyses.IsHumanApproved(analysis):\n            ...         print(\"This analysis is verified\")\n            ...     else:\n            ...         print(\"This is a parser guess\")\n            This analysis is verified\n            This is a parser guess\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetCategory",
          "signature": "SetCategory(analysis_or_hvo, pos)",
          "summary": "Set the part of speech category for an analysis.",
          "description": "Set the part of speech category for an analysis.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            },
            {
              "name": "pos",
              "type": "",
              "default": null,
              "description": "IPartOfSpeech object (or None to clear category)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Create(wordform)\n            >>> verb_pos = project.GetPartOfSpeech(\"verb\")\n            >>> if verb_pos:\n            ...     project.WfiAnalyses.SetCategory(analysis, verb_pos)\n\n            >>> # Clear category\n            >>> project.WfiAnalyses.SetCategory(analysis, None)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize WfiAnalysisOperations with a FLExProject instance.",
          "description": "Initialize WfiAnalysisOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "wordform",
        "operations"
      ]
    },
    "WfiGlossOperations": {
      "name": "WfiGlossOperations",
      "type": "class",
      "namespace": "FlexLibs2.Wordform.WfiGlossOperations",
      "source_file": "Wordform/WfiGlossOperations",
      "category": "wordform",
      "summary": "This class provides operations for managing wordform glosses.",
      "description": "This class provides operations for managing wordform glosses.\n\nA WfiGloss represents a word-level gloss (translation) for a wordform analysis.\nGlosses provide the meaning of the entire word, not individual morphemes.\nMultiple glosses can exist for different analysis languages.\n\nGlosses distinguish between:\n- Human-approved glosses (verified translations)\n- Parser-generated glosses (computational guesses)\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get analysis\nwordform = project.Wordforms.FindOrCreate(\"hlauka\")\nanalysis = project.WfiAnalyses.Create(wordform)\n\n# Create gloss\ngloss = project.WfiGlosses.Create(analysis, \"run\", project.WSHandle('en'))\n\n# Mark as human-approved\nproject.WfiGlosses.Approve(gloss)\n\n# Get all glosses\nfor g in project.WfiGlosses.GetAll(analysis):\ntext = project.WfiGlosses.GetForm(g)\napproved = project.WfiGlosses.IsHumanApproved(g)\nprint(f\"Gloss: {text} ({'approved' if approved else 'guess'})\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Approve",
          "signature": "Approve(gloss_or_hvo)",
          "summary": "Mark a gloss as human-approved.",
          "description": "Mark a gloss as human-approved.\n\nThis implicitly approves the owning analysis as well.\n",
          "parameters": [
            {
              "name": "gloss_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiGloss object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If gloss_or_hvo is None"
          ],
          "example": "            >>> gloss = project.WfiGlosses.Create(analysis, \"run\")\n            >>> project.WfiGlosses.Approve(gloss)\n            >>>\n            >>> # Check approval\n            >>> if project.WfiGlosses.IsHumanApproved(gloss):\n            ...     print(\"Gloss is now approved\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(analysis_or_hvo, gloss_text, wsHandle=None)",
          "summary": "Create a new gloss for a wordform analysis.",
          "description": "Create a new gloss for a wordform analysis.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            },
            {
              "name": "gloss_text",
              "type": "str",
              "default": null,
              "description": "The gloss translation text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "IWfiGloss: The newly created gloss ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If analysis_or_hvo or gloss_text is None",
            "FP_ParameterError: If gloss_text is empty"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Create(wordform)\n            >>> gloss = project.WfiGlosses.Create(analysis, \"run\", project.WSHandle('en'))\n            >>> print(project.WfiGlosses.GetForm(gloss))\n            run\n\n            >>> # Create gloss in different language\n            >>> gloss_fr = project.WfiGlosses.Create(analysis, \"courir\", project.WSHandle('fr'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(gloss_or_hvo)",
          "summary": "Delete a wordform gloss.",
          "description": "Delete a wordform gloss.\n",
          "parameters": [
            {
              "name": "gloss_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiGloss object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If gloss_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> glosses = list(project.WfiGlosses.GetAll(analysis))\n            >>> if len(glosses) > 1:\n            ...     # Delete duplicate or incorrect gloss\n            ...     project.WfiGlosses.Delete(glosses[1])\n\n        Warning:\n            - This is a destructive operation\n            - Cannot be undone\n            - If this was an approved gloss, approval is cleared\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(analysis_or_hvo, index)",
          "summary": "Find a gloss by its index in the analysis's glosses.",
          "description": "Find a gloss by its index in the analysis's glosses.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "Zero-based index of the gloss"
            }
          ],
          "returns": "IWfiGloss or None: The gloss object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> # Get first gloss\n            >>> first_gloss = project.WfiGlosses.Find(analysis, 0)\n            >>> if first_gloss:\n            ...     print(project.WfiGlosses.GetForm(first_gloss))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(analysis_or_hvo)",
          "summary": "Get all glosses for a wordform analysis.",
          "description": "Get all glosses for a wordform analysis.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            }
          ],
          "returns": "IWfiGloss: Each gloss object for the analysis ",
          "raises": [
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> for gloss in project.WfiGlosses.GetAll(analysis):\n            ...     text = project.WfiGlosses.GetForm(gloss)\n            ...     approved = project.WfiGlosses.IsHumanApproved(gloss)\n            ...     print(f\"{text} ({'' if approved else '?'})\")\n            run ()\n            to run (?)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(gloss_or_hvo, wsHandle=None)",
          "summary": "Get the text form of a gloss.",
          "description": "Get the text form of a gloss.\n",
          "parameters": [
            {
              "name": "gloss_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiGloss object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "str: The gloss text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If gloss_or_hvo is None"
          ],
          "example": "            >>> gloss = project.WfiGlosses.Find(analysis, 0)\n            >>> text = project.WfiGlosses.GetForm(gloss)\n            >>> print(text)\n            run\n\n            >>> # Get in specific writing system\n            >>> text_fr = project.WfiGlosses.GetForm(gloss, project.WSHandle('fr'))\n\n        See Also:\n            SetForm, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "IsHumanApproved",
          "signature": "IsHumanApproved(gloss_or_hvo)",
          "summary": "Check if a gloss is human-approved.",
          "description": "Check if a gloss is human-approved.\n\nHuman approval distinguishes verified translations from parser guesses.\n",
          "parameters": [
            {
              "name": "gloss_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiGloss object or its HVO"
            }
          ],
          "returns": "bool: True if human-approved, False otherwise ",
          "raises": [
            "FP_NullParameterError: If gloss_or_hvo is None"
          ],
          "example": "            >>> for gloss in project.WfiGlosses.GetAll(analysis):\n            ...     if project.WfiGlosses.IsHumanApproved(gloss):\n            ...         print(\"Verified gloss\")\n            ...     else:\n            ...         print(\"Parser guess\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetForm",
          "signature": "SetForm(gloss_or_hvo, text, wsHandle=None)",
          "summary": "Set the text form of a gloss.",
          "description": "Set the text form of a gloss.\n",
          "parameters": [
            {
              "name": "gloss_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiGloss object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new gloss text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to analysis WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If gloss_or_hvo or text is None",
            "FP_ParameterError: If text is empty"
          ],
          "example": "            >>> gloss = project.WfiGlosses.Find(analysis, 0)\n            >>> project.WfiGlosses.SetForm(gloss, \"to run\")\n            >>> print(project.WfiGlosses.GetForm(gloss))\n            to run\n\n        See Also:\n            GetForm",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize WfiGlossOperations with a FLExProject instance.",
          "description": "Initialize WfiGlossOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "wordform",
        "operations"
      ]
    },
    "WfiMorphBundleOperations": {
      "name": "WfiMorphBundleOperations",
      "type": "class",
      "namespace": "FlexLibs2.Wordform.WfiMorphBundleOperations",
      "source_file": "Wordform/WfiMorphBundleOperations",
      "category": "wordform",
      "summary": "This class provides operations for managing wordform morpheme bundles.",
      "description": "This class provides operations for managing wordform morpheme bundles.\n\nA WfiMorphBundle represents one morpheme in a wordform analysis, linking:\n- Morpheme form (surface representation)\n- Lexical sense (meaning from lexicon)\n- Morpheme type (stem, prefix, suffix, etc.)\n\nMorph bundles form the morphological breakdown, connecting texts to the lexicon.\nThey enable interlinear glossing and parser training.\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Get analysis\nwordform = project.Wordforms.FindOrCreate(\"hlauka\")\nanalysis = project.WfiAnalyses.Create(wordform)\n\n# Create morph bundles for stem + suffix\nstem_bundle = project.WfiMorphBundles.Create(analysis, \"hlauk-\")\nsuffix_bundle = project.WfiMorphBundles.Create(analysis, \"-a\")\n\n# Link to lexical entries\nstem_entry = project.LexEntry.Find(\"hlauk\")\nif stem_entry and stem_entry.SensesOS.Count > 0:\nsense = stem_entry.SensesOS[0]\nproject.WfiMorphBundles.SetSense(stem_bundle, sense)\n\n# Set morpheme type\nproject.WfiMorphBundles.SetMorphemeType(stem_bundle, \"stem\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(analysis_or_hvo, form, sense=None, wsHandle=None)",
          "summary": "Create a new morpheme bundle in an analysis.",
          "description": "Create a new morpheme bundle in an analysis.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            },
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The morpheme form text"
            },
            {
              "name": "sense",
              "type": "",
              "default": null,
              "description": "Optional ILexSense object to link to"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IWfiMorphBundle: The newly created morph bundle ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If analysis_or_hvo or form is None",
            "FP_ParameterError: If form is empty"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Create(wordform)\n            >>>\n            >>> # Create stem bundle\n            >>> stem = project.WfiMorphBundles.Create(analysis, \"hlauk-\")\n            >>>\n            >>> # Create suffix bundle with linked sense\n            >>> suffix_entry = project.LexEntry.Find(\"-a\")\n            >>> if suffix_entry and suffix_entry.SensesOS.Count > 0:\n            ...     sense = suffix_entry.SensesOS[0]\n            ...     suffix = project.WfiMorphBundles.Create(analysis, \"-a\", sense)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(bundle_or_hvo)",
          "summary": "Delete a morpheme bundle from an analysis.",
          "description": "Delete a morpheme bundle from an analysis.\n",
          "parameters": [
            {
              "name": "bundle_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiMorphBundle object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If bundle_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> bundles = list(project.WfiMorphBundles.GetAll(analysis))\n            >>> if len(bundles) > 2:\n            ...     # Delete incorrect morpheme\n            ...     project.WfiMorphBundles.Delete(bundles[1])\n\n        Warning:\n            - This is a destructive operation\n            - Cannot be undone\n            - Changes the morphological breakdown\n            - May affect parser training\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(analysis_or_hvo, index)",
          "summary": "Find a morph bundle by its index in the analysis.",
          "description": "Find a morph bundle by its index in the analysis.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            },
            {
              "name": "index",
              "type": "int",
              "default": null,
              "description": "Zero-based index of the morph bundle"
            }
          ],
          "returns": "IWfiMorphBundle or None: The bundle object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> # Get first morpheme (typically the stem)\n            >>> first_bundle = project.WfiMorphBundles.Find(analysis, 0)\n            >>> if first_bundle:\n            ...     form = project.WfiMorphBundles.GetForm(first_bundle)\n            ...     print(f\"First morpheme: {form}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll(analysis_or_hvo)",
          "summary": "Get all morpheme bundles in an analysis.",
          "description": "Get all morpheme bundles in an analysis.\n",
          "parameters": [
            {
              "name": "analysis_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiAnalysis object or its HVO"
            }
          ],
          "returns": "IWfiMorphBundle: Each morph bundle object in the analysis ",
          "raises": [
            "FP_NullParameterError: If analysis_or_hvo is None"
          ],
          "example": "            >>> analysis = project.WfiAnalyses.Find(wordform, 0)\n            >>> for bundle in project.WfiMorphBundles.GetAll(analysis):\n            ...     form = project.WfiMorphBundles.GetForm(bundle)\n            ...     sense = project.WfiMorphBundles.GetSense(bundle)\n            ...     gloss = project.Senses.GetGloss(sense) if sense else \"?\"\n            ...     print(f\"{form} = {gloss}\")\n            hlauk- = run\n            -a = VERB\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(bundle_or_hvo, wsHandle=None)",
          "summary": "Get the morpheme form of a morph bundle.",
          "description": "Get the morpheme form of a morph bundle.\n",
          "parameters": [
            {
              "name": "bundle_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiMorphBundle object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The morpheme form text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If bundle_or_hvo is None"
          ],
          "example": "            >>> bundle = project.WfiMorphBundles.Find(analysis, 0)\n            >>> form = project.WfiMorphBundles.GetForm(bundle)\n            >>> print(form)\n            hlauk-\n\n        See Also:\n            SetForm, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetMorphemeType",
          "signature": "GetMorphemeType(bundle_or_hvo)",
          "summary": "Get the morpheme type (stem, prefix, suffix, etc.",
          "description": "Get the morpheme type (stem, prefix, suffix, etc.) of a morph bundle.\n",
          "parameters": [
            {
              "name": "bundle_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiMorphBundle object or its HVO"
            }
          ],
          "returns": "IMoMorphType or None: The morph type object, or None if not set ",
          "raises": [
            "FP_NullParameterError: If bundle_or_hvo is None"
          ],
          "example": "            >>> bundle = project.WfiMorphBundles.Find(analysis, 0)\n            >>> morph_type = project.WfiMorphBundles.GetMorphemeType(bundle)\n            >>> if morph_type:\n            ...     name = ITsString(morph_type.Name.BestAnalysisAlternative).Text\n            ...     print(f\"Morpheme type: {name}\")\n            Morpheme type: stem\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSense",
          "signature": "GetSense(bundle_or_hvo)",
          "summary": "Get the lexical sense linked to this morph bundle.",
          "description": "Get the lexical sense linked to this morph bundle.\n",
          "parameters": [
            {
              "name": "bundle_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiMorphBundle object or its HVO"
            }
          ],
          "returns": "ILexSense or None: The linked sense, or None if not linked ",
          "raises": [
            "FP_NullParameterError: If bundle_or_hvo is None"
          ],
          "example": "            >>> bundle = project.WfiMorphBundles.Find(analysis, 0)\n            >>> sense = project.WfiMorphBundles.GetSense(bundle)\n            >>> if sense:\n            ...     gloss = project.Senses.GetGloss(sense)\n            ...     entry = sense.Entry\n            ...     headword = project.LexEntry.GetHeadword(entry)\n            ...     print(f\"{headword}: {gloss}\")\n            hlauk: run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetForm",
          "signature": "SetForm(bundle_or_hvo, text, wsHandle=None)",
          "summary": "Set the morpheme form of a morph bundle.",
          "description": "Set the morpheme form of a morph bundle.\n",
          "parameters": [
            {
              "name": "bundle_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiMorphBundle object or its HVO"
            },
            {
              "name": "text",
              "type": "str",
              "default": null,
              "description": "The new morpheme form text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If bundle_or_hvo or text is None",
            "FP_ParameterError: If text is empty"
          ],
          "example": "            >>> bundle = project.WfiMorphBundles.Find(analysis, 0)\n            >>> project.WfiMorphBundles.SetForm(bundle, \"hlauka-\")\n            >>> print(project.WfiMorphBundles.GetForm(bundle))\n            hlauka-\n\n        See Also:\n            GetForm",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetMorphemeType",
          "signature": "SetMorphemeType(bundle_or_hvo, type_or_name)",
          "summary": "Set the morpheme type (stem, prefix, suffix, etc.",
          "description": "Set the morpheme type (stem, prefix, suffix, etc.) of a morph bundle.\n",
          "parameters": [
            {
              "name": "bundle_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiMorphBundle object or its HVO"
            },
            {
              "name": "type_or_name",
              "type": "",
              "default": null,
              "description": "Either an IMoMorphType object or a type name (str) such as \"stem\", \"prefix\", \"suffix\", etc."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If bundle_or_hvo or type_or_name is None",
            "FP_ParameterError: If type name not found"
          ],
          "example": "            >>> bundle = project.WfiMorphBundles.Find(analysis, 0)\n            >>> project.WfiMorphBundles.SetMorphemeType(bundle, \"stem\")\n            >>>\n            >>> suffix = project.WfiMorphBundles.Find(analysis, 1)\n            >>> project.WfiMorphBundles.SetMorphemeType(suffix, \"suffix\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetSense",
          "signature": "SetSense(bundle_or_hvo, sense)",
          "summary": "Link a lexical sense to this morph bundle.",
          "description": "Link a lexical sense to this morph bundle.\n",
          "parameters": [
            {
              "name": "bundle_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiMorphBundle object or its HVO"
            },
            {
              "name": "sense",
              "type": "",
              "default": null,
              "description": "ILexSense object to link (or None to clear link)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If bundle_or_hvo is None"
          ],
          "example": "            >>> bundle = project.WfiMorphBundles.Find(analysis, 0)\n            >>>\n            >>> # Find lexical entry and link its sense\n            >>> entry = project.LexEntry.Find(\"hlauk\")\n            >>> if entry and entry.SensesOS.Count > 0:\n            ...     sense = entry.SensesOS[0]\n            ...     project.WfiMorphBundles.SetSense(bundle, sense)\n            >>>\n            >>> # Clear sense link\n            >>> project.WfiMorphBundles.SetSense(bundle, None)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize WfiMorphBundleOperations with a FLExProject instance.",
          "description": "Initialize WfiMorphBundleOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "wordform",
        "operations"
      ]
    },
    "SpellingStatusStates": {
      "name": "SpellingStatusStates",
      "type": "class",
      "namespace": "FlexLibs2.TextsWords.WordformOperations",
      "source_file": "TextsWords/WordformOperations",
      "category": "texts",
      "summary": "Spelling status values for wordforms.",
      "description": "Spelling status values for wordforms.",
      "example": "",
      "base_classes": [],
      "methods": [],
      "properties": [],
      "lcm_dependencies": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "texts"
      ]
    },
    "WordformOperations": {
      "name": "WordformOperations",
      "type": "class",
      "namespace": "FlexLibs2.TextsWords.WordformOperations",
      "source_file": "TextsWords/WordformOperations",
      "category": "texts",
      "summary": "Provides operations for managing wordforms in a FLEx project.",
      "description": "Provides operations for managing wordforms in a FLEx project.\n\nWordforms represent surface forms of words as they appear in texts.\nEach wordform can have multiple analyses and a spelling status.\n\nThis class should be accessed via FLExProject.Wordforms property.\n",
      "example": "        >>> project = FLExProject()\n        >>> project.OpenProject(\"MyProject\")\n        >>> # Get all wordforms\n        >>> for wf in project.Wordforms.GetAll():\n        ...     print(project.Wordforms.GetForm(wf))\n        >>> # Create a new wordform\n        >>> wf = project.Wordforms.Create(\"running\")\n        >>> # Set spelling status\n        >>> project.Wordforms.SetSpellingStatus(wf, SpellingStatusStates.CORRECT)",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "ApproveSpelling",
          "signature": "ApproveSpelling(wordform_or_hvo)",
          "summary": "Approve the spelling of a wordform by setting status to CORRECT.",
          "description": "Approve the spelling of a wordform by setting status to CORRECT.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_ParameterError: If wordform doesn't exist"
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"colour\")\n            >>> project.Wordforms.ApproveSpelling(wf)\n            >>>\n            >>> # Approve multiple wordforms\n            >>> for wf in project.Wordforms.GetAllWithStatus(SpellingStatusStates.UNDECIDED):\n            ...     if should_approve(wf):\n            ...         project.Wordforms.ApproveSpelling(wf)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "CompareTo",
          "signature": "CompareTo(item1, item2, ops1=None, ops2=None)",
          "summary": "Compare two wordforms for differences.",
          "description": "Compare two wordforms for differences.\n",
          "parameters": [
            {
              "name": "item1",
              "type": "",
              "default": null,
              "description": "First wordform object (from project 1)"
            },
            {
              "name": "item2",
              "type": "",
              "default": null,
              "description": "Second wordform object (from project 2)"
            },
            {
              "name": "ops1",
              "type": "",
              "default": null,
              "description": "Optional WordformOperations instance for project 1 (defaults to self)"
            },
            {
              "name": "ops2",
              "type": "",
              "default": null,
              "description": "Optional WordformOperations instance for project 2 (defaults to self)"
            }
          ],
          "returns": "tuple: (is_different, differences_dict) - is_different (bool): True if wordforms differ, False if identical - differences_dict (dict): Maps property names to (value1, value2) tuples ",
          "raises": [],
          "example": "            >>> is_diff, diffs = ops1.CompareTo(wf1, wf2, ops1, ops2)\n            >>> if is_diff:\n            ...     for prop, (val1, val2) in diffs.items():\n            ...         print(f\"{prop}: {val1} != {val2}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Create",
          "signature": "Create(form, wsHandle=None)",
          "summary": "Create a new wordform in the FLEx project.",
          "description": "Create a new wordform in the FLEx project.\n",
          "parameters": [
            {
              "name": "form",
              "type": "",
              "default": null,
              "description": "The surface text form of the wordform"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IWfiWordform: The newly created wordform object ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If form is empty or None"
          ],
          "example": "            >>> wf = project.Wordforms.Create(\"running\")\n            >>> print(project.Wordforms.GetForm(wf))\n            running\n            >>> # Create in specific writing system\n            >>> wf_fr = project.Wordforms.Create(\"courir\", \"fr\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(wordform_or_hvo)",
          "summary": "Delete a wordform from the FLEx project.",
          "description": "Delete a wordform from the FLEx project.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO (database ID)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_ParameterError: If wordform doesn't exist"
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"obsolete\")\n            >>> if wf:\n            ...     project.Wordforms.Delete(wf)\n\n        Warning:\n            - This is a destructive operation\n            - All analyses associated with the wordform will also be deleted\n            - Consider setting spelling status to INCORRECT instead of deleting\n\n        See Also:\n            Create, SetSpellingStatus",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Duplicate",
          "signature": "Duplicate(item_or_hvo, insert_after=True, deep=False)",
          "summary": "Duplicate a wordform, creating a new copy with a new GUID.",
          "description": "Duplicate a wordform, creating a new copy with a new GUID.\n",
          "parameters": [
            {
              "name": "item_or_hvo",
              "type": "",
              "default": null,
              "description": "The IWfiWordform object or HVO to duplicate."
            },
            {
              "name": "insert_after",
              "type": "bool",
              "default": true,
              "description": "Not applicable for wordforms (ignored)."
            },
            {
              "name": "deep",
              "type": "bool",
              "default": false,
              "description": "If True, also duplicate analyses. If False (default), only copy wordform properties."
            }
          ],
          "returns": "IWfiWordform: The newly created duplicate with a new GUID. ",
          "raises": [
            "FP_ReadOnlyError: If the project is not opened with write enabled.",
            "FP_NullParameterError: If item_or_hvo is None."
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"running\")\n            >>> if wf:\n            ...     dup = project.Wordforms.Duplicate(wf)\n            ...     # Change the form to create a variant\n            ...     project.Wordforms.SetForm(dup, \"runnin'\")\n            ...     print(f\"Duplicate: {project.Wordforms.GetForm(dup)}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Exists",
          "signature": "Exists(form, wsHandle=None)",
          "summary": "Check if a wordform exists in the FLEx project.",
          "description": "Check if a wordform exists in the FLEx project.\n",
          "parameters": [
            {
              "name": "form",
              "type": "",
              "default": null,
              "description": "The surface text form to check"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "bool: True if the wordform exists, False otherwise ",
          "raises": [],
          "example": "            >>> if project.Wordforms.Exists(\"running\"):\n            ...     wf = project.Wordforms.Find(\"running\")\n            ... else:\n            ...     wf = project.Wordforms.Create(\"running\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(form, wsHandle=None)",
          "summary": "Find and return a wordform by its surface form.",
          "description": "Find and return a wordform by its surface form.\n",
          "parameters": [
            {
              "name": "form",
              "type": "",
              "default": null,
              "description": "The surface text form to find"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IWfiWordform or None: The wordform object if found, None otherwise ",
          "raises": [],
          "example": "            >>> wf = project.Wordforms.Find(\"running\")\n            >>> if wf:\n            ...     status = project.Wordforms.GetSpellingStatus(wf)\n            ...     print(f\"Spelling status: {status}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Retrieve all wordforms in the FLEx project.",
          "description": "Retrieve all wordforms in the FLEx project.\n\nThis method returns an iterator over all IWfiWordform objects in the\nproject database, allowing iteration over the complete wordform inventory.\n",
          "parameters": [],
          "returns": "IWfiWordform: Each wordform object in the project ",
          "raises": [],
          "example": "            >>> for wordform in project.Wordforms.GetAll():\n            ...     form = project.Wordforms.GetForm(wordform)\n            ...     print(form)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllUnapproved",
          "signature": "GetAllUnapproved()",
          "summary": "Retrieve all wordforms that are not approved (not CORRECT status).",
          "description": "Retrieve all wordforms that are not approved (not CORRECT status).\n",
          "parameters": [],
          "returns": "IWfiWordform: Each wordform object with UNDECIDED or INCORRECT status ",
          "raises": [],
          "example": "            >>> # Get all unapproved wordforms\n            >>> for wf in project.Wordforms.GetAllUnapproved():\n            ...     form = project.Wordforms.GetForm(wf)\n            ...     status = project.Wordforms.GetSpellingStatus(wf)\n            ...     print(f\"{form}: status={status}\")\n            >>>\n            >>> # Count unapproved wordforms\n            >>> unapproved_count = sum(1 for _ in project.Wordforms.GetAllUnapproved())\n            >>> print(f\"Total unapproved: {unapproved_count}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAllWithStatus",
          "signature": "GetAllWithStatus(status)",
          "summary": "Retrieve all wordforms with a specific spelling status.",
          "description": "Retrieve all wordforms with a specific spelling status.\n",
          "parameters": [
            {
              "name": "status",
              "type": "",
              "default": null,
              "description": "The spelling status to filter by (from SpellingStatusStates)"
            }
          ],
          "returns": "IWfiWordform: Each wordform object with the specified status ",
          "raises": [
            "FP_ParameterError: If status is invalid"
          ],
          "example": "            >>> # Get all correctly spelled wordforms\n            >>> correct_wfs = list(project.Wordforms.GetAllWithStatus(SpellingStatusStates.CORRECT))\n            >>> print(f\"Found {len(correct_wfs)} approved wordforms\")\n            >>>\n            >>> # Get all misspellings\n            >>> for wf in project.Wordforms.GetAllWithStatus(SpellingStatusStates.INCORRECT):\n            ...     form = project.Wordforms.GetForm(wf)\n            ...     print(f\"Misspelling: {form}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnalyses",
          "signature": "GetAnalyses(wordform_or_hvo)",
          "summary": "Get all analyses associated with a wordform.",
          "description": "Get all analyses associated with a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "list: List of IWfiAnalysis objects for this wordform ",
          "raises": [
            "FP_ParameterError: If wordform doesn't exist"
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"running\")\n            >>> analyses = project.Wordforms.GetAnalyses(wf)\n            >>> for analysis in analyses:\n            ...     # Process each analysis\n            ...     print(f\"Analysis HVO: {analysis.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetChecksum",
          "signature": "GetChecksum(wordform_or_hvo)",
          "summary": "Get the checksum of a wordform.",
          "description": "Get the checksum of a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "int: The wordform's checksum value ",
          "raises": [
            "FP_ParameterError: If wordform doesn't exist"
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"running\")\n            >>> checksum = project.Wordforms.GetChecksum(wf)\n            >>> print(f\"Checksum: {checksum}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(wordform_or_hvo, wsHandle=None)",
          "summary": "Get the surface text form of a wordform.",
          "description": "Get the surface text form of a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The text form of the wordform (empty string if not set) ",
          "raises": [
            "FP_ParameterError: If wordform doesn't exist"
          ],
          "example": "            >>> for wf in project.Wordforms.GetAll():\n            ...     form = project.Wordforms.GetForm(wf)\n            ...     print(form)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOccurrenceCount",
          "signature": "GetOccurrenceCount(wordform_or_hvo)",
          "summary": "Get the count of occurrences of a wordform in texts.",
          "description": "Get the count of occurrences of a wordform in texts.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "int: Number of times this wordform appears in project texts ",
          "raises": [
            "FP_ParameterError: If wordform doesn't exist"
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"running\")\n            >>> count = project.Wordforms.GetOccurrenceCount(wf)\n            >>> print(f\"'running' appears {count} times in texts\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOccurrences",
          "signature": "GetOccurrences(wordform_or_hvo)",
          "summary": "Get all segment occurrences of a wordform in texts.",
          "description": "Get all segment occurrences of a wordform in texts.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "list: List of segment objects where this wordform appears ",
          "raises": [
            "FP_ParameterError: If wordform doesn't exist"
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"running\")\n            >>> occurrences = project.Wordforms.GetOccurrences(wf)\n            >>> for segment in occurrences:\n            ...     # Process each text segment containing this wordform\n            ...     print(f\"Segment HVO: {segment.Hvo}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSpellingStatus",
          "signature": "GetSpellingStatus(wordform_or_hvo)",
          "summary": "Get the spelling status of a wordform.",
          "description": "Get the spelling status of a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "int: The current spelling status (0=UNDECIDED, 1=INCORRECT, 2=CORRECT) ",
          "raises": [
            "FP_ParameterError: If wordform doesn't exist"
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"running\")\n            >>> status = project.Wordforms.GetSpellingStatus(wf)\n            >>> if status == SpellingStatusStates.UNDECIDED:\n            ...     project.Wordforms.SetSpellingStatus(wf, SpellingStatusStates.CORRECT)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetSyncableProperties",
          "signature": "GetSyncableProperties(item)",
          "summary": "Get all syncable properties of a wordform.",
          "description": "Get all syncable properties of a wordform.\n",
          "parameters": [
            {
              "name": "item",
              "type": "",
              "default": null,
              "description": "The IWfiWordform object."
            }
          ],
          "returns": "dict: Dictionary of syncable properties with their values. ",
          "raises": [],
          "example": "            >>> props = project.Wordforms.GetSyncableProperties(wordform)\n            >>> print(props['Form'])\n            {'en': 'running'}\n            >>> print(props['SpellingStatus'])\n            2  # CORRECT\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetForm",
          "signature": "SetForm(wordform_or_hvo, form, wsHandle=None)",
          "summary": "Set the surface text form of a wordform.",
          "description": "Set the surface text form of a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            },
            {
              "name": "form",
              "type": "",
              "default": null,
              "description": "The new text form to set"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If form is empty or None",
            "FP_ParameterError: If wordform doesn't exist"
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"runing\")  # misspelled\n            >>> if wf:\n            ...     project.Wordforms.SetForm(wf, \"running\")  # correct it\n\n        Warning:\n            - Changing a wordform's text may affect text parsing\n            - May create duplicate if another wordform has same form\n            - Use carefully - consider creating new wordform instead\n\n        See Also:\n            GetForm, Create",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetSpellingStatus",
          "signature": "SetSpellingStatus(wordform_or_hvo, status)",
          "summary": "Set the spelling status of a wordform.",
          "description": "Set the spelling status of a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            },
            {
              "name": "status",
              "type": "",
              "default": null,
              "description": "The new spelling status (0, 1, or 2 from SpellingStatusStates)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_ParameterError: If wordform doesn't exist or status is invalid"
          ],
          "example": "            >>> wf = project.Wordforms.Find(\"colour\")\n            >>> project.Wordforms.SetSpellingStatus(wf, SpellingStatusStates.CORRECT)\n            >>>\n            >>> typo = project.Wordforms.Find(\"teh\")\n            >>> project.Wordforms.SetSpellingStatus(typo, SpellingStatusStates.INCORRECT)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize WordformOperations.",
          "description": "Initialize WordformOperations.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "FLExProject instance"
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "texts",
        "operations"
      ]
    },
    "WfiWordformOperations": {
      "name": "WfiWordformOperations",
      "type": "class",
      "namespace": "FlexLibs2.Wordform.WfiWordformOperations",
      "source_file": "Wordform/WfiWordformOperations",
      "category": "wordform",
      "summary": "This class provides operations for managing wordforms in the Wordform Inventory.",
      "description": "This class provides operations for managing wordforms in the Wordform Inventory.\n\nThe Wordform Inventory stores unique word forms encountered in interlinear texts.\nEach wordform can have multiple analyses representing different morphological\nbreakdowns. This is the MOST ACTIVE area of FLEx (727+ commits in 2024).\n\nWordforms bridge texts and lexicon, enabling:\n- Parser training and improvement\n- Interlinear text analysis\n- Concordance generation\n- Word frequency analysis\n\nUsage::\n\nfrom flexlibs import FLExProject\n\nproject = FLExProject()\nproject.OpenProject(\"my project\", writeEnabled=True)\n\n# Find or create wordform\nvern_ws = project.project.DefaultVernWs\nwordform = project.Wordforms.FindOrCreate(\"hlauka\", vern_ws)\n\n# Get all analyses\nfor analysis in project.Wordforms.GetAnalyses(wordform):\ngloss = project.WfiAnalyses.GetGlosses(analysis)\nprint(f\"Analysis: {gloss}\")\n\n# Set approved analysis\nif wordform.AnalysesOC.Count > 0:\nbest = wordform.AnalysesOC[0]\nproject.Wordforms.SetApprovedAnalysis(wordform, best)\n\n# Get occurrence count\ncount = project.Wordforms.GetOccurrences(wordform)\nprint(f\"Occurs {count} times in texts\")\n\nproject.CloseProject()",
      "example": "",
      "base_classes": [
        "BaseOperations"
      ],
      "methods": [
        {
          "name": "Create",
          "signature": "Create(form, wsHandle=None)",
          "summary": "Create a new wordform in the Wordform Inventory.",
          "description": "Create a new wordform in the Wordform Inventory.\n",
          "parameters": [
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The wordform text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IWfiWordform: The newly created wordform ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If form is None",
            "FP_ParameterError: If form is empty"
          ],
          "example": "            >>> wordform = project.Wordforms.Create(\"hlauka\")\n            >>> print(project.Wordforms.GetForm(wordform))\n            hlauka\n\n            >>> # Create with specific writing system\n            >>> wordform = project.Wordforms.Create(\"hello\", project.WSHandle('en'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Delete",
          "signature": "Delete(wordform_or_hvo)",
          "summary": "Delete a wordform from the Wordform Inventory.",
          "description": "Delete a wordform from the Wordform Inventory.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If wordform_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"obsolete\")\n            >>> if wordform:\n            ...     project.Wordforms.Delete(wordform)\n\n        Warning:\n            - This is a destructive operation\n            - All analyses for this wordform will be deleted\n            - Text occurrences may become unlinked\n            - Cannot be undone\n            - Use with caution - wordforms are typically managed automatically\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "Find",
          "signature": "Find(form, wsHandle=None)",
          "summary": "Find a wordform by its form text.",
          "description": "Find a wordform by its form text.\n",
          "parameters": [
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The wordform text to search for"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IWfiWordform or None: The wordform object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If form is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> if wordform:\n            ...     analyses = wordform.AnalysesOC.Count\n            ...     print(f\"Found wordform with {analyses} analyses\")\n            Found wordform with 3 analyses\n\n            >>> # Search in specific writing system\n            >>> wordform = project.Wordforms.Find(\"hello\", project.WSHandle('en'))\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindByHvo",
          "signature": "FindByHvo(hvo)",
          "summary": "Find a wordform by its HVO (database ID).",
          "description": "Find a wordform by its HVO (database ID).\n",
          "parameters": [
            {
              "name": "hvo",
              "type": "int",
              "default": null,
              "description": "The HVO of the wordform"
            }
          ],
          "returns": "IWfiWordform or None: The wordform object if found, None otherwise ",
          "raises": [
            "FP_NullParameterError: If hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.FindByHvo(12345)\n            >>> if wordform:\n            ...     form = project.Wordforms.GetForm(wordform)\n            ...     print(f\"Found wordform: {form}\")\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "FindOrCreate",
          "signature": "FindOrCreate(form, wsHandle=None)",
          "summary": "Find an existing wordform or create a new one.",
          "description": "Find an existing wordform or create a new one.\n\nThis is the most common pattern for working with the Wordform Inventory.\nIt ensures a wordform exists without creating duplicates.\n",
          "parameters": [
            {
              "name": "form",
              "type": "str",
              "default": null,
              "description": "The wordform text"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "IWfiWordform: The found or created wordform ",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled (for create)",
            "FP_NullParameterError: If form is None",
            "FP_ParameterError: If form is empty"
          ],
          "example": "            >>> # Safe pattern - always returns a wordform\n            >>> wordform = project.Wordforms.FindOrCreate(\"hlauka\")\n            >>> print(project.Wordforms.GetForm(wordform))\n            hlauka\n\n            >>> # Use when processing interlinear texts\n            >>> for word_text in text_words:\n            ...     wf = project.Wordforms.FindOrCreate(word_text)\n            ...     # Add analysis, gloss, etc.\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAll",
          "signature": "GetAll()",
          "summary": "Get all wordforms in the Wordform Inventory.",
          "description": "Get all wordforms in the Wordform Inventory.\n",
          "parameters": [],
          "returns": "IWfiWordform: Each wordform object in the inventory ",
          "raises": [],
          "example": "            >>> for wordform in project.Wordforms.GetAll():\n            ...     form = project.Wordforms.GetForm(wordform)\n            ...     analyses = wordform.AnalysesOC.Count\n            ...     print(f\"{form}: {analyses} analyses\")\n            hlauka: 3 analyses\n            gula: 2 analyses\n            zwane: 1 analysis\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetAnalyses",
          "signature": "GetAnalyses(wordform_or_hvo)",
          "summary": "Get all analyses for a wordform.",
          "description": "Get all analyses for a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "list: List of IWfiAnalysis objects ",
          "raises": [
            "FP_NullParameterError: If wordform_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> analyses = project.Wordforms.GetAnalyses(wordform)\n            >>> for analysis in analyses:\n            ...     approved = project.WfiAnalyses.IsHumanApproved(analysis)\n            ...     status = \"approved\" if approved else \"parser guess\"\n            ...     print(f\"Analysis: {status}\")\n            Analysis: approved\n            Analysis: parser guess\n            Analysis: parser guess\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetApprovedAnalysis",
          "signature": "GetApprovedAnalysis(wordform_or_hvo)",
          "summary": "Get the human-approved analysis for a wordform.",
          "description": "Get the human-approved analysis for a wordform.\n\nThe approved analysis is the linguist's preferred morphological breakdown,\ndistinguishing it from parser guesses.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "IWfiAnalysis or None: The approved analysis, or None if not set ",
          "raises": [
            "FP_NullParameterError: If wordform_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> approved = project.Wordforms.GetApprovedAnalysis(wordform)\n            >>> if approved:\n            ...     glosses = project.WfiAnalyses.GetGlosses(approved)\n            ...     print(f\"Approved analysis: {glosses}\")\n            ... else:\n            ...     print(\"No approved analysis yet\")\n            Approved analysis: run\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetForm",
          "signature": "GetForm(wordform_or_hvo, wsHandle=None)",
          "summary": "Get the text form of a wordform.",
          "description": "Get the text form of a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            },
            {
              "name": "wsHandle",
              "type": "",
              "default": null,
              "description": "Optional writing system handle. Defaults to vernacular WS."
            }
          ],
          "returns": "str: The wordform text (empty string if not set) ",
          "raises": [
            "FP_NullParameterError: If wordform_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.FindOrCreate(\"hlauka\")\n            >>> form = project.Wordforms.GetForm(wordform)\n            >>> print(form)\n            hlauka\n\n        See Also:\n            Find, FindOrCreate",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "GetOccurrences",
          "signature": "GetOccurrences(wordform_or_hvo)",
          "summary": "Get the number of times this wordform occurs in texts.",
          "description": "Get the number of times this wordform occurs in texts.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            }
          ],
          "returns": "int: The occurrence count ",
          "raises": [
            "FP_NullParameterError: If wordform_or_hvo is None"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> count = project.Wordforms.GetOccurrences(wordform)\n            >>> print(f\"'hlauka' occurs {count} times in texts\")\n            'hlauka' occurs 15 times in texts\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "SetApprovedAnalysis",
          "signature": "SetApprovedAnalysis(wordform_or_hvo, analysis)",
          "summary": "Set the human-approved analysis for a wordform.",
          "description": "Set the human-approved analysis for a wordform.\n",
          "parameters": [
            {
              "name": "wordform_or_hvo",
              "type": "",
              "default": null,
              "description": "Either an IWfiWordform object or its HVO"
            },
            {
              "name": "analysis",
              "type": "",
              "default": null,
              "description": "IWfiAnalysis object to approve (or None to clear approval)"
            }
          ],
          "returns": "",
          "raises": [
            "FP_ReadOnlyError: If project is not opened with write enabled",
            "FP_NullParameterError: If wordform_or_hvo is None",
            "FP_ParameterError: If analysis doesn't belong to this wordform"
          ],
          "example": "            >>> wordform = project.Wordforms.Find(\"hlauka\")\n            >>> analyses = project.Wordforms.GetAnalyses(wordform)\n            >>> if analyses:\n            ...     # Approve first analysis\n            ...     project.Wordforms.SetApprovedAnalysis(wordform, analyses[0])\n\n            >>> # Clear approval\n            >>> project.Wordforms.SetApprovedAnalysis(wordform, None)\n",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        },
        {
          "name": "__init__",
          "signature": "__init__(project)",
          "summary": "Initialize WfiWordformOperations with a FLExProject instance.",
          "description": "Initialize WfiWordformOperations with a FLExProject instance.\n",
          "parameters": [
            {
              "name": "project",
              "type": "",
              "default": null,
              "description": "The FLExProject instance to operate on."
            }
          ],
          "returns": "",
          "raises": [],
          "example": "",
          "is_property": false,
          "is_classmethod": false,
          "is_staticmethod": false
        }
      ],
      "properties": [],
      "lcm_dependencies": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ],
      "tags": [
        "wordform",
        "operations"
      ]
    }
  },
  "categories": {
    "general": {
      "description": "Operations related to general",
      "entities": [
        "BaseOperations",
        "FP_ProjectError",
        "FP_FileNotFoundError",
        "FP_FileLockedError",
        "FP_MigrationRequired",
        "FP_RuntimeError",
        "FP_ReadOnlyError",
        "FP_WritingSystemError",
        "FP_NullParameterError",
        "FP_ParameterError",
        "FLExProject",
        "FilterTypes",
        "FilterOperations",
        "MediaType",
        "MediaOperations"
      ]
    },
    "discourse": {
      "description": "Operations related to discourse",
      "entities": [
        "ConstChartClauseMarkerOperations",
        "ConstChartMovedTextOperations",
        "ConstChartOperations",
        "ConstChartRowOperations",
        "ConstChartTagOperations",
        "ConstChartWordGroupOperations"
      ]
    },
    "grammar": {
      "description": "Operations related to grammar",
      "entities": [
        "EnvironmentOperations",
        "GramCatOperations",
        "InflectionFeatureOperations",
        "MorphRuleOperations",
        "NaturalClassOperations",
        "PhonemeOperations",
        "PhonologicalRuleOperations",
        "POSOperations"
      ]
    },
    "lexicon": {
      "description": "Operations related to lexicon",
      "entities": [
        "AllomorphOperations",
        "EtymologyOperations",
        "ExampleOperations",
        "LexEntryOperations",
        "LexRefMappingTypes",
        "LexReferenceOperations",
        "LexSenseOperations",
        "PronunciationOperations",
        "ReversalOperations",
        "SemanticDomainOperations",
        "VariantOperations"
      ]
    },
    "lists": {
      "description": "Operations related to lists",
      "entities": [
        "AgentOperations",
        "ConfidenceOperations",
        "OverlayOperations",
        "PossibilityListOperations",
        "PublicationOperations",
        "TranslationTypeOperations"
      ]
    },
    "notebook": {
      "description": "Operations related to notebook",
      "entities": [
        "AnthropologyOperations",
        "DataNotebookOperations",
        "LocationOperations",
        "NoteOperations",
        "PersonOperations"
      ]
    },
    "reversal": {
      "description": "Operations related to reversal",
      "entities": [
        "ReversalIndexEntryOperations",
        "ReversalIndexOperations"
      ]
    },
    "scripture": {
      "description": "Operations related to scripture",
      "entities": [
        "ScrAnnotationsOperations",
        "ScrBookOperations",
        "ScrDraftOperations",
        "ScrNoteOperations",
        "ScrSectionOperations",
        "ScrTxtParaOperations"
      ]
    },
    "system": {
      "description": "Operations related to system",
      "entities": [
        "AnnotationDefOperations",
        "CheckOperations",
        "CustomFieldOperations",
        "ProjectSettingsOperations",
        "WritingSystemOperations"
      ]
    },
    "texts": {
      "description": "Operations related to texts",
      "entities": [
        "DiscourseOperations",
        "ParagraphOperations",
        "SegmentOperations",
        "TextOperations",
        "ApprovalStatusTypes",
        "SpellingStatusStates",
        "WordformOperations"
      ]
    },
    "wordform": {
      "description": "Operations related to wordform",
      "entities": [
        "WfiAnalysisOperations",
        "WfiGlossOperations",
        "WfiMorphBundleOperations",
        "WfiWordformOperations"
      ]
    }
  },
  "lcm_mapping": {
    "BaseOperations.CompareTo": {
      "class": "BaseOperations",
      "method": "CompareTo",
      "lcm_deps": []
    },
    "BaseOperations.GetSyncableProperties": {
      "class": "BaseOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": []
    },
    "BaseOperations.MoveAfter": {
      "class": "BaseOperations",
      "method": "MoveAfter",
      "lcm_deps": []
    },
    "BaseOperations.MoveBefore": {
      "class": "BaseOperations",
      "method": "MoveBefore",
      "lcm_deps": []
    },
    "BaseOperations.MoveDown": {
      "class": "BaseOperations",
      "method": "MoveDown",
      "lcm_deps": []
    },
    "BaseOperations.MoveToIndex": {
      "class": "BaseOperations",
      "method": "MoveToIndex",
      "lcm_deps": []
    },
    "BaseOperations.MoveUp": {
      "class": "BaseOperations",
      "method": "MoveUp",
      "lcm_deps": []
    },
    "BaseOperations.Sort": {
      "class": "BaseOperations",
      "method": "Sort",
      "lcm_deps": []
    },
    "BaseOperations.Swap": {
      "class": "BaseOperations",
      "method": "Swap",
      "lcm_deps": []
    },
    "BaseOperations.__init__": {
      "class": "BaseOperations",
      "method": "__init__",
      "lcm_deps": []
    },
    "FP_ProjectError.__init__": {
      "class": "FP_ProjectError",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FP_FileNotFoundError.__init__": {
      "class": "FP_FileNotFoundError",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FP_FileLockedError.__init__": {
      "class": "FP_FileLockedError",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FP_MigrationRequired.__init__": {
      "class": "FP_MigrationRequired",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FP_RuntimeError.__init__": {
      "class": "FP_RuntimeError",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FP_ReadOnlyError.__init__": {
      "class": "FP_ReadOnlyError",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FP_WritingSystemError.__init__": {
      "class": "FP_WritingSystemError",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FP_NullParameterError.__init__": {
      "class": "FP_NullParameterError",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FP_ParameterError.__init__": {
      "class": "FP_ParameterError",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.BestStr": {
      "class": "FLExProject",
      "method": "BestStr",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.BuildGotoURL": {
      "class": "FLExProject",
      "method": "BuildGotoURL",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.CloseProject": {
      "class": "FLExProject",
      "method": "CloseProject",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetAllAnalysisWSs": {
      "class": "FLExProject",
      "method": "GetAllAnalysisWSs",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetAllSemanticDomains": {
      "class": "FLExProject",
      "method": "GetAllSemanticDomains",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetAllVernacularWSs": {
      "class": "FLExProject",
      "method": "GetAllVernacularWSs",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetAudioPath": {
      "class": "FLExProject",
      "method": "GetAudioPath",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetCustomFieldValue": {
      "class": "FLExProject",
      "method": "GetCustomFieldValue",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetDateLastModified": {
      "class": "FLExProject",
      "method": "GetDateLastModified",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetDefaultAnalysisWS": {
      "class": "FLExProject",
      "method": "GetDefaultAnalysisWS",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetDefaultVernacularWS": {
      "class": "FLExProject",
      "method": "GetDefaultVernacularWS",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetFieldID": {
      "class": "FLExProject",
      "method": "GetFieldID",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetLexicalRelationTypes": {
      "class": "FLExProject",
      "method": "GetLexicalRelationTypes",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetLinkedFilesDir": {
      "class": "FLExProject",
      "method": "GetLinkedFilesDir",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetPartsOfSpeech": {
      "class": "FLExProject",
      "method": "GetPartsOfSpeech",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetPublications": {
      "class": "FLExProject",
      "method": "GetPublications",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.GetWritingSystems": {
      "class": "FLExProject",
      "method": "GetWritingSystems",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.IsAudioWritingSystem": {
      "class": "FLExProject",
      "method": "IsAudioWritingSystem",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAddAllomorph": {
      "class": "FLExProject",
      "method": "LexiconAddAllomorph",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAddComplexForm": {
      "class": "FLExProject",
      "method": "LexiconAddComplexForm",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAddEntry": {
      "class": "FLExProject",
      "method": "LexiconAddEntry",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAddPronunciation": {
      "class": "FLExProject",
      "method": "LexiconAddPronunciation",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAddSense": {
      "class": "FLExProject",
      "method": "LexiconAddSense",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAddTagToField": {
      "class": "FLExProject",
      "method": "LexiconAddTagToField",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAddVariantForm": {
      "class": "FLExProject",
      "method": "LexiconAddVariantForm",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAllAllomorphs": {
      "class": "FLExProject",
      "method": "LexiconAllAllomorphs",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAllEntries": {
      "class": "FLExProject",
      "method": "LexiconAllEntries",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconAllEntriesSorted": {
      "class": "FLExProject",
      "method": "LexiconAllEntriesSorted",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconClearField": {
      "class": "FLExProject",
      "method": "LexiconClearField",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconClearListFieldSingle": {
      "class": "FLExProject",
      "method": "LexiconClearListFieldSingle",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconDeleteObject": {
      "class": "FLExProject",
      "method": "LexiconDeleteObject",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconEntryAnalysesCount": {
      "class": "FLExProject",
      "method": "LexiconEntryAnalysesCount",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconFieldIsAnyStringType": {
      "class": "FLExProject",
      "method": "LexiconFieldIsAnyStringType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconFieldIsMultiType": {
      "class": "FLExProject",
      "method": "LexiconFieldIsMultiType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconFieldIsStringType": {
      "class": "FLExProject",
      "method": "LexiconFieldIsStringType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetAllomorphCustomFields": {
      "class": "FLExProject",
      "method": "LexiconGetAllomorphCustomFields",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetAllomorphForms": {
      "class": "FLExProject",
      "method": "LexiconGetAllomorphForms",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetAlternateForm": {
      "class": "FLExProject",
      "method": "LexiconGetAlternateForm",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetCitationForm": {
      "class": "FLExProject",
      "method": "LexiconGetCitationForm",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetComplexFormType": {
      "class": "FLExProject",
      "method": "LexiconGetComplexFormType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetEntry": {
      "class": "FLExProject",
      "method": "LexiconGetEntry",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetEntryCustomFieldNamed": {
      "class": "FLExProject",
      "method": "LexiconGetEntryCustomFieldNamed",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetEntryCustomFields": {
      "class": "FLExProject",
      "method": "LexiconGetEntryCustomFields",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetExample": {
      "class": "FLExProject",
      "method": "LexiconGetExample",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetExampleCustomFields": {
      "class": "FLExProject",
      "method": "LexiconGetExampleCustomFields",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetExampleTranslation": {
      "class": "FLExProject",
      "method": "LexiconGetExampleTranslation",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetFieldText": {
      "class": "FLExProject",
      "method": "LexiconGetFieldText",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetHeadWord": {
      "class": "FLExProject",
      "method": "LexiconGetHeadWord",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetHeadword": {
      "class": "FLExProject",
      "method": "LexiconGetHeadword",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetLexemeForm": {
      "class": "FLExProject",
      "method": "LexiconGetLexemeForm",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetMorphType": {
      "class": "FLExProject",
      "method": "LexiconGetMorphType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetPronunciation": {
      "class": "FLExProject",
      "method": "LexiconGetPronunciation",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetPronunciations": {
      "class": "FLExProject",
      "method": "LexiconGetPronunciations",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetPublishInCount": {
      "class": "FLExProject",
      "method": "LexiconGetPublishInCount",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetSense": {
      "class": "FLExProject",
      "method": "LexiconGetSense",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetSenseByName": {
      "class": "FLExProject",
      "method": "LexiconGetSenseByName",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetSenseCustomFieldNamed": {
      "class": "FLExProject",
      "method": "LexiconGetSenseCustomFieldNamed",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetSenseCustomFields": {
      "class": "FLExProject",
      "method": "LexiconGetSenseCustomFields",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetSenseDefinition": {
      "class": "FLExProject",
      "method": "LexiconGetSenseDefinition",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetSenseGloss": {
      "class": "FLExProject",
      "method": "LexiconGetSenseGloss",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetSenseNumber": {
      "class": "FLExProject",
      "method": "LexiconGetSenseNumber",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetSensePOS": {
      "class": "FLExProject",
      "method": "LexiconGetSensePOS",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetSenseSemanticDomains": {
      "class": "FLExProject",
      "method": "LexiconGetSenseSemanticDomains",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconGetVariantType": {
      "class": "FLExProject",
      "method": "LexiconGetVariantType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconNumberOfEntries": {
      "class": "FLExProject",
      "method": "LexiconNumberOfEntries",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconNumberOfSenses": {
      "class": "FLExProject",
      "method": "LexiconNumberOfSenses",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSenseAnalysesCount": {
      "class": "FLExProject",
      "method": "LexiconSenseAnalysesCount",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSetComplexFormType": {
      "class": "FLExProject",
      "method": "LexiconSetComplexFormType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSetExample": {
      "class": "FLExProject",
      "method": "LexiconSetExample",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSetFieldInteger": {
      "class": "FLExProject",
      "method": "LexiconSetFieldInteger",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSetFieldText": {
      "class": "FLExProject",
      "method": "LexiconSetFieldText",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSetLexemeForm": {
      "class": "FLExProject",
      "method": "LexiconSetLexemeForm",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSetListFieldMultiple": {
      "class": "FLExProject",
      "method": "LexiconSetListFieldMultiple",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSetListFieldSingle": {
      "class": "FLExProject",
      "method": "LexiconSetListFieldSingle",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSetMorphType": {
      "class": "FLExProject",
      "method": "LexiconSetMorphType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.LexiconSetSenseGloss": {
      "class": "FLExProject",
      "method": "LexiconSetSenseGloss",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ListFieldLookup": {
      "class": "FLExProject",
      "method": "ListFieldLookup",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ListFieldPossibilities": {
      "class": "FLExProject",
      "method": "ListFieldPossibilities",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ListFieldPossibilityList": {
      "class": "FLExProject",
      "method": "ListFieldPossibilityList",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.Object": {
      "class": "FLExProject",
      "method": "Object",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ObjectCountFor": {
      "class": "FLExProject",
      "method": "ObjectCountFor",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ObjectRepository": {
      "class": "FLExProject",
      "method": "ObjectRepository",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ObjectsIn": {
      "class": "FLExProject",
      "method": "ObjectsIn",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.OpenProject": {
      "class": "FLExProject",
      "method": "OpenProject",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ProjectName": {
      "class": "FLExProject",
      "method": "ProjectName",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.PublicationType": {
      "class": "FLExProject",
      "method": "PublicationType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ReversalEntries": {
      "class": "FLExProject",
      "method": "ReversalEntries",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ReversalGetForm": {
      "class": "FLExProject",
      "method": "ReversalGetForm",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ReversalIndex": {
      "class": "FLExProject",
      "method": "ReversalIndex",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.ReversalSetForm": {
      "class": "FLExProject",
      "method": "ReversalSetForm",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.SetAudioPath": {
      "class": "FLExProject",
      "method": "SetAudioPath",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.TextsGetAll": {
      "class": "FLExProject",
      "method": "TextsGetAll",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.TextsNumberOfTexts": {
      "class": "FLExProject",
      "method": "TextsNumberOfTexts",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.UnpackNestedPossibilityList": {
      "class": "FLExProject",
      "method": "UnpackNestedPossibilityList",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.WSHandle": {
      "class": "FLExProject",
      "method": "WSHandle",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "FLExProject.WSUIName": {
      "class": "FLExProject",
      "method": "WSUIName",
      "lcm_deps": [
        "ICmObjectRepository",
        "ILexEntryRepository",
        "ILexEntry",
        "LexEntryTags",
        "ILexSense",
        "LexSenseTags",
        "IWfiWordformRepository",
        "WfiWordformTags",
        "WfiGlossTags",
        "IWfiAnalysisRepository",
        "IWfiAnalysis",
        "WfiAnalysisTags",
        "WfiMorphBundleTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "ILexRefTypeRepository",
        "ICmPossibilityRepository",
        "ICmPossibilityList",
        "ICmSemanticDomain",
        "TextTags",
        "ITextRepository",
        "IStTxtPara",
        "ISegmentRepository",
        "IReversalIndex",
        "IReversalIndexEntry",
        "ReversalIndexEntryTags",
        "IMoMorphType",
        "SpecialWritingSystemCodes",
        "LcmInvalidClassException",
        "LcmInvalidFieldException",
        "LcmFileLockedException",
        "LcmDataMigrationForbiddenException",
        "IUndoStackManager",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "ITsStrBldr",
        "TsStringUtils",
        "WorkerThreadException",
        "ReflectionHelper",
        "ILexEntryRefFactory",
        "FwObjDataTypes",
        "IDataReader"
      ]
    },
    "ConstChartClauseMarkerOperations.AddDependentClause": {
      "class": "ConstChartClauseMarkerOperations",
      "method": "AddDependentClause",
      "lcm_deps": [
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartRow",
        "IConstChartWordGroup"
      ]
    },
    "ConstChartClauseMarkerOperations.Create": {
      "class": "ConstChartClauseMarkerOperations",
      "method": "Create",
      "lcm_deps": [
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartRow",
        "IConstChartWordGroup"
      ]
    },
    "ConstChartClauseMarkerOperations.Delete": {
      "class": "ConstChartClauseMarkerOperations",
      "method": "Delete",
      "lcm_deps": [
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartRow",
        "IConstChartWordGroup"
      ]
    },
    "ConstChartClauseMarkerOperations.Find": {
      "class": "ConstChartClauseMarkerOperations",
      "method": "Find",
      "lcm_deps": [
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartRow",
        "IConstChartWordGroup"
      ]
    },
    "ConstChartClauseMarkerOperations.GetAll": {
      "class": "ConstChartClauseMarkerOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartRow",
        "IConstChartWordGroup"
      ]
    },
    "ConstChartClauseMarkerOperations.GetDependentClauses": {
      "class": "ConstChartClauseMarkerOperations",
      "method": "GetDependentClauses",
      "lcm_deps": [
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartRow",
        "IConstChartWordGroup"
      ]
    },
    "ConstChartClauseMarkerOperations.GetWordGroup": {
      "class": "ConstChartClauseMarkerOperations",
      "method": "GetWordGroup",
      "lcm_deps": [
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartRow",
        "IConstChartWordGroup"
      ]
    },
    "ConstChartClauseMarkerOperations.__init__": {
      "class": "ConstChartClauseMarkerOperations",
      "method": "__init__",
      "lcm_deps": [
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartRow",
        "IConstChartWordGroup"
      ]
    },
    "ConstChartMovedTextOperations.Create": {
      "class": "ConstChartMovedTextOperations",
      "method": "Create",
      "lcm_deps": [
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartWordGroup",
        "IDsConstChart"
      ]
    },
    "ConstChartMovedTextOperations.Delete": {
      "class": "ConstChartMovedTextOperations",
      "method": "Delete",
      "lcm_deps": [
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartWordGroup",
        "IDsConstChart"
      ]
    },
    "ConstChartMovedTextOperations.Find": {
      "class": "ConstChartMovedTextOperations",
      "method": "Find",
      "lcm_deps": [
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartWordGroup",
        "IDsConstChart"
      ]
    },
    "ConstChartMovedTextOperations.GetAll": {
      "class": "ConstChartMovedTextOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartWordGroup",
        "IDsConstChart"
      ]
    },
    "ConstChartMovedTextOperations.GetWordGroup": {
      "class": "ConstChartMovedTextOperations",
      "method": "GetWordGroup",
      "lcm_deps": [
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartWordGroup",
        "IDsConstChart"
      ]
    },
    "ConstChartMovedTextOperations.IsPreposed": {
      "class": "ConstChartMovedTextOperations",
      "method": "IsPreposed",
      "lcm_deps": [
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartWordGroup",
        "IDsConstChart"
      ]
    },
    "ConstChartMovedTextOperations.SetPreposed": {
      "class": "ConstChartMovedTextOperations",
      "method": "SetPreposed",
      "lcm_deps": [
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartWordGroup",
        "IDsConstChart"
      ]
    },
    "ConstChartMovedTextOperations.__init__": {
      "class": "ConstChartMovedTextOperations",
      "method": "__init__",
      "lcm_deps": [
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartWordGroup",
        "IDsConstChart"
      ]
    },
    "ConstChartOperations.Create": {
      "class": "ConstChartOperations",
      "method": "Create",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.Delete": {
      "class": "ConstChartOperations",
      "method": "Delete",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.Find": {
      "class": "ConstChartOperations",
      "method": "Find",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.FindByHvo": {
      "class": "ConstChartOperations",
      "method": "FindByHvo",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.GetAll": {
      "class": "ConstChartOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.GetName": {
      "class": "ConstChartOperations",
      "method": "GetName",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.GetRows": {
      "class": "ConstChartOperations",
      "method": "GetRows",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.GetTemplate": {
      "class": "ConstChartOperations",
      "method": "GetTemplate",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.SetName": {
      "class": "ConstChartOperations",
      "method": "SetName",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.SetTemplate": {
      "class": "ConstChartOperations",
      "method": "SetTemplate",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartOperations.__init__": {
      "class": "ConstChartOperations",
      "method": "__init__",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsConstChartRepository",
        "IDsDiscourse",
        "IConstChartRow",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "IDsDiscourseFactory"
      ]
    },
    "ConstChartRowOperations.Create": {
      "class": "ConstChartRowOperations",
      "method": "Create",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.Delete": {
      "class": "ConstChartRowOperations",
      "method": "Delete",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.Find": {
      "class": "ConstChartRowOperations",
      "method": "Find",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.GetAll": {
      "class": "ConstChartRowOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.GetLabel": {
      "class": "ConstChartRowOperations",
      "method": "GetLabel",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.GetNotes": {
      "class": "ConstChartRowOperations",
      "method": "GetNotes",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.GetWordGroups": {
      "class": "ConstChartRowOperations",
      "method": "GetWordGroups",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.MoveTo": {
      "class": "ConstChartRowOperations",
      "method": "MoveTo",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.SetLabel": {
      "class": "ConstChartRowOperations",
      "method": "SetLabel",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.SetNotes": {
      "class": "ConstChartRowOperations",
      "method": "SetNotes",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartRowOperations.__init__": {
      "class": "ConstChartRowOperations",
      "method": "__init__",
      "lcm_deps": [
        "IConstChartRow",
        "IConstChartRowFactory",
        "IDsConstChart",
        "IConstChartWordGroup",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartTagOperations.Create": {
      "class": "ConstChartTagOperations",
      "method": "Create",
      "lcm_deps": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartTagOperations.Delete": {
      "class": "ConstChartTagOperations",
      "method": "Delete",
      "lcm_deps": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartTagOperations.Find": {
      "class": "ConstChartTagOperations",
      "method": "Find",
      "lcm_deps": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartTagOperations.GetAll": {
      "class": "ConstChartTagOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartTagOperations.GetDescription": {
      "class": "ConstChartTagOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartTagOperations.GetName": {
      "class": "ConstChartTagOperations",
      "method": "GetName",
      "lcm_deps": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartTagOperations.SetDescription": {
      "class": "ConstChartTagOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartTagOperations.SetName": {
      "class": "ConstChartTagOperations",
      "method": "SetName",
      "lcm_deps": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartTagOperations.__init__": {
      "class": "ConstChartTagOperations",
      "method": "__init__",
      "lcm_deps": [
        "IConstChartTag",
        "IConstChartTagFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IDsConstChart",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConstChartWordGroupOperations.Create": {
      "class": "ConstChartWordGroupOperations",
      "method": "Create",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.Delete": {
      "class": "ConstChartWordGroupOperations",
      "method": "Delete",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.Find": {
      "class": "ConstChartWordGroupOperations",
      "method": "Find",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.GetAll": {
      "class": "ConstChartWordGroupOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.GetBeginSegment": {
      "class": "ConstChartWordGroupOperations",
      "method": "GetBeginSegment",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.GetColumn": {
      "class": "ConstChartWordGroupOperations",
      "method": "GetColumn",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.GetEndSegment": {
      "class": "ConstChartWordGroupOperations",
      "method": "GetEndSegment",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.SetBeginSegment": {
      "class": "ConstChartWordGroupOperations",
      "method": "SetBeginSegment",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.SetColumn": {
      "class": "ConstChartWordGroupOperations",
      "method": "SetColumn",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.SetEndSegment": {
      "class": "ConstChartWordGroupOperations",
      "method": "SetEndSegment",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "ConstChartWordGroupOperations.__init__": {
      "class": "ConstChartWordGroupOperations",
      "method": "__init__",
      "lcm_deps": [
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartRow",
        "IAnalysis",
        "ISegment"
      ]
    },
    "EnvironmentOperations.CompareTo": {
      "class": "EnvironmentOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.Create": {
      "class": "EnvironmentOperations",
      "method": "Create",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.Delete": {
      "class": "EnvironmentOperations",
      "method": "Delete",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.Duplicate": {
      "class": "EnvironmentOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.GetAll": {
      "class": "EnvironmentOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.GetLeftContextPattern": {
      "class": "EnvironmentOperations",
      "method": "GetLeftContextPattern",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.GetName": {
      "class": "EnvironmentOperations",
      "method": "GetName",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.GetRightContextPattern": {
      "class": "EnvironmentOperations",
      "method": "GetRightContextPattern",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.GetStringRepresentation": {
      "class": "EnvironmentOperations",
      "method": "GetStringRepresentation",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.GetSyncableProperties": {
      "class": "EnvironmentOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.SetName": {
      "class": "EnvironmentOperations",
      "method": "SetName",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.SetStringRepresentation": {
      "class": "EnvironmentOperations",
      "method": "SetStringRepresentation",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "EnvironmentOperations.__init__": {
      "class": "EnvironmentOperations",
      "method": "__init__",
      "lcm_deps": [
        "IPhEnvironmentFactory",
        "IPhEnvironment",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.CompareTo": {
      "class": "GramCatOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.Create": {
      "class": "GramCatOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.Delete": {
      "class": "GramCatOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.Duplicate": {
      "class": "GramCatOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.GetAll": {
      "class": "GramCatOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.GetName": {
      "class": "GramCatOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.GetParent": {
      "class": "GramCatOperations",
      "method": "GetParent",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.GetSubcategories": {
      "class": "GramCatOperations",
      "method": "GetSubcategories",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.GetSyncableProperties": {
      "class": "GramCatOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.SetName": {
      "class": "GramCatOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "GramCatOperations.__init__": {
      "class": "GramCatOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.CompareTo": {
      "class": "InflectionFeatureOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.FeatureCreate": {
      "class": "InflectionFeatureOperations",
      "method": "FeatureCreate",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.FeatureDelete": {
      "class": "InflectionFeatureOperations",
      "method": "FeatureDelete",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.FeatureGetAll": {
      "class": "InflectionFeatureOperations",
      "method": "FeatureGetAll",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.FeatureGetValues": {
      "class": "InflectionFeatureOperations",
      "method": "FeatureGetValues",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.FeatureStructureCreate": {
      "class": "InflectionFeatureOperations",
      "method": "FeatureStructureCreate",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.FeatureStructureDelete": {
      "class": "InflectionFeatureOperations",
      "method": "FeatureStructureDelete",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.FeatureStructureGetAll": {
      "class": "InflectionFeatureOperations",
      "method": "FeatureStructureGetAll",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.GetFeatureConstraints": {
      "class": "InflectionFeatureOperations",
      "method": "GetFeatureConstraints",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.GetFeatures": {
      "class": "InflectionFeatureOperations",
      "method": "GetFeatures",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.GetSyncableProperties": {
      "class": "InflectionFeatureOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.GetTypes": {
      "class": "InflectionFeatureOperations",
      "method": "GetTypes",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.InflectionClassCreate": {
      "class": "InflectionFeatureOperations",
      "method": "InflectionClassCreate",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.InflectionClassDelete": {
      "class": "InflectionFeatureOperations",
      "method": "InflectionClassDelete",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.InflectionClassGetAll": {
      "class": "InflectionFeatureOperations",
      "method": "InflectionClassGetAll",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.InflectionClassGetName": {
      "class": "InflectionFeatureOperations",
      "method": "InflectionClassGetName",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.InflectionClassSetName": {
      "class": "InflectionFeatureOperations",
      "method": "InflectionClassSetName",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "InflectionFeatureOperations.__init__": {
      "class": "InflectionFeatureOperations",
      "method": "__init__",
      "lcm_deps": [
        "IMoInflClass",
        "IMoInflClassFactory",
        "IFsFeatStruc",
        "IFsFeatStrucFactory",
        "IFsFeatDefn",
        "IFsComplexFeature",
        "IFsComplexFeatureFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MorphRuleOperations.CompareTo": {
      "class": "MorphRuleOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.Create": {
      "class": "MorphRuleOperations",
      "method": "Create",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.Delete": {
      "class": "MorphRuleOperations",
      "method": "Delete",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.Duplicate": {
      "class": "MorphRuleOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.GetAll": {
      "class": "MorphRuleOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.GetDescription": {
      "class": "MorphRuleOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.GetName": {
      "class": "MorphRuleOperations",
      "method": "GetName",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.GetStratum": {
      "class": "MorphRuleOperations",
      "method": "GetStratum",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.GetSyncableProperties": {
      "class": "MorphRuleOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.IsActive": {
      "class": "MorphRuleOperations",
      "method": "IsActive",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.SetActive": {
      "class": "MorphRuleOperations",
      "method": "SetActive",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.SetDescription": {
      "class": "MorphRuleOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.SetName": {
      "class": "MorphRuleOperations",
      "method": "SetName",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.SetStratum": {
      "class": "MorphRuleOperations",
      "method": "SetStratum",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "MorphRuleOperations.__init__": {
      "class": "MorphRuleOperations",
      "method": "__init__",
      "lcm_deps": [
        "ITsString",
        "TsStringUtils",
        "IMoAffixProcessFactory"
      ]
    },
    "NaturalClassOperations.AddPhoneme": {
      "class": "NaturalClassOperations",
      "method": "AddPhoneme",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.CompareTo": {
      "class": "NaturalClassOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.Create": {
      "class": "NaturalClassOperations",
      "method": "Create",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.Delete": {
      "class": "NaturalClassOperations",
      "method": "Delete",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.Duplicate": {
      "class": "NaturalClassOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.GetAbbreviation": {
      "class": "NaturalClassOperations",
      "method": "GetAbbreviation",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.GetAll": {
      "class": "NaturalClassOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.GetName": {
      "class": "NaturalClassOperations",
      "method": "GetName",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.GetPhonemes": {
      "class": "NaturalClassOperations",
      "method": "GetPhonemes",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.GetSyncableProperties": {
      "class": "NaturalClassOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.RemovePhoneme": {
      "class": "NaturalClassOperations",
      "method": "RemovePhoneme",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.SetName": {
      "class": "NaturalClassOperations",
      "method": "SetName",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NaturalClassOperations.__init__": {
      "class": "NaturalClassOperations",
      "method": "__init__",
      "lcm_deps": [
        "IPhNaturalClass",
        "IPhNCSegments",
        "IPhNCSegmentsFactory",
        "IPhPhoneme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.AddCode": {
      "class": "PhonemeOperations",
      "method": "AddCode",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.CompareTo": {
      "class": "PhonemeOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.Create": {
      "class": "PhonemeOperations",
      "method": "Create",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.Delete": {
      "class": "PhonemeOperations",
      "method": "Delete",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.Duplicate": {
      "class": "PhonemeOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.Exists": {
      "class": "PhonemeOperations",
      "method": "Exists",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.Find": {
      "class": "PhonemeOperations",
      "method": "Find",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.GetAll": {
      "class": "PhonemeOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.GetBasicIPASymbol": {
      "class": "PhonemeOperations",
      "method": "GetBasicIPASymbol",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.GetCodes": {
      "class": "PhonemeOperations",
      "method": "GetCodes",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.GetDescription": {
      "class": "PhonemeOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.GetFeatures": {
      "class": "PhonemeOperations",
      "method": "GetFeatures",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.GetRepresentation": {
      "class": "PhonemeOperations",
      "method": "GetRepresentation",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.GetSyncableProperties": {
      "class": "PhonemeOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.IsConsonant": {
      "class": "PhonemeOperations",
      "method": "IsConsonant",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.IsVowel": {
      "class": "PhonemeOperations",
      "method": "IsVowel",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.RemoveCode": {
      "class": "PhonemeOperations",
      "method": "RemoveCode",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.SetDescription": {
      "class": "PhonemeOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.SetRepresentation": {
      "class": "PhonemeOperations",
      "method": "SetRepresentation",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonemeOperations.__init__": {
      "class": "PhonemeOperations",
      "method": "__init__",
      "lcm_deps": [
        "IPhPhoneme",
        "IPhPhonemeFactory",
        "IPhCode",
        "IPhCodeFactory",
        "IFsFeatStruc",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.AddInputSegment": {
      "class": "PhonologicalRuleOperations",
      "method": "AddInputSegment",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.AddOutputSegment": {
      "class": "PhonologicalRuleOperations",
      "method": "AddOutputSegment",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.CompareTo": {
      "class": "PhonologicalRuleOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.Create": {
      "class": "PhonologicalRuleOperations",
      "method": "Create",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.Delete": {
      "class": "PhonologicalRuleOperations",
      "method": "Delete",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.Duplicate": {
      "class": "PhonologicalRuleOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.Exists": {
      "class": "PhonologicalRuleOperations",
      "method": "Exists",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.Find": {
      "class": "PhonologicalRuleOperations",
      "method": "Find",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.GetAll": {
      "class": "PhonologicalRuleOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.GetDescription": {
      "class": "PhonologicalRuleOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.GetDirection": {
      "class": "PhonologicalRuleOperations",
      "method": "GetDirection",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.GetName": {
      "class": "PhonologicalRuleOperations",
      "method": "GetName",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.GetStratum": {
      "class": "PhonologicalRuleOperations",
      "method": "GetStratum",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.GetSyncableProperties": {
      "class": "PhonologicalRuleOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.SetDescription": {
      "class": "PhonologicalRuleOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.SetDirection": {
      "class": "PhonologicalRuleOperations",
      "method": "SetDirection",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.SetLeftContext": {
      "class": "PhonologicalRuleOperations",
      "method": "SetLeftContext",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.SetName": {
      "class": "PhonologicalRuleOperations",
      "method": "SetName",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.SetRightContext": {
      "class": "PhonologicalRuleOperations",
      "method": "SetRightContext",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.SetStratum": {
      "class": "PhonologicalRuleOperations",
      "method": "SetStratum",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PhonologicalRuleOperations.__init__": {
      "class": "PhonologicalRuleOperations",
      "method": "__init__",
      "lcm_deps": [
        "IPhRegularRuleFactory",
        "IPhSegRuleRHSFactory",
        "IPhSegmentRuleFactory",
        "IPhSimpleContextNCFactory",
        "IPhSimpleContextSegFactory",
        "IPhIterationContextFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.AddSubcategory": {
      "class": "POSOperations",
      "method": "AddSubcategory",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.CompareTo": {
      "class": "POSOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.Create": {
      "class": "POSOperations",
      "method": "Create",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.Delete": {
      "class": "POSOperations",
      "method": "Delete",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.Duplicate": {
      "class": "POSOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.Exists": {
      "class": "POSOperations",
      "method": "Exists",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.Find": {
      "class": "POSOperations",
      "method": "Find",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.GetAbbreviation": {
      "class": "POSOperations",
      "method": "GetAbbreviation",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.GetAffixSlots": {
      "class": "POSOperations",
      "method": "GetAffixSlots",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.GetAll": {
      "class": "POSOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.GetCatalogSourceId": {
      "class": "POSOperations",
      "method": "GetCatalogSourceId",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.GetEntryCount": {
      "class": "POSOperations",
      "method": "GetEntryCount",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.GetInflectionClasses": {
      "class": "POSOperations",
      "method": "GetInflectionClasses",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.GetName": {
      "class": "POSOperations",
      "method": "GetName",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.GetSubcategories": {
      "class": "POSOperations",
      "method": "GetSubcategories",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.GetSyncableProperties": {
      "class": "POSOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.RemoveSubcategory": {
      "class": "POSOperations",
      "method": "RemoveSubcategory",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.SetAbbreviation": {
      "class": "POSOperations",
      "method": "SetAbbreviation",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.SetName": {
      "class": "POSOperations",
      "method": "SetName",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "POSOperations.__init__": {
      "class": "POSOperations",
      "method": "__init__",
      "lcm_deps": [
        "IPartOfSpeechFactory",
        "IPartOfSpeech",
        "ILexEntryRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AllomorphOperations.AddPhoneEnv": {
      "class": "AllomorphOperations",
      "method": "AddPhoneEnv",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.CompareTo": {
      "class": "AllomorphOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.Create": {
      "class": "AllomorphOperations",
      "method": "Create",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.Delete": {
      "class": "AllomorphOperations",
      "method": "Delete",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.Duplicate": {
      "class": "AllomorphOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.GetAll": {
      "class": "AllomorphOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.GetForm": {
      "class": "AllomorphOperations",
      "method": "GetForm",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.GetFormAudio": {
      "class": "AllomorphOperations",
      "method": "GetFormAudio",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.GetMorphType": {
      "class": "AllomorphOperations",
      "method": "GetMorphType",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.GetPhoneEnv": {
      "class": "AllomorphOperations",
      "method": "GetPhoneEnv",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.GetSyncableProperties": {
      "class": "AllomorphOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.RemovePhoneEnv": {
      "class": "AllomorphOperations",
      "method": "RemovePhoneEnv",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.SetForm": {
      "class": "AllomorphOperations",
      "method": "SetForm",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.SetFormAudio": {
      "class": "AllomorphOperations",
      "method": "SetFormAudio",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.SetMorphType": {
      "class": "AllomorphOperations",
      "method": "SetMorphType",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "AllomorphOperations.__init__": {
      "class": "AllomorphOperations",
      "method": "__init__",
      "lcm_deps": [
        "IMoForm",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "ILexEntry",
        "IPhEnvironment",
        "MoMorphTypeTags",
        "ITsString",
        "TsStringUtils",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoStemAllomorphFactory"
      ]
    },
    "EtymologyOperations.CompareTo": {
      "class": "EtymologyOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.Create": {
      "class": "EtymologyOperations",
      "method": "Create",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.Delete": {
      "class": "EtymologyOperations",
      "method": "Delete",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.Duplicate": {
      "class": "EtymologyOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetAll": {
      "class": "EtymologyOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetBibliography": {
      "class": "EtymologyOperations",
      "method": "GetBibliography",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetComment": {
      "class": "EtymologyOperations",
      "method": "GetComment",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetForm": {
      "class": "EtymologyOperations",
      "method": "GetForm",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetGloss": {
      "class": "EtymologyOperations",
      "method": "GetGloss",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetGuid": {
      "class": "EtymologyOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetLanguage": {
      "class": "EtymologyOperations",
      "method": "GetLanguage",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetOwningEntry": {
      "class": "EtymologyOperations",
      "method": "GetOwningEntry",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetSource": {
      "class": "EtymologyOperations",
      "method": "GetSource",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.GetSyncableProperties": {
      "class": "EtymologyOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.Reorder": {
      "class": "EtymologyOperations",
      "method": "Reorder",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.SetBibliography": {
      "class": "EtymologyOperations",
      "method": "SetBibliography",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.SetComment": {
      "class": "EtymologyOperations",
      "method": "SetComment",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.SetForm": {
      "class": "EtymologyOperations",
      "method": "SetForm",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.SetGloss": {
      "class": "EtymologyOperations",
      "method": "SetGloss",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.SetLanguage": {
      "class": "EtymologyOperations",
      "method": "SetLanguage",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.SetSource": {
      "class": "EtymologyOperations",
      "method": "SetSource",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "EtymologyOperations.__init__": {
      "class": "EtymologyOperations",
      "method": "__init__",
      "lcm_deps": [
        "ILexEtymology",
        "ILexEtymologyFactory",
        "ILexEntry",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.AddDoNotPublishIn": {
      "class": "ExampleOperations",
      "method": "AddDoNotPublishIn",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.AddMediaFile": {
      "class": "ExampleOperations",
      "method": "AddMediaFile",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.AddTranslation": {
      "class": "ExampleOperations",
      "method": "AddTranslation",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.CompareTo": {
      "class": "ExampleOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.Create": {
      "class": "ExampleOperations",
      "method": "Create",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.Delete": {
      "class": "ExampleOperations",
      "method": "Delete",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.Duplicate": {
      "class": "ExampleOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetAll": {
      "class": "ExampleOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetDoNotPublishIn": {
      "class": "ExampleOperations",
      "method": "GetDoNotPublishIn",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetExample": {
      "class": "ExampleOperations",
      "method": "GetExample",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetGuid": {
      "class": "ExampleOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetLiteralTranslation": {
      "class": "ExampleOperations",
      "method": "GetLiteralTranslation",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetMediaCount": {
      "class": "ExampleOperations",
      "method": "GetMediaCount",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetMediaFiles": {
      "class": "ExampleOperations",
      "method": "GetMediaFiles",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetOwningSense": {
      "class": "ExampleOperations",
      "method": "GetOwningSense",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetReference": {
      "class": "ExampleOperations",
      "method": "GetReference",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetSyncableProperties": {
      "class": "ExampleOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetTranslation": {
      "class": "ExampleOperations",
      "method": "GetTranslation",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.GetTranslations": {
      "class": "ExampleOperations",
      "method": "GetTranslations",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.MoveMediaFile": {
      "class": "ExampleOperations",
      "method": "MoveMediaFile",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.RemoveDoNotPublishIn": {
      "class": "ExampleOperations",
      "method": "RemoveDoNotPublishIn",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.RemoveMediaFile": {
      "class": "ExampleOperations",
      "method": "RemoveMediaFile",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.RemoveTranslation": {
      "class": "ExampleOperations",
      "method": "RemoveTranslation",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.Reorder": {
      "class": "ExampleOperations",
      "method": "Reorder",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.SetExample": {
      "class": "ExampleOperations",
      "method": "SetExample",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.SetLiteralTranslation": {
      "class": "ExampleOperations",
      "method": "SetLiteralTranslation",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.SetReference": {
      "class": "ExampleOperations",
      "method": "SetReference",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.SetTranslation": {
      "class": "ExampleOperations",
      "method": "SetTranslation",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "ExampleOperations.__init__": {
      "class": "ExampleOperations",
      "method": "__init__",
      "lcm_deps": [
        "ILexExampleSentence",
        "ILexExampleSentenceFactory",
        "ILexSense",
        "ICmTranslation",
        "ICmTranslationFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "ITsString"
      ]
    },
    "LexEntryOperations.AddComplexFormComponent": {
      "class": "LexEntryOperations",
      "method": "AddComplexFormComponent",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.AddDoNotPublishIn": {
      "class": "LexEntryOperations",
      "method": "AddDoNotPublishIn",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.AddDoNotShowMainEntryIn": {
      "class": "LexEntryOperations",
      "method": "AddDoNotShowMainEntryIn",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.AddSense": {
      "class": "LexEntryOperations",
      "method": "AddSense",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.CompareTo": {
      "class": "LexEntryOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.Create": {
      "class": "LexEntryOperations",
      "method": "Create",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.Delete": {
      "class": "LexEntryOperations",
      "method": "Delete",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.Duplicate": {
      "class": "LexEntryOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.Exists": {
      "class": "LexEntryOperations",
      "method": "Exists",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.Find": {
      "class": "LexEntryOperations",
      "method": "Find",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetAll": {
      "class": "LexEntryOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetAllSenses": {
      "class": "LexEntryOperations",
      "method": "GetAllSenses",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetAvailableMorphTypes": {
      "class": "LexEntryOperations",
      "method": "GetAvailableMorphTypes",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetBestVernacularAlternative": {
      "class": "LexEntryOperations",
      "method": "GetBestVernacularAlternative",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetBibliography": {
      "class": "LexEntryOperations",
      "method": "GetBibliography",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetCitationForm": {
      "class": "LexEntryOperations",
      "method": "GetCitationForm",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetComment": {
      "class": "LexEntryOperations",
      "method": "GetComment",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetComplexFormComponents": {
      "class": "LexEntryOperations",
      "method": "GetComplexFormComponents",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetComplexFormsNotSubentries": {
      "class": "LexEntryOperations",
      "method": "GetComplexFormsNotSubentries",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetDateCreated": {
      "class": "LexEntryOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetDateModified": {
      "class": "LexEntryOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetDoNotPublishIn": {
      "class": "LexEntryOperations",
      "method": "GetDoNotPublishIn",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetDoNotShowMainEntryIn": {
      "class": "LexEntryOperations",
      "method": "GetDoNotShowMainEntryIn",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetDoNotUseForParsing": {
      "class": "LexEntryOperations",
      "method": "GetDoNotUseForParsing",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetExcludeAsHeadword": {
      "class": "LexEntryOperations",
      "method": "GetExcludeAsHeadword",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetGuid": {
      "class": "LexEntryOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetHeadword": {
      "class": "LexEntryOperations",
      "method": "GetHeadword",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetHomographNumber": {
      "class": "LexEntryOperations",
      "method": "GetHomographNumber",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetImportResidue": {
      "class": "LexEntryOperations",
      "method": "GetImportResidue",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetLIFTid": {
      "class": "LexEntryOperations",
      "method": "GetLIFTid",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetLexemeForm": {
      "class": "LexEntryOperations",
      "method": "GetLexemeForm",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetLiteralMeaning": {
      "class": "LexEntryOperations",
      "method": "GetLiteralMeaning",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetLongName": {
      "class": "LexEntryOperations",
      "method": "GetLongName",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetMinimalLexReferences": {
      "class": "LexEntryOperations",
      "method": "GetMinimalLexReferences",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetMorphType": {
      "class": "LexEntryOperations",
      "method": "GetMorphType",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetRestrictions": {
      "class": "LexEntryOperations",
      "method": "GetRestrictions",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetSenseCount": {
      "class": "LexEntryOperations",
      "method": "GetSenseCount",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetSenses": {
      "class": "LexEntryOperations",
      "method": "GetSenses",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetShortName": {
      "class": "LexEntryOperations",
      "method": "GetShortName",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetSummaryDefinition": {
      "class": "LexEntryOperations",
      "method": "GetSummaryDefinition",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetSyncableProperties": {
      "class": "LexEntryOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.GetVisibleComplexFormBackRefs": {
      "class": "LexEntryOperations",
      "method": "GetVisibleComplexFormBackRefs",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.MergeObject": {
      "class": "LexEntryOperations",
      "method": "MergeObject",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.RemoveComplexFormComponent": {
      "class": "LexEntryOperations",
      "method": "RemoveComplexFormComponent",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.RemoveDoNotPublishIn": {
      "class": "LexEntryOperations",
      "method": "RemoveDoNotPublishIn",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.RemoveDoNotShowMainEntryIn": {
      "class": "LexEntryOperations",
      "method": "RemoveDoNotShowMainEntryIn",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetBibliography": {
      "class": "LexEntryOperations",
      "method": "SetBibliography",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetCitationForm": {
      "class": "LexEntryOperations",
      "method": "SetCitationForm",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetComment": {
      "class": "LexEntryOperations",
      "method": "SetComment",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetDoNotUseForParsing": {
      "class": "LexEntryOperations",
      "method": "SetDoNotUseForParsing",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetExcludeAsHeadword": {
      "class": "LexEntryOperations",
      "method": "SetExcludeAsHeadword",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetHeadword": {
      "class": "LexEntryOperations",
      "method": "SetHeadword",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetHomographNumber": {
      "class": "LexEntryOperations",
      "method": "SetHomographNumber",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetImportResidue": {
      "class": "LexEntryOperations",
      "method": "SetImportResidue",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetLexemeForm": {
      "class": "LexEntryOperations",
      "method": "SetLexemeForm",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetLiteralMeaning": {
      "class": "LexEntryOperations",
      "method": "SetLiteralMeaning",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetMorphType": {
      "class": "LexEntryOperations",
      "method": "SetMorphType",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetRestrictions": {
      "class": "LexEntryOperations",
      "method": "SetRestrictions",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.SetSummaryDefinition": {
      "class": "LexEntryOperations",
      "method": "SetSummaryDefinition",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.ValidateMorphType": {
      "class": "LexEntryOperations",
      "method": "ValidateMorphType",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexEntryOperations.__init__": {
      "class": "LexEntryOperations",
      "method": "__init__",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryFactory",
        "ILexEntryRepository",
        "ILexSense",
        "ILexSenseFactory",
        "IMoMorphType",
        "IMoStemAllomorphFactory",
        "IMoAffixAllomorphFactory",
        "IMoForm",
        "MoMorphTypeTags",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "LexEntryRefTags",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LexReferenceOperations.AddTarget": {
      "class": "LexReferenceOperations",
      "method": "AddTarget",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.CompareTo": {
      "class": "LexReferenceOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.Create": {
      "class": "LexReferenceOperations",
      "method": "Create",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.CreateType": {
      "class": "LexReferenceOperations",
      "method": "CreateType",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.Delete": {
      "class": "LexReferenceOperations",
      "method": "Delete",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.DeleteType": {
      "class": "LexReferenceOperations",
      "method": "DeleteType",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.FindType": {
      "class": "LexReferenceOperations",
      "method": "FindType",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetAll": {
      "class": "LexReferenceOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetAllTypes": {
      "class": "LexReferenceOperations",
      "method": "GetAllTypes",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetComplexFormEntries": {
      "class": "LexReferenceOperations",
      "method": "GetComplexFormEntries",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetComponentEntries": {
      "class": "LexReferenceOperations",
      "method": "GetComponentEntries",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetMappingType": {
      "class": "LexReferenceOperations",
      "method": "GetMappingType",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetReferencesOfType": {
      "class": "LexReferenceOperations",
      "method": "GetReferencesOfType",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetSyncableProperties": {
      "class": "LexReferenceOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetTargets": {
      "class": "LexReferenceOperations",
      "method": "GetTargets",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetType": {
      "class": "LexReferenceOperations",
      "method": "GetType",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetTypeName": {
      "class": "LexReferenceOperations",
      "method": "GetTypeName",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.GetTypeReverseName": {
      "class": "LexReferenceOperations",
      "method": "GetTypeReverseName",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.RemoveTarget": {
      "class": "LexReferenceOperations",
      "method": "RemoveTarget",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.SetTypeName": {
      "class": "LexReferenceOperations",
      "method": "SetTypeName",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.SetTypeReverseName": {
      "class": "LexReferenceOperations",
      "method": "SetTypeReverseName",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.ShowComplexFormsIn": {
      "class": "LexReferenceOperations",
      "method": "ShowComplexFormsIn",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexReferenceOperations.__init__": {
      "class": "LexReferenceOperations",
      "method": "__init__",
      "lcm_deps": [
        "ILexReference",
        "ILexReferenceFactory",
        "ILexRefType",
        "ILexRefTypeFactory",
        "ILexRefTypeRepository",
        "ILexEntry",
        "ILexSense",
        "LexRefTypeTags",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ITsString",
        "ITsString"
      ]
    },
    "LexSenseOperations.AddAnthroCode": {
      "class": "LexSenseOperations",
      "method": "AddAnthroCode",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.AddDomainType": {
      "class": "LexSenseOperations",
      "method": "AddDomainType",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.AddExample": {
      "class": "LexSenseOperations",
      "method": "AddExample",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.AddPicture": {
      "class": "LexSenseOperations",
      "method": "AddPicture",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.AddSemanticDomain": {
      "class": "LexSenseOperations",
      "method": "AddSemanticDomain",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.AddUsageType": {
      "class": "LexSenseOperations",
      "method": "AddUsageType",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.CompareTo": {
      "class": "LexSenseOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.Create": {
      "class": "LexSenseOperations",
      "method": "Create",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.CreateSubsense": {
      "class": "LexSenseOperations",
      "method": "CreateSubsense",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.Delete": {
      "class": "LexSenseOperations",
      "method": "Delete",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.Duplicate": {
      "class": "LexSenseOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetAll": {
      "class": "LexSenseOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetAllSenses": {
      "class": "LexSenseOperations",
      "method": "GetAllSenses",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetAnalysesCount": {
      "class": "LexSenseOperations",
      "method": "GetAnalysesCount",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetAnthroCodes": {
      "class": "LexSenseOperations",
      "method": "GetAnthroCodes",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetAnthroNote": {
      "class": "LexSenseOperations",
      "method": "GetAnthroNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetBibliography": {
      "class": "LexSenseOperations",
      "method": "GetBibliography",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetCaption": {
      "class": "LexSenseOperations",
      "method": "GetCaption",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetComplexFormsNotSubentries": {
      "class": "LexSenseOperations",
      "method": "GetComplexFormsNotSubentries",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetDefinition": {
      "class": "LexSenseOperations",
      "method": "GetDefinition",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetDefinitionOrGloss": {
      "class": "LexSenseOperations",
      "method": "GetDefinitionOrGloss",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetDiscourseNote": {
      "class": "LexSenseOperations",
      "method": "GetDiscourseNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetDomainTypes": {
      "class": "LexSenseOperations",
      "method": "GetDomainTypes",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetEncyclopedicInfo": {
      "class": "LexSenseOperations",
      "method": "GetEncyclopedicInfo",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetExampleCount": {
      "class": "LexSenseOperations",
      "method": "GetExampleCount",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetExamples": {
      "class": "LexSenseOperations",
      "method": "GetExamples",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetGeneralNote": {
      "class": "LexSenseOperations",
      "method": "GetGeneralNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetGloss": {
      "class": "LexSenseOperations",
      "method": "GetGloss",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetGrammarNote": {
      "class": "LexSenseOperations",
      "method": "GetGrammarNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetGrammaticalInfo": {
      "class": "LexSenseOperations",
      "method": "GetGrammaticalInfo",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetGuid": {
      "class": "LexSenseOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetImportResidue": {
      "class": "LexSenseOperations",
      "method": "GetImportResidue",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetMinimalLexReferences": {
      "class": "LexSenseOperations",
      "method": "GetMinimalLexReferences",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetOwningEntry": {
      "class": "LexSenseOperations",
      "method": "GetOwningEntry",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetParentSense": {
      "class": "LexSenseOperations",
      "method": "GetParentSense",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetPartOfSpeech": {
      "class": "LexSenseOperations",
      "method": "GetPartOfSpeech",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetPhonologyNote": {
      "class": "LexSenseOperations",
      "method": "GetPhonologyNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetPictureCount": {
      "class": "LexSenseOperations",
      "method": "GetPictureCount",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetPictures": {
      "class": "LexSenseOperations",
      "method": "GetPictures",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetRestrictions": {
      "class": "LexSenseOperations",
      "method": "GetRestrictions",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetReversalCount": {
      "class": "LexSenseOperations",
      "method": "GetReversalCount",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetReversalEntries": {
      "class": "LexSenseOperations",
      "method": "GetReversalEntries",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetScientificName": {
      "class": "LexSenseOperations",
      "method": "GetScientificName",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetSemanticDomains": {
      "class": "LexSenseOperations",
      "method": "GetSemanticDomains",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetSemanticsNote": {
      "class": "LexSenseOperations",
      "method": "GetSemanticsNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetSenseNumber": {
      "class": "LexSenseOperations",
      "method": "GetSenseNumber",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetSenseType": {
      "class": "LexSenseOperations",
      "method": "GetSenseType",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetSocioLinguisticsNote": {
      "class": "LexSenseOperations",
      "method": "GetSocioLinguisticsNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetSource": {
      "class": "LexSenseOperations",
      "method": "GetSource",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetStatus": {
      "class": "LexSenseOperations",
      "method": "GetStatus",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetSubsenses": {
      "class": "LexSenseOperations",
      "method": "GetSubsenses",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetSyncableProperties": {
      "class": "LexSenseOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetUsageTypes": {
      "class": "LexSenseOperations",
      "method": "GetUsageTypes",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.GetVisibleComplexFormBackRefs": {
      "class": "LexSenseOperations",
      "method": "GetVisibleComplexFormBackRefs",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.MergeObject": {
      "class": "LexSenseOperations",
      "method": "MergeObject",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.MovePicture": {
      "class": "LexSenseOperations",
      "method": "MovePicture",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.RemoveAnthroCode": {
      "class": "LexSenseOperations",
      "method": "RemoveAnthroCode",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.RemoveDomainType": {
      "class": "LexSenseOperations",
      "method": "RemoveDomainType",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.RemovePicture": {
      "class": "LexSenseOperations",
      "method": "RemovePicture",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.RemoveSemanticDomain": {
      "class": "LexSenseOperations",
      "method": "RemoveSemanticDomain",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.RemoveUsageType": {
      "class": "LexSenseOperations",
      "method": "RemoveUsageType",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.RenamePicture": {
      "class": "LexSenseOperations",
      "method": "RenamePicture",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.Reorder": {
      "class": "LexSenseOperations",
      "method": "Reorder",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetAnthroNote": {
      "class": "LexSenseOperations",
      "method": "SetAnthroNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetBibliography": {
      "class": "LexSenseOperations",
      "method": "SetBibliography",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetCaption": {
      "class": "LexSenseOperations",
      "method": "SetCaption",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetDefinition": {
      "class": "LexSenseOperations",
      "method": "SetDefinition",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetDiscourseNote": {
      "class": "LexSenseOperations",
      "method": "SetDiscourseNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetEncyclopedicInfo": {
      "class": "LexSenseOperations",
      "method": "SetEncyclopedicInfo",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetGeneralNote": {
      "class": "LexSenseOperations",
      "method": "SetGeneralNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetGloss": {
      "class": "LexSenseOperations",
      "method": "SetGloss",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetGrammarNote": {
      "class": "LexSenseOperations",
      "method": "SetGrammarNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetGrammaticalInfo": {
      "class": "LexSenseOperations",
      "method": "SetGrammaticalInfo",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetImportResidue": {
      "class": "LexSenseOperations",
      "method": "SetImportResidue",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetPartOfSpeech": {
      "class": "LexSenseOperations",
      "method": "SetPartOfSpeech",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetPhonologyNote": {
      "class": "LexSenseOperations",
      "method": "SetPhonologyNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetRestrictions": {
      "class": "LexSenseOperations",
      "method": "SetRestrictions",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetScientificName": {
      "class": "LexSenseOperations",
      "method": "SetScientificName",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetSemanticsNote": {
      "class": "LexSenseOperations",
      "method": "SetSemanticsNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetSenseType": {
      "class": "LexSenseOperations",
      "method": "SetSenseType",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetSocioLinguisticsNote": {
      "class": "LexSenseOperations",
      "method": "SetSocioLinguisticsNote",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetSource": {
      "class": "LexSenseOperations",
      "method": "SetSource",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.SetStatus": {
      "class": "LexSenseOperations",
      "method": "SetStatus",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "LexSenseOperations.__init__": {
      "class": "LexSenseOperations",
      "method": "__init__",
      "lcm_deps": [
        "ILexSense",
        "ILexSenseFactory",
        "ILexEntry",
        "ILexExampleSentenceFactory",
        "ICmSemanticDomain",
        "ICmPicture",
        "ICmPictureFactory",
        "IReversalIndexEntry",
        "ITsString",
        "TsStringUtils",
        "ReflectionHelper",
        "ITsString",
        "TsStringUtils",
        "ITsString",
        "TsStringUtils",
        "IMoStemMsaFactory",
        "ICmPictureFactory",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "ITsString",
        "IMoStemMsaFactory"
      ]
    },
    "PronunciationOperations.AddMediaFile": {
      "class": "PronunciationOperations",
      "method": "AddMediaFile",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.CompareTo": {
      "class": "PronunciationOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.Create": {
      "class": "PronunciationOperations",
      "method": "Create",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.Delete": {
      "class": "PronunciationOperations",
      "method": "Delete",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.Duplicate": {
      "class": "PronunciationOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.GetAll": {
      "class": "PronunciationOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.GetForm": {
      "class": "PronunciationOperations",
      "method": "GetForm",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.GetGuid": {
      "class": "PronunciationOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.GetLocation": {
      "class": "PronunciationOperations",
      "method": "GetLocation",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.GetMediaCount": {
      "class": "PronunciationOperations",
      "method": "GetMediaCount",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.GetMediaFiles": {
      "class": "PronunciationOperations",
      "method": "GetMediaFiles",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.GetOwningEntry": {
      "class": "PronunciationOperations",
      "method": "GetOwningEntry",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.GetSyncableProperties": {
      "class": "PronunciationOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.MoveMediaFile": {
      "class": "PronunciationOperations",
      "method": "MoveMediaFile",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.RemoveMediaFile": {
      "class": "PronunciationOperations",
      "method": "RemoveMediaFile",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.Reorder": {
      "class": "PronunciationOperations",
      "method": "Reorder",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.SetForm": {
      "class": "PronunciationOperations",
      "method": "SetForm",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.SetLocation": {
      "class": "PronunciationOperations",
      "method": "SetLocation",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "PronunciationOperations.__init__": {
      "class": "PronunciationOperations",
      "method": "__init__",
      "lcm_deps": [
        "ILexEntry",
        "ILexPronunciation",
        "ILexPronunciationFactory",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils",
        "ITsString"
      ]
    },
    "ReversalOperations.AddSense": {
      "class": "ReversalOperations",
      "method": "AddSense",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.CompareTo": {
      "class": "ReversalOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.Create": {
      "class": "ReversalOperations",
      "method": "Create",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.CreateSubentry": {
      "class": "ReversalOperations",
      "method": "CreateSubentry",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.Delete": {
      "class": "ReversalOperations",
      "method": "Delete",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.Duplicate": {
      "class": "ReversalOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.Exists": {
      "class": "ReversalOperations",
      "method": "Exists",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.Find": {
      "class": "ReversalOperations",
      "method": "Find",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.FindIndex": {
      "class": "ReversalOperations",
      "method": "FindIndex",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetAll": {
      "class": "ReversalOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetAllIndexes": {
      "class": "ReversalOperations",
      "method": "GetAllIndexes",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetForm": {
      "class": "ReversalOperations",
      "method": "GetForm",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetIndex": {
      "class": "ReversalOperations",
      "method": "GetIndex",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetParentEntry": {
      "class": "ReversalOperations",
      "method": "GetParentEntry",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetPartsOfSpeech": {
      "class": "ReversalOperations",
      "method": "GetPartsOfSpeech",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetSenseCount": {
      "class": "ReversalOperations",
      "method": "GetSenseCount",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetSenses": {
      "class": "ReversalOperations",
      "method": "GetSenses",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetSubentries": {
      "class": "ReversalOperations",
      "method": "GetSubentries",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.GetSyncableProperties": {
      "class": "ReversalOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.RemoveSense": {
      "class": "ReversalOperations",
      "method": "RemoveSense",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.SetForm": {
      "class": "ReversalOperations",
      "method": "SetForm",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalOperations.__init__": {
      "class": "ReversalOperations",
      "method": "__init__",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.CompareTo": {
      "class": "SemanticDomainOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.Create": {
      "class": "SemanticDomainOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.Delete": {
      "class": "SemanticDomainOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.Duplicate": {
      "class": "SemanticDomainOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.Exists": {
      "class": "SemanticDomainOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.Find": {
      "class": "SemanticDomainOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.FindByName": {
      "class": "SemanticDomainOperations",
      "method": "FindByName",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetAbbreviation": {
      "class": "SemanticDomainOperations",
      "method": "GetAbbreviation",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetAll": {
      "class": "SemanticDomainOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetDepth": {
      "class": "SemanticDomainOperations",
      "method": "GetDepth",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetDescription": {
      "class": "SemanticDomainOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetName": {
      "class": "SemanticDomainOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetNumber": {
      "class": "SemanticDomainOperations",
      "method": "GetNumber",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetOcmCodes": {
      "class": "SemanticDomainOperations",
      "method": "GetOcmCodes",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetParent": {
      "class": "SemanticDomainOperations",
      "method": "GetParent",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetQuestions": {
      "class": "SemanticDomainOperations",
      "method": "GetQuestions",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetSenseCount": {
      "class": "SemanticDomainOperations",
      "method": "GetSenseCount",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetSensesInDomain": {
      "class": "SemanticDomainOperations",
      "method": "GetSensesInDomain",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetSubdomains": {
      "class": "SemanticDomainOperations",
      "method": "GetSubdomains",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.GetSyncableProperties": {
      "class": "SemanticDomainOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.SetDescription": {
      "class": "SemanticDomainOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.SetName": {
      "class": "SemanticDomainOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SemanticDomainOperations.__init__": {
      "class": "SemanticDomainOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmSemanticDomain",
        "ICmSemanticDomainFactory",
        "ILexSenseRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.AddComponentLexeme": {
      "class": "VariantOperations",
      "method": "AddComponentLexeme",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.CompareTo": {
      "class": "VariantOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.Create": {
      "class": "VariantOperations",
      "method": "Create",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.Delete": {
      "class": "VariantOperations",
      "method": "Delete",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.Duplicate": {
      "class": "VariantOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.FindType": {
      "class": "VariantOperations",
      "method": "FindType",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetAll": {
      "class": "VariantOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetAllTypes": {
      "class": "VariantOperations",
      "method": "GetAllTypes",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetComponentLexemes": {
      "class": "VariantOperations",
      "method": "GetComponentLexemes",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetForm": {
      "class": "VariantOperations",
      "method": "GetForm",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetOwningEntry": {
      "class": "VariantOperations",
      "method": "GetOwningEntry",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetSyncableProperties": {
      "class": "VariantOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetType": {
      "class": "VariantOperations",
      "method": "GetType",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetTypeDescription": {
      "class": "VariantOperations",
      "method": "GetTypeDescription",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetTypeName": {
      "class": "VariantOperations",
      "method": "GetTypeName",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.GetVariantCount": {
      "class": "VariantOperations",
      "method": "GetVariantCount",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.RemoveComponentLexeme": {
      "class": "VariantOperations",
      "method": "RemoveComponentLexeme",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.SetForm": {
      "class": "VariantOperations",
      "method": "SetForm",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.SetType": {
      "class": "VariantOperations",
      "method": "SetType",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "VariantOperations.__init__": {
      "class": "VariantOperations",
      "method": "__init__",
      "lcm_deps": [
        "ILexEntry",
        "ILexEntryRef",
        "ILexEntryRefFactory",
        "ILexEntryType",
        "ILexEntryTypeRepository",
        "IVariantComponentLexeme",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.CompareTo": {
      "class": "AgentOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.Create": {
      "class": "AgentOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.CreateHumanAgent": {
      "class": "AgentOperations",
      "method": "CreateHumanAgent",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.CreateParserAgent": {
      "class": "AgentOperations",
      "method": "CreateParserAgent",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.Delete": {
      "class": "AgentOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.Duplicate": {
      "class": "AgentOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.Exists": {
      "class": "AgentOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.Find": {
      "class": "AgentOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.FindByType": {
      "class": "AgentOperations",
      "method": "FindByType",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetAll": {
      "class": "AgentOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetDateCreated": {
      "class": "AgentOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetDateModified": {
      "class": "AgentOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetEvaluationCount": {
      "class": "AgentOperations",
      "method": "GetEvaluationCount",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetEvaluations": {
      "class": "AgentOperations",
      "method": "GetEvaluations",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetGuid": {
      "class": "AgentOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetHuman": {
      "class": "AgentOperations",
      "method": "GetHuman",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetHumanAgents": {
      "class": "AgentOperations",
      "method": "GetHumanAgents",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetName": {
      "class": "AgentOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetParserAgents": {
      "class": "AgentOperations",
      "method": "GetParserAgents",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetSyncableProperties": {
      "class": "AgentOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.GetVersion": {
      "class": "AgentOperations",
      "method": "GetVersion",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.IsHuman": {
      "class": "AgentOperations",
      "method": "IsHuman",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.IsParser": {
      "class": "AgentOperations",
      "method": "IsParser",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.SetHuman": {
      "class": "AgentOperations",
      "method": "SetHuman",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.SetName": {
      "class": "AgentOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.SetVersion": {
      "class": "AgentOperations",
      "method": "SetVersion",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AgentOperations.__init__": {
      "class": "AgentOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmAgent",
        "ICmAgentFactory",
        "ICmAgentRepository",
        "ICmPerson",
        "ICmAgentEvaluation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.CompareTo": {
      "class": "ConfidenceOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.Create": {
      "class": "ConfidenceOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.Delete": {
      "class": "ConfidenceOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.Duplicate": {
      "class": "ConfidenceOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.Exists": {
      "class": "ConfidenceOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.Find": {
      "class": "ConfidenceOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.GetAll": {
      "class": "ConfidenceOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.GetAnalysesWithConfidence": {
      "class": "ConfidenceOperations",
      "method": "GetAnalysesWithConfidence",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.GetDefault": {
      "class": "ConfidenceOperations",
      "method": "GetDefault",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.GetDescription": {
      "class": "ConfidenceOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.GetGlossesWithConfidence": {
      "class": "ConfidenceOperations",
      "method": "GetGlossesWithConfidence",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.GetGuid": {
      "class": "ConfidenceOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.GetName": {
      "class": "ConfidenceOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.GetSyncableProperties": {
      "class": "ConfidenceOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.SetDescription": {
      "class": "ConfidenceOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.SetName": {
      "class": "ConfidenceOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ConfidenceOperations.__init__": {
      "class": "ConfidenceOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "IWfiAnalysisRepository",
        "IWfiGlossRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.AddElement": {
      "class": "OverlayOperations",
      "method": "AddElement",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.CompareTo": {
      "class": "OverlayOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.Create": {
      "class": "OverlayOperations",
      "method": "Create",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.Delete": {
      "class": "OverlayOperations",
      "method": "Delete",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.Duplicate": {
      "class": "OverlayOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.Find": {
      "class": "OverlayOperations",
      "method": "Find",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.FindByChart": {
      "class": "OverlayOperations",
      "method": "FindByChart",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetAll": {
      "class": "OverlayOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetChart": {
      "class": "OverlayOperations",
      "method": "GetChart",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetDescription": {
      "class": "OverlayOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetDisplayOrder": {
      "class": "OverlayOperations",
      "method": "GetDisplayOrder",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetElements": {
      "class": "OverlayOperations",
      "method": "GetElements",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetGuid": {
      "class": "OverlayOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetName": {
      "class": "OverlayOperations",
      "method": "GetName",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetPossItems": {
      "class": "OverlayOperations",
      "method": "GetPossItems",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetSyncableProperties": {
      "class": "OverlayOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.GetVisibleOverlays": {
      "class": "OverlayOperations",
      "method": "GetVisibleOverlays",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.IsVisible": {
      "class": "OverlayOperations",
      "method": "IsVisible",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.RemoveElement": {
      "class": "OverlayOperations",
      "method": "RemoveElement",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.SetDescription": {
      "class": "OverlayOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.SetDisplayOrder": {
      "class": "OverlayOperations",
      "method": "SetDisplayOrder",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.SetName": {
      "class": "OverlayOperations",
      "method": "SetName",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.SetVisible": {
      "class": "OverlayOperations",
      "method": "SetVisible",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "OverlayOperations.__init__": {
      "class": "OverlayOperations",
      "method": "__init__",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.CompareTo": {
      "class": "PossibilityListOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.CreateItem": {
      "class": "PossibilityListOperations",
      "method": "CreateItem",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.CreateList": {
      "class": "PossibilityListOperations",
      "method": "CreateList",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.DeleteItem": {
      "class": "PossibilityListOperations",
      "method": "DeleteItem",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.DeleteList": {
      "class": "PossibilityListOperations",
      "method": "DeleteList",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.Duplicate": {
      "class": "PossibilityListOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.FindItem": {
      "class": "PossibilityListOperations",
      "method": "FindItem",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.FindList": {
      "class": "PossibilityListOperations",
      "method": "FindList",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetAllLists": {
      "class": "PossibilityListOperations",
      "method": "GetAllLists",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetDepth": {
      "class": "PossibilityListOperations",
      "method": "GetDepth",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetItemAbbreviation": {
      "class": "PossibilityListOperations",
      "method": "GetItemAbbreviation",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetItemDescription": {
      "class": "PossibilityListOperations",
      "method": "GetItemDescription",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetItemGuid": {
      "class": "PossibilityListOperations",
      "method": "GetItemGuid",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetItemHvo": {
      "class": "PossibilityListOperations",
      "method": "GetItemHvo",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetItemName": {
      "class": "PossibilityListOperations",
      "method": "GetItemName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetItems": {
      "class": "PossibilityListOperations",
      "method": "GetItems",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetListGuid": {
      "class": "PossibilityListOperations",
      "method": "GetListGuid",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetListHvo": {
      "class": "PossibilityListOperations",
      "method": "GetListHvo",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetListName": {
      "class": "PossibilityListOperations",
      "method": "GetListName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetParentItem": {
      "class": "PossibilityListOperations",
      "method": "GetParentItem",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetSubitems": {
      "class": "PossibilityListOperations",
      "method": "GetSubitems",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.GetSyncableProperties": {
      "class": "PossibilityListOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.MoveItem": {
      "class": "PossibilityListOperations",
      "method": "MoveItem",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.SetItemAbbreviation": {
      "class": "PossibilityListOperations",
      "method": "SetItemAbbreviation",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.SetItemDescription": {
      "class": "PossibilityListOperations",
      "method": "SetItemDescription",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.SetItemName": {
      "class": "PossibilityListOperations",
      "method": "SetItemName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.SetListName": {
      "class": "PossibilityListOperations",
      "method": "SetListName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PossibilityListOperations.__init__": {
      "class": "PossibilityListOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ICmPossibilityListFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.AddDivision": {
      "class": "PublicationOperations",
      "method": "AddDivision",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.CompareTo": {
      "class": "PublicationOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.Create": {
      "class": "PublicationOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.Delete": {
      "class": "PublicationOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.Duplicate": {
      "class": "PublicationOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.Exists": {
      "class": "PublicationOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.Find": {
      "class": "PublicationOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetAll": {
      "class": "PublicationOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetDateCreated": {
      "class": "PublicationOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetDateModified": {
      "class": "PublicationOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetDescription": {
      "class": "PublicationOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetDivisions": {
      "class": "PublicationOperations",
      "method": "GetDivisions",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetGuid": {
      "class": "PublicationOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetHeaderFooter": {
      "class": "PublicationOperations",
      "method": "GetHeaderFooter",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetIsDefault": {
      "class": "PublicationOperations",
      "method": "GetIsDefault",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetIsLandscape": {
      "class": "PublicationOperations",
      "method": "GetIsLandscape",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetName": {
      "class": "PublicationOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetPageHeight": {
      "class": "PublicationOperations",
      "method": "GetPageHeight",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetPageLayout": {
      "class": "PublicationOperations",
      "method": "GetPageLayout",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetPageWidth": {
      "class": "PublicationOperations",
      "method": "GetPageWidth",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetParent": {
      "class": "PublicationOperations",
      "method": "GetParent",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetSubPublications": {
      "class": "PublicationOperations",
      "method": "GetSubPublications",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.GetSyncableProperties": {
      "class": "PublicationOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.SetDescription": {
      "class": "PublicationOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.SetIsDefault": {
      "class": "PublicationOperations",
      "method": "SetIsDefault",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.SetName": {
      "class": "PublicationOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.SetPageHeight": {
      "class": "PublicationOperations",
      "method": "SetPageHeight",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.SetPageLayout": {
      "class": "PublicationOperations",
      "method": "SetPageLayout",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.SetPageWidth": {
      "class": "PublicationOperations",
      "method": "SetPageWidth",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PublicationOperations.__init__": {
      "class": "PublicationOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TranslationTypeOperations.CompareTo": {
      "class": "TranslationTypeOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.Create": {
      "class": "TranslationTypeOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.Delete": {
      "class": "TranslationTypeOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.Duplicate": {
      "class": "TranslationTypeOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.Exists": {
      "class": "TranslationTypeOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.Find": {
      "class": "TranslationTypeOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.FindByWS": {
      "class": "TranslationTypeOperations",
      "method": "FindByWS",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetAbbreviation": {
      "class": "TranslationTypeOperations",
      "method": "GetAbbreviation",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetAll": {
      "class": "TranslationTypeOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetAnalysisWS": {
      "class": "TranslationTypeOperations",
      "method": "GetAnalysisWS",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetBackTranslationType": {
      "class": "TranslationTypeOperations",
      "method": "GetBackTranslationType",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetFreeTranslationType": {
      "class": "TranslationTypeOperations",
      "method": "GetFreeTranslationType",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetGuid": {
      "class": "TranslationTypeOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetLiteralTranslationType": {
      "class": "TranslationTypeOperations",
      "method": "GetLiteralTranslationType",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetName": {
      "class": "TranslationTypeOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetSegmentsWithType": {
      "class": "TranslationTypeOperations",
      "method": "GetSegmentsWithType",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetSyncableProperties": {
      "class": "TranslationTypeOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.GetTextsWithType": {
      "class": "TranslationTypeOperations",
      "method": "GetTextsWithType",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.IsDefault": {
      "class": "TranslationTypeOperations",
      "method": "IsDefault",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.SetAbbreviation": {
      "class": "TranslationTypeOperations",
      "method": "SetAbbreviation",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.SetAnalysisWS": {
      "class": "TranslationTypeOperations",
      "method": "SetAnalysisWS",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.SetDefault": {
      "class": "TranslationTypeOperations",
      "method": "SetDefault",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.SetName": {
      "class": "TranslationTypeOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "TranslationTypeOperations.__init__": {
      "class": "TranslationTypeOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ITextRepository",
        "IStTxtParaRepository",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.AddResearcher": {
      "class": "AnthropologyOperations",
      "method": "AddResearcher",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.AddText": {
      "class": "AnthropologyOperations",
      "method": "AddText",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.CompareTo": {
      "class": "AnthropologyOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.Create": {
      "class": "AnthropologyOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.CreateSubitem": {
      "class": "AnthropologyOperations",
      "method": "CreateSubitem",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.Delete": {
      "class": "AnthropologyOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.Duplicate": {
      "class": "AnthropologyOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.Exists": {
      "class": "AnthropologyOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.Find": {
      "class": "AnthropologyOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.FindByCategory": {
      "class": "AnthropologyOperations",
      "method": "FindByCategory",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.FindByCode": {
      "class": "AnthropologyOperations",
      "method": "FindByCode",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetAbbreviation": {
      "class": "AnthropologyOperations",
      "method": "GetAbbreviation",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetAll": {
      "class": "AnthropologyOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetAnthroCode": {
      "class": "AnthropologyOperations",
      "method": "GetAnthroCode",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetCategory": {
      "class": "AnthropologyOperations",
      "method": "GetCategory",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetDateCreated": {
      "class": "AnthropologyOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetDateModified": {
      "class": "AnthropologyOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetDescription": {
      "class": "AnthropologyOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetGuid": {
      "class": "AnthropologyOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetItemsForText": {
      "class": "AnthropologyOperations",
      "method": "GetItemsForText",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetName": {
      "class": "AnthropologyOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetParent": {
      "class": "AnthropologyOperations",
      "method": "GetParent",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetResearchers": {
      "class": "AnthropologyOperations",
      "method": "GetResearchers",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetSubitems": {
      "class": "AnthropologyOperations",
      "method": "GetSubitems",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetSyncableProperties": {
      "class": "AnthropologyOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetTextCount": {
      "class": "AnthropologyOperations",
      "method": "GetTextCount",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.GetTexts": {
      "class": "AnthropologyOperations",
      "method": "GetTexts",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.RemoveResearcher": {
      "class": "AnthropologyOperations",
      "method": "RemoveResearcher",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.RemoveText": {
      "class": "AnthropologyOperations",
      "method": "RemoveText",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.SetAbbreviation": {
      "class": "AnthropologyOperations",
      "method": "SetAbbreviation",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.SetAnthroCode": {
      "class": "AnthropologyOperations",
      "method": "SetAnthroCode",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.SetCategory": {
      "class": "AnthropologyOperations",
      "method": "SetCategory",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.SetDescription": {
      "class": "AnthropologyOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.SetName": {
      "class": "AnthropologyOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "AnthropologyOperations.__init__": {
      "class": "AnthropologyOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmAnthroItem",
        "ICmAnthroItemFactory",
        "IText",
        "ICmPerson",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "DataNotebookOperations.AddLocation": {
      "class": "DataNotebookOperations",
      "method": "AddLocation",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.AddMediaFile": {
      "class": "DataNotebookOperations",
      "method": "AddMediaFile",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.AddParticipant": {
      "class": "DataNotebookOperations",
      "method": "AddParticipant",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.AddResearcher": {
      "class": "DataNotebookOperations",
      "method": "AddResearcher",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.AddSource": {
      "class": "DataNotebookOperations",
      "method": "AddSource",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.CompareTo": {
      "class": "DataNotebookOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.Create": {
      "class": "DataNotebookOperations",
      "method": "Create",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.CreateSubRecord": {
      "class": "DataNotebookOperations",
      "method": "CreateSubRecord",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.Delete": {
      "class": "DataNotebookOperations",
      "method": "Delete",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.Duplicate": {
      "class": "DataNotebookOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.Exists": {
      "class": "DataNotebookOperations",
      "method": "Exists",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.Find": {
      "class": "DataNotebookOperations",
      "method": "Find",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.FindByDate": {
      "class": "DataNotebookOperations",
      "method": "FindByDate",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.FindByResearcher": {
      "class": "DataNotebookOperations",
      "method": "FindByResearcher",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.FindByType": {
      "class": "DataNotebookOperations",
      "method": "FindByType",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.FindRecordTypeByName": {
      "class": "DataNotebookOperations",
      "method": "FindRecordTypeByName",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.FindStatusByName": {
      "class": "DataNotebookOperations",
      "method": "FindStatusByName",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetAll": {
      "class": "DataNotebookOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetAllRecordTypes": {
      "class": "DataNotebookOperations",
      "method": "GetAllRecordTypes",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetAllStatuses": {
      "class": "DataNotebookOperations",
      "method": "GetAllStatuses",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetConfidence": {
      "class": "DataNotebookOperations",
      "method": "GetConfidence",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetContent": {
      "class": "DataNotebookOperations",
      "method": "GetContent",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetDateCreated": {
      "class": "DataNotebookOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetDateModified": {
      "class": "DataNotebookOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetDateOfEvent": {
      "class": "DataNotebookOperations",
      "method": "GetDateOfEvent",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetGuid": {
      "class": "DataNotebookOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetLocations": {
      "class": "DataNotebookOperations",
      "method": "GetLocations",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetMediaFiles": {
      "class": "DataNotebookOperations",
      "method": "GetMediaFiles",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetParentRecord": {
      "class": "DataNotebookOperations",
      "method": "GetParentRecord",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetParticipants": {
      "class": "DataNotebookOperations",
      "method": "GetParticipants",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetRecordType": {
      "class": "DataNotebookOperations",
      "method": "GetRecordType",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetResearchers": {
      "class": "DataNotebookOperations",
      "method": "GetResearchers",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetSources": {
      "class": "DataNotebookOperations",
      "method": "GetSources",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetStatus": {
      "class": "DataNotebookOperations",
      "method": "GetStatus",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetSubRecords": {
      "class": "DataNotebookOperations",
      "method": "GetSubRecords",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetSyncableProperties": {
      "class": "DataNotebookOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetTexts": {
      "class": "DataNotebookOperations",
      "method": "GetTexts",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.GetTitle": {
      "class": "DataNotebookOperations",
      "method": "GetTitle",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.LinkToText": {
      "class": "DataNotebookOperations",
      "method": "LinkToText",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.RemoveLocation": {
      "class": "DataNotebookOperations",
      "method": "RemoveLocation",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.RemoveMediaFile": {
      "class": "DataNotebookOperations",
      "method": "RemoveMediaFile",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.RemoveParticipant": {
      "class": "DataNotebookOperations",
      "method": "RemoveParticipant",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.RemoveResearcher": {
      "class": "DataNotebookOperations",
      "method": "RemoveResearcher",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.RemoveSource": {
      "class": "DataNotebookOperations",
      "method": "RemoveSource",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.SetConfidence": {
      "class": "DataNotebookOperations",
      "method": "SetConfidence",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.SetContent": {
      "class": "DataNotebookOperations",
      "method": "SetContent",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.SetDateOfEvent": {
      "class": "DataNotebookOperations",
      "method": "SetDateOfEvent",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.SetRecordType": {
      "class": "DataNotebookOperations",
      "method": "SetRecordType",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.SetStatus": {
      "class": "DataNotebookOperations",
      "method": "SetStatus",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.SetTitle": {
      "class": "DataNotebookOperations",
      "method": "SetTitle",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.UnlinkFromText": {
      "class": "DataNotebookOperations",
      "method": "UnlinkFromText",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DataNotebookOperations.__init__": {
      "class": "DataNotebookOperations",
      "method": "__init__",
      "lcm_deps": [
        "IRnGenericRec",
        "IRnGenericRecFactory",
        "IRnResearchNbkRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmPerson",
        "IText",
        "ICmFile",
        "ICmFileFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "LocationOperations.CompareTo": {
      "class": "LocationOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.Create": {
      "class": "LocationOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.CreateSublocation": {
      "class": "LocationOperations",
      "method": "CreateSublocation",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.Delete": {
      "class": "LocationOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.Duplicate": {
      "class": "LocationOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.Exists": {
      "class": "LocationOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.Find": {
      "class": "LocationOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.FindByCoordinates": {
      "class": "LocationOperations",
      "method": "FindByCoordinates",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetAlias": {
      "class": "LocationOperations",
      "method": "GetAlias",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetAll": {
      "class": "LocationOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetCoordinates": {
      "class": "LocationOperations",
      "method": "GetCoordinates",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetDateCreated": {
      "class": "LocationOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetDateModified": {
      "class": "LocationOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetDescription": {
      "class": "LocationOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetElevation": {
      "class": "LocationOperations",
      "method": "GetElevation",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetGuid": {
      "class": "LocationOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetName": {
      "class": "LocationOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetNearby": {
      "class": "LocationOperations",
      "method": "GetNearby",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetRegion": {
      "class": "LocationOperations",
      "method": "GetRegion",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetSublocations": {
      "class": "LocationOperations",
      "method": "GetSublocations",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.GetSyncableProperties": {
      "class": "LocationOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.SetAlias": {
      "class": "LocationOperations",
      "method": "SetAlias",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.SetCoordinates": {
      "class": "LocationOperations",
      "method": "SetCoordinates",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.SetDescription": {
      "class": "LocationOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.SetElevation": {
      "class": "LocationOperations",
      "method": "SetElevation",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.SetName": {
      "class": "LocationOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.SetRegion": {
      "class": "LocationOperations",
      "method": "SetRegion",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "LocationOperations.__init__": {
      "class": "LocationOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmLocation",
        "ICmLocationFactory",
        "ICmPossibilityRepository",
        "ITsString",
        "TsStringUtils",
        "GenDate"
      ]
    },
    "NoteOperations.AddReply": {
      "class": "NoteOperations",
      "method": "AddReply",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.CompareTo": {
      "class": "NoteOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.Create": {
      "class": "NoteOperations",
      "method": "Create",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.Delete": {
      "class": "NoteOperations",
      "method": "Delete",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.Duplicate": {
      "class": "NoteOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetAll": {
      "class": "NoteOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetAuthor": {
      "class": "NoteOperations",
      "method": "GetAuthor",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetContent": {
      "class": "NoteOperations",
      "method": "GetContent",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetDateCreated": {
      "class": "NoteOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetDateModified": {
      "class": "NoteOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetGuid": {
      "class": "NoteOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetNoteType": {
      "class": "NoteOperations",
      "method": "GetNoteType",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetOwner": {
      "class": "NoteOperations",
      "method": "GetOwner",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetReplies": {
      "class": "NoteOperations",
      "method": "GetReplies",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.GetSyncableProperties": {
      "class": "NoteOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.Reorder": {
      "class": "NoteOperations",
      "method": "Reorder",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.SetAuthor": {
      "class": "NoteOperations",
      "method": "SetAuthor",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.SetContent": {
      "class": "NoteOperations",
      "method": "SetContent",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.SetNoteType": {
      "class": "NoteOperations",
      "method": "SetNoteType",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "NoteOperations.__init__": {
      "class": "NoteOperations",
      "method": "__init__",
      "lcm_deps": [
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "ICmBaseAnnotation",
        "ICmBaseAnnotationFactory",
        "ICmAnnotationDefn",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.AddLanguage": {
      "class": "PersonOperations",
      "method": "AddLanguage",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.AddNote": {
      "class": "PersonOperations",
      "method": "AddNote",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.AddPosition": {
      "class": "PersonOperations",
      "method": "AddPosition",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.AddResidence": {
      "class": "PersonOperations",
      "method": "AddResidence",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.CompareTo": {
      "class": "PersonOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.Create": {
      "class": "PersonOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.Delete": {
      "class": "PersonOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.Duplicate": {
      "class": "PersonOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.Exists": {
      "class": "PersonOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.Find": {
      "class": "PersonOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetAddress": {
      "class": "PersonOperations",
      "method": "GetAddress",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetAll": {
      "class": "PersonOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetDateCreated": {
      "class": "PersonOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetDateModified": {
      "class": "PersonOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetDateOfBirth": {
      "class": "PersonOperations",
      "method": "GetDateOfBirth",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetEducation": {
      "class": "PersonOperations",
      "method": "GetEducation",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetEmail": {
      "class": "PersonOperations",
      "method": "GetEmail",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetGender": {
      "class": "PersonOperations",
      "method": "GetGender",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetGuid": {
      "class": "PersonOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetLanguages": {
      "class": "PersonOperations",
      "method": "GetLanguages",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetName": {
      "class": "PersonOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetNotes": {
      "class": "PersonOperations",
      "method": "GetNotes",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetPhone": {
      "class": "PersonOperations",
      "method": "GetPhone",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetPositions": {
      "class": "PersonOperations",
      "method": "GetPositions",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetResidences": {
      "class": "PersonOperations",
      "method": "GetResidences",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.GetSyncableProperties": {
      "class": "PersonOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.SetAddress": {
      "class": "PersonOperations",
      "method": "SetAddress",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.SetDateOfBirth": {
      "class": "PersonOperations",
      "method": "SetDateOfBirth",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.SetEducation": {
      "class": "PersonOperations",
      "method": "SetEducation",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.SetEmail": {
      "class": "PersonOperations",
      "method": "SetEmail",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.SetGender": {
      "class": "PersonOperations",
      "method": "SetGender",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.SetName": {
      "class": "PersonOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.SetPhone": {
      "class": "PersonOperations",
      "method": "SetPhone",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "PersonOperations.__init__": {
      "class": "PersonOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmPerson",
        "ICmPersonFactory",
        "ICmPersonRepository",
        "ICmPossibility",
        "ICmPossibilityRepository",
        "ICmLocation",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.AddSense": {
      "class": "ReversalIndexEntryOperations",
      "method": "AddSense",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.Create": {
      "class": "ReversalIndexEntryOperations",
      "method": "Create",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.Delete": {
      "class": "ReversalIndexEntryOperations",
      "method": "Delete",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.Find": {
      "class": "ReversalIndexEntryOperations",
      "method": "Find",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.FindByHvo": {
      "class": "ReversalIndexEntryOperations",
      "method": "FindByHvo",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.GetAll": {
      "class": "ReversalIndexEntryOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.GetForm": {
      "class": "ReversalIndexEntryOperations",
      "method": "GetForm",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.GetSenses": {
      "class": "ReversalIndexEntryOperations",
      "method": "GetSenses",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.GetSubentries": {
      "class": "ReversalIndexEntryOperations",
      "method": "GetSubentries",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.RemoveSense": {
      "class": "ReversalIndexEntryOperations",
      "method": "RemoveSense",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.SetForm": {
      "class": "ReversalIndexEntryOperations",
      "method": "SetForm",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexEntryOperations.__init__": {
      "class": "ReversalIndexEntryOperations",
      "method": "__init__",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexEntry",
        "IReversalIndexEntryFactory",
        "ILexSense",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.Create": {
      "class": "ReversalIndexOperations",
      "method": "Create",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.Delete": {
      "class": "ReversalIndexOperations",
      "method": "Delete",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.ExportToLIFT": {
      "class": "ReversalIndexOperations",
      "method": "ExportToLIFT",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.Find": {
      "class": "ReversalIndexOperations",
      "method": "Find",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.FindByWritingSystem": {
      "class": "ReversalIndexOperations",
      "method": "FindByWritingSystem",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.GetAll": {
      "class": "ReversalIndexOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.GetEntries": {
      "class": "ReversalIndexOperations",
      "method": "GetEntries",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.GetName": {
      "class": "ReversalIndexOperations",
      "method": "GetName",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.GetWritingSystem": {
      "class": "ReversalIndexOperations",
      "method": "GetWritingSystem",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.SetName": {
      "class": "ReversalIndexOperations",
      "method": "SetName",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ReversalIndexOperations.__init__": {
      "class": "ReversalIndexOperations",
      "method": "__init__",
      "lcm_deps": [
        "IReversalIndex",
        "IReversalIndexFactory",
        "IReversalIndexRepository",
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrAnnotationsOperations.Create": {
      "class": "ScrAnnotationsOperations",
      "method": "Create",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrBookAnnotationsFactory",
        "IScrScriptureNote"
      ]
    },
    "ScrAnnotationsOperations.Delete": {
      "class": "ScrAnnotationsOperations",
      "method": "Delete",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrBookAnnotationsFactory",
        "IScrScriptureNote"
      ]
    },
    "ScrAnnotationsOperations.GetForBook": {
      "class": "ScrAnnotationsOperations",
      "method": "GetForBook",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrBookAnnotationsFactory",
        "IScrScriptureNote"
      ]
    },
    "ScrAnnotationsOperations.GetNotes": {
      "class": "ScrAnnotationsOperations",
      "method": "GetNotes",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrBookAnnotationsFactory",
        "IScrScriptureNote"
      ]
    },
    "ScrAnnotationsOperations.__init__": {
      "class": "ScrAnnotationsOperations",
      "method": "__init__",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrBookAnnotationsFactory",
        "IScrScriptureNote"
      ]
    },
    "ScrBookOperations.Create": {
      "class": "ScrBookOperations",
      "method": "Create",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrBookOperations.Delete": {
      "class": "ScrBookOperations",
      "method": "Delete",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrBookOperations.Find": {
      "class": "ScrBookOperations",
      "method": "Find",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrBookOperations.FindByName": {
      "class": "ScrBookOperations",
      "method": "FindByName",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrBookOperations.GetAll": {
      "class": "ScrBookOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrBookOperations.GetCanonicalNum": {
      "class": "ScrBookOperations",
      "method": "GetCanonicalNum",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrBookOperations.GetSections": {
      "class": "ScrBookOperations",
      "method": "GetSections",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrBookOperations.GetTitle": {
      "class": "ScrBookOperations",
      "method": "GetTitle",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrBookOperations.SetTitle": {
      "class": "ScrBookOperations",
      "method": "SetTitle",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrBookOperations.__init__": {
      "class": "ScrBookOperations",
      "method": "__init__",
      "lcm_deps": [
        "IScrBook",
        "IScrBookFactory",
        "IScrBookRepository",
        "IScrSection",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrDraftOperations.Create": {
      "class": "ScrDraftOperations",
      "method": "Create",
      "lcm_deps": [
        "IScrDraft",
        "IScrDraftFactory",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrDraftOperations.Delete": {
      "class": "ScrDraftOperations",
      "method": "Delete",
      "lcm_deps": [
        "IScrDraft",
        "IScrDraftFactory",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrDraftOperations.Find": {
      "class": "ScrDraftOperations",
      "method": "Find",
      "lcm_deps": [
        "IScrDraft",
        "IScrDraftFactory",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrDraftOperations.GetAll": {
      "class": "ScrDraftOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IScrDraft",
        "IScrDraftFactory",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrDraftOperations.GetBooks": {
      "class": "ScrDraftOperations",
      "method": "GetBooks",
      "lcm_deps": [
        "IScrDraft",
        "IScrDraftFactory",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrDraftOperations.GetDescription": {
      "class": "ScrDraftOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "IScrDraft",
        "IScrDraftFactory",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrDraftOperations.SetDescription": {
      "class": "ScrDraftOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "IScrDraft",
        "IScrDraftFactory",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrDraftOperations.__init__": {
      "class": "ScrDraftOperations",
      "method": "__init__",
      "lcm_deps": [
        "IScrDraft",
        "IScrDraftFactory",
        "IScripture",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ScrNoteOperations.Create": {
      "class": "ScrNoteOperations",
      "method": "Create",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrNoteOperations.Delete": {
      "class": "ScrNoteOperations",
      "method": "Delete",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrNoteOperations.Find": {
      "class": "ScrNoteOperations",
      "method": "Find",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrNoteOperations.GetAll": {
      "class": "ScrNoteOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrNoteOperations.GetText": {
      "class": "ScrNoteOperations",
      "method": "GetText",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrNoteOperations.GetType": {
      "class": "ScrNoteOperations",
      "method": "GetType",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrNoteOperations.IsResolved": {
      "class": "ScrNoteOperations",
      "method": "IsResolved",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrNoteOperations.Resolve": {
      "class": "ScrNoteOperations",
      "method": "Resolve",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrNoteOperations.SetText": {
      "class": "ScrNoteOperations",
      "method": "SetText",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrNoteOperations.__init__": {
      "class": "ScrNoteOperations",
      "method": "__init__",
      "lcm_deps": [
        "IScrBook",
        "IScrBookAnnotations",
        "IScrScriptureNote",
        "IScrScriptureNoteFactory",
        "IScrTxtPara",
        "ITsString",
        "TsStringUtils",
        "IScrBookAnnotationsFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTextFactory",
        "IStTxtParaFactory",
        "IStTxtParaFactory"
      ]
    },
    "ScrSectionOperations.Create": {
      "class": "ScrSectionOperations",
      "method": "Create",
      "lcm_deps": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ]
    },
    "ScrSectionOperations.Delete": {
      "class": "ScrSectionOperations",
      "method": "Delete",
      "lcm_deps": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ]
    },
    "ScrSectionOperations.Find": {
      "class": "ScrSectionOperations",
      "method": "Find",
      "lcm_deps": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ]
    },
    "ScrSectionOperations.GetAll": {
      "class": "ScrSectionOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ]
    },
    "ScrSectionOperations.GetContent": {
      "class": "ScrSectionOperations",
      "method": "GetContent",
      "lcm_deps": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ]
    },
    "ScrSectionOperations.GetHeading": {
      "class": "ScrSectionOperations",
      "method": "GetHeading",
      "lcm_deps": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ]
    },
    "ScrSectionOperations.MoveTo": {
      "class": "ScrSectionOperations",
      "method": "MoveTo",
      "lcm_deps": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ]
    },
    "ScrSectionOperations.SetHeading": {
      "class": "ScrSectionOperations",
      "method": "SetHeading",
      "lcm_deps": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ]
    },
    "ScrSectionOperations.__init__": {
      "class": "ScrSectionOperations",
      "method": "__init__",
      "lcm_deps": [
        "IScrBook",
        "IScrSection",
        "IScrSectionFactory",
        "IScrTxtPara",
        "IStText",
        "IStTextFactory",
        "ITsString",
        "TsStringUtils",
        "IStTxtParaFactory"
      ]
    },
    "ScrTxtParaOperations.Create": {
      "class": "ScrTxtParaOperations",
      "method": "Create",
      "lcm_deps": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ]
    },
    "ScrTxtParaOperations.Delete": {
      "class": "ScrTxtParaOperations",
      "method": "Delete",
      "lcm_deps": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ]
    },
    "ScrTxtParaOperations.Find": {
      "class": "ScrTxtParaOperations",
      "method": "Find",
      "lcm_deps": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ]
    },
    "ScrTxtParaOperations.GetAll": {
      "class": "ScrTxtParaOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ]
    },
    "ScrTxtParaOperations.GetStyleName": {
      "class": "ScrTxtParaOperations",
      "method": "GetStyleName",
      "lcm_deps": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ]
    },
    "ScrTxtParaOperations.GetText": {
      "class": "ScrTxtParaOperations",
      "method": "GetText",
      "lcm_deps": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ]
    },
    "ScrTxtParaOperations.SetStyleName": {
      "class": "ScrTxtParaOperations",
      "method": "SetStyleName",
      "lcm_deps": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ]
    },
    "ScrTxtParaOperations.SetText": {
      "class": "ScrTxtParaOperations",
      "method": "SetText",
      "lcm_deps": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ]
    },
    "ScrTxtParaOperations.__init__": {
      "class": "ScrTxtParaOperations",
      "method": "__init__",
      "lcm_deps": [
        "IScrSection",
        "IScrTxtPara",
        "IScrTxtParaFactory",
        "IStStyle",
        "ITsString",
        "TsStringUtils",
        "IStTextFactory"
      ]
    },
    "FilterOperations.ApplyFilter": {
      "class": "FilterOperations",
      "method": "ApplyFilter",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.CompareTo": {
      "class": "FilterOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.Create": {
      "class": "FilterOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.Delete": {
      "class": "FilterOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.Duplicate": {
      "class": "FilterOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.Exists": {
      "class": "FilterOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.ExportFilter": {
      "class": "FilterOperations",
      "method": "ExportFilter",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.Find": {
      "class": "FilterOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetAll": {
      "class": "FilterOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetCriteria": {
      "class": "FilterOperations",
      "method": "GetCriteria",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetDateCreated": {
      "class": "FilterOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetDateModified": {
      "class": "FilterOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetFilterType": {
      "class": "FilterOperations",
      "method": "GetFilterType",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetFiltersByType": {
      "class": "FilterOperations",
      "method": "GetFiltersByType",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetGuid": {
      "class": "FilterOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetMatchCount": {
      "class": "FilterOperations",
      "method": "GetMatchCount",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetName": {
      "class": "FilterOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.GetSyncableProperties": {
      "class": "FilterOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.ImportFilter": {
      "class": "FilterOperations",
      "method": "ImportFilter",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.SetCriteria": {
      "class": "FilterOperations",
      "method": "SetCriteria",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.SetName": {
      "class": "FilterOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "FilterOperations.__init__": {
      "class": "FilterOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmFilter",
        "ICmFilterFactory",
        "IFsClosedFeature",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.CompareTo": {
      "class": "MediaOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.CopyToProject": {
      "class": "MediaOperations",
      "method": "CopyToProject",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.Create": {
      "class": "MediaOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.Delete": {
      "class": "MediaOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.Duplicate": {
      "class": "MediaOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.Exists": {
      "class": "MediaOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.Find": {
      "class": "MediaOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetAll": {
      "class": "MediaOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetAllByType": {
      "class": "MediaOperations",
      "method": "GetAllByType",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetExternalPath": {
      "class": "MediaOperations",
      "method": "GetExternalPath",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetFileSize": {
      "class": "MediaOperations",
      "method": "GetFileSize",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetGuid": {
      "class": "MediaOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetHvo": {
      "class": "MediaOperations",
      "method": "GetHvo",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetInternalPath": {
      "class": "MediaOperations",
      "method": "GetInternalPath",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetLabel": {
      "class": "MediaOperations",
      "method": "GetLabel",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetMediaType": {
      "class": "MediaOperations",
      "method": "GetMediaType",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetOrphanedMedia": {
      "class": "MediaOperations",
      "method": "GetOrphanedMedia",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetOwnerCount": {
      "class": "MediaOperations",
      "method": "GetOwnerCount",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetOwners": {
      "class": "MediaOperations",
      "method": "GetOwners",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.GetSyncableProperties": {
      "class": "MediaOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.IsAudio": {
      "class": "MediaOperations",
      "method": "IsAudio",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.IsImage": {
      "class": "MediaOperations",
      "method": "IsImage",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.IsValid": {
      "class": "MediaOperations",
      "method": "IsValid",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.IsVideo": {
      "class": "MediaOperations",
      "method": "IsVideo",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.RenameMediaFile": {
      "class": "MediaOperations",
      "method": "RenameMediaFile",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.SetInternalPath": {
      "class": "MediaOperations",
      "method": "SetInternalPath",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.SetLabel": {
      "class": "MediaOperations",
      "method": "SetLabel",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "MediaOperations.__init__": {
      "class": "MediaOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmFile",
        "ICmFileFactory",
        "ICmFolder",
        "ICmFolderFactory",
        "ICmObjectRepository",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.CompareTo": {
      "class": "AnnotationDefOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.Create": {
      "class": "AnnotationDefOperations",
      "method": "Create",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.Delete": {
      "class": "AnnotationDefOperations",
      "method": "Delete",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.Duplicate": {
      "class": "AnnotationDefOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.Exists": {
      "class": "AnnotationDefOperations",
      "method": "Exists",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.Find": {
      "class": "AnnotationDefOperations",
      "method": "Find",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.FindByType": {
      "class": "AnnotationDefOperations",
      "method": "FindByType",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetAll": {
      "class": "AnnotationDefOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetAnnotationType": {
      "class": "AnnotationDefOperations",
      "method": "GetAnnotationType",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetCopyCutPasteAllowed": {
      "class": "AnnotationDefOperations",
      "method": "GetCopyCutPasteAllowed",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetDateCreated": {
      "class": "AnnotationDefOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetGuid": {
      "class": "AnnotationDefOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetHelpString": {
      "class": "AnnotationDefOperations",
      "method": "GetHelpString",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetInstanceOf": {
      "class": "AnnotationDefOperations",
      "method": "GetInstanceOf",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetMultiple": {
      "class": "AnnotationDefOperations",
      "method": "GetMultiple",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetName": {
      "class": "AnnotationDefOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetPrompt": {
      "class": "AnnotationDefOperations",
      "method": "GetPrompt",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetSyncableProperties": {
      "class": "AnnotationDefOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetUserCanCreate": {
      "class": "AnnotationDefOperations",
      "method": "GetUserCanCreate",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.GetUserCreatableTypes": {
      "class": "AnnotationDefOperations",
      "method": "GetUserCreatableTypes",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.SetHelpString": {
      "class": "AnnotationDefOperations",
      "method": "SetHelpString",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.SetMultiple": {
      "class": "AnnotationDefOperations",
      "method": "SetMultiple",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.SetName": {
      "class": "AnnotationDefOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.SetPrompt": {
      "class": "AnnotationDefOperations",
      "method": "SetPrompt",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.SetUserCanCreate": {
      "class": "AnnotationDefOperations",
      "method": "SetUserCanCreate",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "AnnotationDefOperations.__init__": {
      "class": "AnnotationDefOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmAnnotationDefn",
        "ICmAnnotationDefnRepository",
        "ICmAnnotationDefnFactory",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CheckOperations.CompareTo": {
      "class": "CheckOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.CreateCheckType": {
      "class": "CheckOperations",
      "method": "CreateCheckType",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.DeleteCheckType": {
      "class": "CheckOperations",
      "method": "DeleteCheckType",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.DisableCheck": {
      "class": "CheckOperations",
      "method": "DisableCheck",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.Duplicate": {
      "class": "CheckOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.EnableCheck": {
      "class": "CheckOperations",
      "method": "EnableCheck",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.FindCheckType": {
      "class": "CheckOperations",
      "method": "FindCheckType",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.FindItemsWithIssues": {
      "class": "CheckOperations",
      "method": "FindItemsWithIssues",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetAllCheckTypes": {
      "class": "CheckOperations",
      "method": "GetAllCheckTypes",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetCheckResults": {
      "class": "CheckOperations",
      "method": "GetCheckResults",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetCheckStatus": {
      "class": "CheckOperations",
      "method": "GetCheckStatus",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetDescription": {
      "class": "CheckOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetEnabledChecks": {
      "class": "CheckOperations",
      "method": "GetEnabledChecks",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetErrorCount": {
      "class": "CheckOperations",
      "method": "GetErrorCount",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetGuid": {
      "class": "CheckOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetIssuesForObject": {
      "class": "CheckOperations",
      "method": "GetIssuesForObject",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetLastRun": {
      "class": "CheckOperations",
      "method": "GetLastRun",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetName": {
      "class": "CheckOperations",
      "method": "GetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetSyncableProperties": {
      "class": "CheckOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.GetWarningCount": {
      "class": "CheckOperations",
      "method": "GetWarningCount",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.IsEnabled": {
      "class": "CheckOperations",
      "method": "IsEnabled",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.RunCheck": {
      "class": "CheckOperations",
      "method": "RunCheck",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.SetDescription": {
      "class": "CheckOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.SetName": {
      "class": "CheckOperations",
      "method": "SetName",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CheckOperations.__init__": {
      "class": "CheckOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmPossibility",
        "ICmPossibilityFactory",
        "ICmPossibilityList",
        "ILexEntry",
        "IWfiWordform",
        "IText",
        "ITsString",
        "TsStringUtils",
        "ICmPossibilityListFactory"
      ]
    },
    "CustomFieldOperations.AddListValue": {
      "class": "CustomFieldOperations",
      "method": "AddListValue",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.ClearField": {
      "class": "CustomFieldOperations",
      "method": "ClearField",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.ClearValue": {
      "class": "CustomFieldOperations",
      "method": "ClearValue",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.CompareTo": {
      "class": "CustomFieldOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.CreateField": {
      "class": "CustomFieldOperations",
      "method": "CreateField",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.DeleteField": {
      "class": "CustomFieldOperations",
      "method": "DeleteField",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.Duplicate": {
      "class": "CustomFieldOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.FindField": {
      "class": "CustomFieldOperations",
      "method": "FindField",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.GetAllFields": {
      "class": "CustomFieldOperations",
      "method": "GetAllFields",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.GetFieldName": {
      "class": "CustomFieldOperations",
      "method": "GetFieldName",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.GetFieldType": {
      "class": "CustomFieldOperations",
      "method": "GetFieldType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.GetListValues": {
      "class": "CustomFieldOperations",
      "method": "GetListValues",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.GetOwnerClass": {
      "class": "CustomFieldOperations",
      "method": "GetOwnerClass",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.GetSyncableProperties": {
      "class": "CustomFieldOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.GetValue": {
      "class": "CustomFieldOperations",
      "method": "GetValue",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.IsListType": {
      "class": "CustomFieldOperations",
      "method": "IsListType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.IsMultiString": {
      "class": "CustomFieldOperations",
      "method": "IsMultiString",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.IsStringType": {
      "class": "CustomFieldOperations",
      "method": "IsStringType",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.RemoveListValue": {
      "class": "CustomFieldOperations",
      "method": "RemoveListValue",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.SetFieldName": {
      "class": "CustomFieldOperations",
      "method": "SetFieldName",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.SetListFieldMultiple": {
      "class": "CustomFieldOperations",
      "method": "SetListFieldMultiple",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.SetListFieldSingle": {
      "class": "CustomFieldOperations",
      "method": "SetListFieldSingle",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.SetValue": {
      "class": "CustomFieldOperations",
      "method": "SetValue",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "CustomFieldOperations.__init__": {
      "class": "CustomFieldOperations",
      "method": "__init__",
      "lcm_deps": [
        "ICmObjectRepository",
        "ICmPossibilityRepository",
        "ILexEntry",
        "ILexSense",
        "ILexExampleSentence",
        "IMoForm",
        "LexEntryTags",
        "LexSenseTags",
        "LexExampleSentenceTags",
        "MoFormTags",
        "CellarPropertyType",
        "CellarPropertyTypeFilter",
        "IFwMetaDataCacheManaged",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.CompareTo": {
      "class": "ProjectSettingsOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.Duplicate": {
      "class": "ProjectSettingsOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetAnalysisWSs": {
      "class": "ProjectSettingsOperations",
      "method": "GetAnalysisWSs",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetAnalysisWritingSystems": {
      "class": "ProjectSettingsOperations",
      "method": "GetAnalysisWritingSystems",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetDateCreated": {
      "class": "ProjectSettingsOperations",
      "method": "GetDateCreated",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetDateModified": {
      "class": "ProjectSettingsOperations",
      "method": "GetDateModified",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetDefaultFont": {
      "class": "ProjectSettingsOperations",
      "method": "GetDefaultFont",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetDefaultFontSize": {
      "class": "ProjectSettingsOperations",
      "method": "GetDefaultFontSize",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetDescription": {
      "class": "ProjectSettingsOperations",
      "method": "GetDescription",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetExtLinkRootDir": {
      "class": "ProjectSettingsOperations",
      "method": "GetExtLinkRootDir",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetInterfaceLanguage": {
      "class": "ProjectSettingsOperations",
      "method": "GetInterfaceLanguage",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetLinkedFilesRootDir": {
      "class": "ProjectSettingsOperations",
      "method": "GetLinkedFilesRootDir",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetProjectName": {
      "class": "ProjectSettingsOperations",
      "method": "GetProjectName",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetSyncableProperties": {
      "class": "ProjectSettingsOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetVernacularWSs": {
      "class": "ProjectSettingsOperations",
      "method": "GetVernacularWSs",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.GetVernacularWritingSystems": {
      "class": "ProjectSettingsOperations",
      "method": "GetVernacularWritingSystems",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.SetDefaultAnalysis": {
      "class": "ProjectSettingsOperations",
      "method": "SetDefaultAnalysis",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.SetDefaultFont": {
      "class": "ProjectSettingsOperations",
      "method": "SetDefaultFont",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.SetDefaultFontSize": {
      "class": "ProjectSettingsOperations",
      "method": "SetDefaultFontSize",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.SetDefaultVernacular": {
      "class": "ProjectSettingsOperations",
      "method": "SetDefaultVernacular",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.SetDescription": {
      "class": "ProjectSettingsOperations",
      "method": "SetDescription",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.SetExtLinkRootDir": {
      "class": "ProjectSettingsOperations",
      "method": "SetExtLinkRootDir",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.SetInterfaceLanguage": {
      "class": "ProjectSettingsOperations",
      "method": "SetInterfaceLanguage",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.SetLinkedFilesRootDir": {
      "class": "ProjectSettingsOperations",
      "method": "SetLinkedFilesRootDir",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.SetProjectName": {
      "class": "ProjectSettingsOperations",
      "method": "SetProjectName",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ProjectSettingsOperations.__init__": {
      "class": "ProjectSettingsOperations",
      "method": "__init__",
      "lcm_deps": [
        "ILangProject",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WritingSystemOperations.CompareTo": {
      "class": "WritingSystemOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.Create": {
      "class": "WritingSystemOperations",
      "method": "Create",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.Delete": {
      "class": "WritingSystemOperations",
      "method": "Delete",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.Duplicate": {
      "class": "WritingSystemOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.Exists": {
      "class": "WritingSystemOperations",
      "method": "Exists",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetAll": {
      "class": "WritingSystemOperations",
      "method": "GetAll",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetAnalysis": {
      "class": "WritingSystemOperations",
      "method": "GetAnalysis",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetBestString": {
      "class": "WritingSystemOperations",
      "method": "GetBestString",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetDefaultAnalysis": {
      "class": "WritingSystemOperations",
      "method": "GetDefaultAnalysis",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetDefaultVernacular": {
      "class": "WritingSystemOperations",
      "method": "GetDefaultVernacular",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetDisplayName": {
      "class": "WritingSystemOperations",
      "method": "GetDisplayName",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetFontName": {
      "class": "WritingSystemOperations",
      "method": "GetFontName",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetFontSize": {
      "class": "WritingSystemOperations",
      "method": "GetFontSize",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetLanguageTag": {
      "class": "WritingSystemOperations",
      "method": "GetLanguageTag",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetRightToLeft": {
      "class": "WritingSystemOperations",
      "method": "GetRightToLeft",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetSyncableProperties": {
      "class": "WritingSystemOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.GetVernacular": {
      "class": "WritingSystemOperations",
      "method": "GetVernacular",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.SetDefaultAnalysis": {
      "class": "WritingSystemOperations",
      "method": "SetDefaultAnalysis",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.SetDefaultVernacular": {
      "class": "WritingSystemOperations",
      "method": "SetDefaultVernacular",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.SetFontName": {
      "class": "WritingSystemOperations",
      "method": "SetFontName",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.SetFontSize": {
      "class": "WritingSystemOperations",
      "method": "SetFontSize",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.SetRightToLeft": {
      "class": "WritingSystemOperations",
      "method": "SetRightToLeft",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "WritingSystemOperations.__init__": {
      "class": "WritingSystemOperations",
      "method": "__init__",
      "lcm_deps": [
        "SpecialWritingSystemCodes",
        "ITsString",
        "TsStringUtils",
        "IMultiUnicode",
        "IMultiString"
      ]
    },
    "DiscourseOperations.AddRow": {
      "class": "DiscourseOperations",
      "method": "AddRow",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.CompareTo": {
      "class": "DiscourseOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.CreateChart": {
      "class": "DiscourseOperations",
      "method": "CreateChart",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.DeleteChart": {
      "class": "DiscourseOperations",
      "method": "DeleteChart",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.DeleteRow": {
      "class": "DiscourseOperations",
      "method": "DeleteRow",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.Duplicate": {
      "class": "DiscourseOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetAllCharts": {
      "class": "DiscourseOperations",
      "method": "GetAllCharts",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetCellContent": {
      "class": "DiscourseOperations",
      "method": "GetCellContent",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetCells": {
      "class": "DiscourseOperations",
      "method": "GetCells",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetChartName": {
      "class": "DiscourseOperations",
      "method": "GetChartName",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetChartType": {
      "class": "DiscourseOperations",
      "method": "GetChartType",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetGuid": {
      "class": "DiscourseOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetOwningText": {
      "class": "DiscourseOperations",
      "method": "GetOwningText",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetRowCount": {
      "class": "DiscourseOperations",
      "method": "GetRowCount",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetRows": {
      "class": "DiscourseOperations",
      "method": "GetRows",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.GetSyncableProperties": {
      "class": "DiscourseOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.SetCellContent": {
      "class": "DiscourseOperations",
      "method": "SetCellContent",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.SetChartName": {
      "class": "DiscourseOperations",
      "method": "SetChartName",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "DiscourseOperations.__init__": {
      "class": "DiscourseOperations",
      "method": "__init__",
      "lcm_deps": [
        "IDsConstChart",
        "IDsConstChartFactory",
        "IDsChart",
        "IDsDiscourseData",
        "IConstChartRow",
        "IConstChartRowFactory",
        "IConstChartWordGroup",
        "IConstChartWordGroupFactory",
        "IConstChartMovedTextMarker",
        "IConstChartMovedTextMarkerFactory",
        "IConstChartClauseMarker",
        "IConstChartClauseMarkerFactory",
        "IConstChartTag",
        "IText",
        "ICmPossibility",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.CompareTo": {
      "class": "ParagraphOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.Create": {
      "class": "ParagraphOperations",
      "method": "Create",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.Delete": {
      "class": "ParagraphOperations",
      "method": "Delete",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.Duplicate": {
      "class": "ParagraphOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.GetAll": {
      "class": "ParagraphOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.GetSegmentCount": {
      "class": "ParagraphOperations",
      "method": "GetSegmentCount",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.GetSegments": {
      "class": "ParagraphOperations",
      "method": "GetSegments",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.GetSyncableProperties": {
      "class": "ParagraphOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.GetText": {
      "class": "ParagraphOperations",
      "method": "GetText",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.InsertAt": {
      "class": "ParagraphOperations",
      "method": "InsertAt",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.SetText": {
      "class": "ParagraphOperations",
      "method": "SetText",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "ParagraphOperations.__init__": {
      "class": "ParagraphOperations",
      "method": "__init__",
      "lcm_deps": [
        "IText",
        "IStTxtPara",
        "IStTxtParaFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.CompareTo": {
      "class": "SegmentOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.Create": {
      "class": "SegmentOperations",
      "method": "Create",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.Delete": {
      "class": "SegmentOperations",
      "method": "Delete",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.Duplicate": {
      "class": "SegmentOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.Exists": {
      "class": "SegmentOperations",
      "method": "Exists",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.GetAll": {
      "class": "SegmentOperations",
      "method": "GetAll",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.GetAnalyses": {
      "class": "SegmentOperations",
      "method": "GetAnalyses",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.GetBaselineText": {
      "class": "SegmentOperations",
      "method": "GetBaselineText",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.GetBeginOffset": {
      "class": "SegmentOperations",
      "method": "GetBeginOffset",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.GetEndOffset": {
      "class": "SegmentOperations",
      "method": "GetEndOffset",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.GetFreeTranslation": {
      "class": "SegmentOperations",
      "method": "GetFreeTranslation",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.GetLiteralTranslation": {
      "class": "SegmentOperations",
      "method": "GetLiteralTranslation",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.GetNotes": {
      "class": "SegmentOperations",
      "method": "GetNotes",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.GetSyncableProperties": {
      "class": "SegmentOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.IsLabel": {
      "class": "SegmentOperations",
      "method": "IsLabel",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.MergeSegments": {
      "class": "SegmentOperations",
      "method": "MergeSegments",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.RebuildSegments": {
      "class": "SegmentOperations",
      "method": "RebuildSegments",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.SetBaselineText": {
      "class": "SegmentOperations",
      "method": "SetBaselineText",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.SetFreeTranslation": {
      "class": "SegmentOperations",
      "method": "SetFreeTranslation",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.SetIsLabel": {
      "class": "SegmentOperations",
      "method": "SetIsLabel",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.SetLiteralTranslation": {
      "class": "SegmentOperations",
      "method": "SetLiteralTranslation",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.SetOffsets": {
      "class": "SegmentOperations",
      "method": "SetOffsets",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.SplitSegment": {
      "class": "SegmentOperations",
      "method": "SplitSegment",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.ValidateSegments": {
      "class": "SegmentOperations",
      "method": "ValidateSegments",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "SegmentOperations.__init__": {
      "class": "SegmentOperations",
      "method": "__init__",
      "lcm_deps": [
        "ISegment",
        "ISegmentFactory",
        "IStTxtPara",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.AddMediaFile": {
      "class": "TextOperations",
      "method": "AddMediaFile",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.CompareTo": {
      "class": "TextOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.Create": {
      "class": "TextOperations",
      "method": "Create",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.Delete": {
      "class": "TextOperations",
      "method": "Delete",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.Duplicate": {
      "class": "TextOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.Exists": {
      "class": "TextOperations",
      "method": "Exists",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetAbbreviation": {
      "class": "TextOperations",
      "method": "GetAbbreviation",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetAll": {
      "class": "TextOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetContents": {
      "class": "TextOperations",
      "method": "GetContents",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetGenre": {
      "class": "TextOperations",
      "method": "GetGenre",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetIsTranslated": {
      "class": "TextOperations",
      "method": "GetIsTranslated",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetMediaFiles": {
      "class": "TextOperations",
      "method": "GetMediaFiles",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetName": {
      "class": "TextOperations",
      "method": "GetName",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetParagraphCount": {
      "class": "TextOperations",
      "method": "GetParagraphCount",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetParagraphs": {
      "class": "TextOperations",
      "method": "GetParagraphs",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.GetSyncableProperties": {
      "class": "TextOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.SetGenre": {
      "class": "TextOperations",
      "method": "SetGenre",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.SetIsTranslated": {
      "class": "TextOperations",
      "method": "SetIsTranslated",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.SetName": {
      "class": "TextOperations",
      "method": "SetName",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "TextOperations.__init__": {
      "class": "TextOperations",
      "method": "__init__",
      "lcm_deps": [
        "IText",
        "ITextFactory",
        "IStTextFactory",
        "ITextRepository",
        "ICmPossibility",
        "ICmMedia",
        "ICmMediaFactory",
        "ICmFolderFactory",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.AddGloss": {
      "class": "WfiAnalysisOperations",
      "method": "AddGloss",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.ApproveAnalysis": {
      "class": "WfiAnalysisOperations",
      "method": "ApproveAnalysis",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.CompareTo": {
      "class": "WfiAnalysisOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.Create": {
      "class": "WfiAnalysisOperations",
      "method": "Create",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.Delete": {
      "class": "WfiAnalysisOperations",
      "method": "Delete",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.Duplicate": {
      "class": "WfiAnalysisOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.Exists": {
      "class": "WfiAnalysisOperations",
      "method": "Exists",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetAgentEvaluation": {
      "class": "WfiAnalysisOperations",
      "method": "GetAgentEvaluation",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetAll": {
      "class": "WfiAnalysisOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetApprovalStatus": {
      "class": "WfiAnalysisOperations",
      "method": "GetApprovalStatus",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetCategory": {
      "class": "WfiAnalysisOperations",
      "method": "GetCategory",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetEvaluations": {
      "class": "WfiAnalysisOperations",
      "method": "GetEvaluations",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetGlossCount": {
      "class": "WfiAnalysisOperations",
      "method": "GetGlossCount",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetGlosses": {
      "class": "WfiAnalysisOperations",
      "method": "GetGlosses",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetGuid": {
      "class": "WfiAnalysisOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetHumanEvaluation": {
      "class": "WfiAnalysisOperations",
      "method": "GetHumanEvaluation",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetMorphBundleCount": {
      "class": "WfiAnalysisOperations",
      "method": "GetMorphBundleCount",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetMorphBundles": {
      "class": "WfiAnalysisOperations",
      "method": "GetMorphBundles",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetOwningWordform": {
      "class": "WfiAnalysisOperations",
      "method": "GetOwningWordform",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.GetSyncableProperties": {
      "class": "WfiAnalysisOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.IsComputerApproved": {
      "class": "WfiAnalysisOperations",
      "method": "IsComputerApproved",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.IsHumanApproved": {
      "class": "WfiAnalysisOperations",
      "method": "IsHumanApproved",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.RejectAnalysis": {
      "class": "WfiAnalysisOperations",
      "method": "RejectAnalysis",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.SetApprovalStatus": {
      "class": "WfiAnalysisOperations",
      "method": "SetApprovalStatus",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiAnalysisRepository",
        "IWfiWordform",
        "IWfiGlossFactory",
        "IWfiMorphBundleFactory",
        "IPartOfSpeech",
        "ICmAgentEvaluation",
        "ICmAgentEvaluationFactory",
        "ICmAgent",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.SetCategory": {
      "class": "WfiAnalysisOperations",
      "method": "SetCategory",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.__init__": {
      "class": "WfiAnalysisOperations",
      "method": "__init__",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.ClearForm": {
      "class": "WfiGlossOperations",
      "method": "ClearForm",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.CompareTo": {
      "class": "WfiGlossOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.CopyGloss": {
      "class": "WfiGlossOperations",
      "method": "CopyGloss",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.Create": {
      "class": "WfiGlossOperations",
      "method": "Create",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.Delete": {
      "class": "WfiGlossOperations",
      "method": "Delete",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.Duplicate": {
      "class": "WfiGlossOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.Exists": {
      "class": "WfiGlossOperations",
      "method": "Exists",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.Find": {
      "class": "WfiGlossOperations",
      "method": "Find",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.GetAll": {
      "class": "WfiGlossOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.GetAllForms": {
      "class": "WfiGlossOperations",
      "method": "GetAllForms",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.GetBestForm": {
      "class": "WfiGlossOperations",
      "method": "GetBestForm",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.GetCount": {
      "class": "WfiGlossOperations",
      "method": "GetCount",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.GetForm": {
      "class": "WfiGlossOperations",
      "method": "GetForm",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.GetGuid": {
      "class": "WfiGlossOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.GetOwningAnalysis": {
      "class": "WfiGlossOperations",
      "method": "GetOwningAnalysis",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.GetSyncableProperties": {
      "class": "WfiGlossOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.Reorder": {
      "class": "WfiGlossOperations",
      "method": "Reorder",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.SetForm": {
      "class": "WfiGlossOperations",
      "method": "SetForm",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.__init__": {
      "class": "WfiGlossOperations",
      "method": "__init__",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.CompareTo": {
      "class": "WfiMorphBundleOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.Create": {
      "class": "WfiMorphBundleOperations",
      "method": "Create",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.Delete": {
      "class": "WfiMorphBundleOperations",
      "method": "Delete",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.Duplicate": {
      "class": "WfiMorphBundleOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetAll": {
      "class": "WfiMorphBundleOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetForm": {
      "class": "WfiMorphBundleOperations",
      "method": "GetForm",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetGloss": {
      "class": "WfiMorphBundleOperations",
      "method": "GetGloss",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetGuid": {
      "class": "WfiMorphBundleOperations",
      "method": "GetGuid",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetInflType": {
      "class": "WfiMorphBundleOperations",
      "method": "GetInflType",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetInflectionClass": {
      "class": "WfiMorphBundleOperations",
      "method": "GetInflectionClass",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetMSA": {
      "class": "WfiMorphBundleOperations",
      "method": "GetMSA",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetMorphType": {
      "class": "WfiMorphBundleOperations",
      "method": "GetMorphType",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetOwningAnalysis": {
      "class": "WfiMorphBundleOperations",
      "method": "GetOwningAnalysis",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetSense": {
      "class": "WfiMorphBundleOperations",
      "method": "GetSense",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetSyncableProperties": {
      "class": "WfiMorphBundleOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.Reorder": {
      "class": "WfiMorphBundleOperations",
      "method": "Reorder",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.SetForm": {
      "class": "WfiMorphBundleOperations",
      "method": "SetForm",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.SetGloss": {
      "class": "WfiMorphBundleOperations",
      "method": "SetGloss",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.SetInflType": {
      "class": "WfiMorphBundleOperations",
      "method": "SetInflType",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.SetInflectionClass": {
      "class": "WfiMorphBundleOperations",
      "method": "SetInflectionClass",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.SetMSA": {
      "class": "WfiMorphBundleOperations",
      "method": "SetMSA",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.SetMorphType": {
      "class": "WfiMorphBundleOperations",
      "method": "SetMorphType",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphSynAnalysis",
        "IMoMorphType",
        "IMoInflClass",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.SetSense": {
      "class": "WfiMorphBundleOperations",
      "method": "SetSense",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.__init__": {
      "class": "WfiMorphBundleOperations",
      "method": "__init__",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.ApproveSpelling": {
      "class": "WordformOperations",
      "method": "ApproveSpelling",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.CompareTo": {
      "class": "WordformOperations",
      "method": "CompareTo",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.Create": {
      "class": "WordformOperations",
      "method": "Create",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.Delete": {
      "class": "WordformOperations",
      "method": "Delete",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.Duplicate": {
      "class": "WordformOperations",
      "method": "Duplicate",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.Exists": {
      "class": "WordformOperations",
      "method": "Exists",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.Find": {
      "class": "WordformOperations",
      "method": "Find",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetAll": {
      "class": "WordformOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetAllUnapproved": {
      "class": "WordformOperations",
      "method": "GetAllUnapproved",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetAllWithStatus": {
      "class": "WordformOperations",
      "method": "GetAllWithStatus",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetAnalyses": {
      "class": "WordformOperations",
      "method": "GetAnalyses",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetChecksum": {
      "class": "WordformOperations",
      "method": "GetChecksum",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetForm": {
      "class": "WordformOperations",
      "method": "GetForm",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetOccurrenceCount": {
      "class": "WordformOperations",
      "method": "GetOccurrenceCount",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetOccurrences": {
      "class": "WordformOperations",
      "method": "GetOccurrences",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetSpellingStatus": {
      "class": "WordformOperations",
      "method": "GetSpellingStatus",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.GetSyncableProperties": {
      "class": "WordformOperations",
      "method": "GetSyncableProperties",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.SetForm": {
      "class": "WordformOperations",
      "method": "SetForm",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.SetSpellingStatus": {
      "class": "WordformOperations",
      "method": "SetSpellingStatus",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WordformOperations.__init__": {
      "class": "WordformOperations",
      "method": "__init__",
      "lcm_deps": [
        "IWfiWordformRepository",
        "IWfiWordformFactory",
        "IWfiWordform",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.Approve": {
      "class": "WfiAnalysisOperations",
      "method": "Approve",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiAnalysisOperations.Find": {
      "class": "WfiAnalysisOperations",
      "method": "Find",
      "lcm_deps": [
        "IWfiAnalysis",
        "IWfiAnalysisFactory",
        "IWfiWordform",
        "IWfiMorphBundle",
        "IPartOfSpeech",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.Approve": {
      "class": "WfiGlossOperations",
      "method": "Approve",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiGlossOperations.IsHumanApproved": {
      "class": "WfiGlossOperations",
      "method": "IsHumanApproved",
      "lcm_deps": [
        "IWfiGloss",
        "IWfiGlossFactory",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.Find": {
      "class": "WfiMorphBundleOperations",
      "method": "Find",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.GetMorphemeType": {
      "class": "WfiMorphBundleOperations",
      "method": "GetMorphemeType",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiMorphBundleOperations.SetMorphemeType": {
      "class": "WfiMorphBundleOperations",
      "method": "SetMorphemeType",
      "lcm_deps": [
        "IWfiMorphBundle",
        "IWfiMorphBundleFactory",
        "IWfiAnalysis",
        "ILexSense",
        "IMoMorphType",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.Create": {
      "class": "WfiWordformOperations",
      "method": "Create",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.Delete": {
      "class": "WfiWordformOperations",
      "method": "Delete",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.Find": {
      "class": "WfiWordformOperations",
      "method": "Find",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.FindByHvo": {
      "class": "WfiWordformOperations",
      "method": "FindByHvo",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.FindOrCreate": {
      "class": "WfiWordformOperations",
      "method": "FindOrCreate",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.GetAll": {
      "class": "WfiWordformOperations",
      "method": "GetAll",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.GetAnalyses": {
      "class": "WfiWordformOperations",
      "method": "GetAnalyses",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.GetApprovedAnalysis": {
      "class": "WfiWordformOperations",
      "method": "GetApprovedAnalysis",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.GetForm": {
      "class": "WfiWordformOperations",
      "method": "GetForm",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.GetOccurrences": {
      "class": "WfiWordformOperations",
      "method": "GetOccurrences",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.SetApprovedAnalysis": {
      "class": "WfiWordformOperations",
      "method": "SetApprovedAnalysis",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    },
    "WfiWordformOperations.__init__": {
      "class": "WfiWordformOperations",
      "method": "__init__",
      "lcm_deps": [
        "IWfiWordform",
        "IWfiWordformFactory",
        "IWfiWordformRepository",
        "IWfiAnalysis",
        "ITsString",
        "TsStringUtils"
      ]
    }
  }
}